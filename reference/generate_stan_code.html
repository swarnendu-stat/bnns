<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Internal function to generate Stan Code Based on Output Activation Function — generate_stan_code • bnns</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Internal function to generate Stan Code Based on Output Activation Function — generate_stan_code"><meta name="description" content="This function serves as a wrapper to generate Stan code for Bayesian neural networks
tailored to different types of response variables. Based on the specified output
activation function (out_act_fn), it delegates the code generation to the
appropriate function for continuous, binary, or categorical response models."><meta property="og:description" content="This function serves as a wrapper to generate Stan code for Bayesian neural networks
tailored to different types of response variables. Based on the specified output
activation function (out_act_fn), it delegates the code generation to the
appropriate function for continuous, binary, or categorical response models."><meta property="og:image" content="https://swarnendu-stat.github.io/bnns/logo.png"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">bnns</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.2</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/bnns.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/benchmarking.html">Benchmarking bnns</a></li>
    <li><a class="dropdown-item" href="../articles/clin_trial_app.html">Using Bayesian Neural Networks in Clinical Trials</a></li>
    <li><a class="dropdown-item" href="../articles/common_applications.html">Common Application Areas of bnns</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/swarnendu-stat/bnns/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Internal function to generate Stan Code Based on Output Activation Function</h1>
      <small class="dont-index">Source: <a href="https://github.com/swarnendu-stat/bnns/blob/v0.1.2/R/generate_stan_code.R" class="external-link"><code>R/generate_stan_code.R</code></a></small>
      <div class="d-none name"><code>generate_stan_code.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>This function serves as a wrapper to generate Stan code for Bayesian neural networks
tailored to different types of response variables. Based on the specified output
activation function (<code>out_act_fn</code>), it delegates the code generation to the
appropriate function for continuous, binary, or categorical response models.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">generate_stan_code</span><span class="op">(</span><span class="va">num_layers</span>, <span class="va">nodes</span>, out_act_fn <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-num-layers">num_layers<a class="anchor" aria-label="anchor" href="#arg-num-layers"></a></dt>
<dd><p>An integer specifying the number of hidden layers in the neural network.</p></dd>


<dt id="arg-nodes">nodes<a class="anchor" aria-label="anchor" href="#arg-nodes"></a></dt>
<dd><p>A vector of integers, where each element specifies the number of nodes
in the corresponding hidden layer. The length of the vector must match <code>num_layers</code>.</p></dd>


<dt id="arg-out-act-fn">out_act_fn<a class="anchor" aria-label="anchor" href="#arg-out-act-fn"></a></dt>
<dd><p>An integer specifying the output activation function, determining
the type of response variable. Supported values are:</p><ul><li><p><code>1</code>: Continuous response (identity function as output layer).</p></li>
<li><p><code>2</code>: Binary response (sigmoid function as output layer).</p></li>
<li><p><code>3</code>: Categorical response (softmax function as output layer).</p></li>
</ul></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>A character string containing the Stan code for the specified Bayesian neural network model.
The Stan model includes data, parameters, transformed parameters, and model blocks,
adjusted based on the specified response type.</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>This function dynamically calls one of the following functions based on the value of <code>out_act_fn</code>:</p><ul><li><p><strong>Continuous response:</strong> Calls <code>generate_stan_code_cont</code>.</p></li>
<li><p><strong>Binary response:</strong> Calls <code>generate_stan_code_bin</code>.</p></li>
<li><p><strong>Categorical response:</strong> Calls <code>generate_stan_code_cat</code>.</p></li>
</ul><p>If an unsupported value is provided for <code>out_act_fn</code>, the function throws an error.
The generated Stan code is adapted for the response type, including appropriate
likelihood functions and transformations.</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index">
<ul><li><p><a href="generate_stan_code_cont.html">generate_stan_code_cont</a>: For continuous response models.</p></li>
<li><p><a href="generate_stan_code_bin.html">generate_stan_code_bin</a>: For binary response models.</p></li>
<li><p><a href="generate_stan_code_cat.html">generate_stan_code_cat</a>: For categorical response models.</p></li>
</ul></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="co"># Generate Stan code for a continuous response model</span></span></span>
<span class="r-in"><span><span class="va">stan_code</span> <span class="op">&lt;-</span> <span class="fu">generate_stan_code</span><span class="op">(</span>num_layers <span class="op">=</span> <span class="fl">2</span>, nodes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">5</span><span class="op">)</span>, out_act_fn <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">stan_code</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; n;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; m;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; L;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; nodes[L];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, m] X;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; act_fn[L];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[m, nodes[1]] w1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[nodes[1]] b1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[nodes[1], nodes[2]] w2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[nodes[2]] b2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[nodes[L]] w_out;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real b_out;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; sigma;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[1]] z1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[1]] a1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[2]] z2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[2]] a2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] y_hat;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   z1 = X * w1 + rep_matrix(b1', n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (act_fn[1] == 1) a1 = tanh(z1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[1] == 2) a1 = inv_logit(z1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[1] == 3) a1 = log(1 + exp(z1));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[1] == 4) a1 = fmax(rep_matrix(0, n, nodes[1]), z1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else a1 = z1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   z2 = a1 * w2 + rep_matrix(b2', n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (act_fn[2] == 1) a2 = tanh(z2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[2] == 2) a2 = inv_logit(z2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[2] == 3) a2 = log(1 + exp(z2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[2] == 4) a2 = fmax(rep_matrix(0, n, nodes[2]), z2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else a2 = z2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y_hat = a2 * w_out + b_out;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(w1) ~ PRIOR_WEIGHT;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b1 ~ PRIOR_BIAS;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(w2) ~ PRIOR_WEIGHT;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b2 ~ PRIOR_BIAS;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   w_out ~ PRIOR_WEIGHT;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_out ~ PRIOR_BIAS;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~ PRIOR_SIGMA;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y ~ normal(y_hat, sigma);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Generate Stan code for a binary response model</span></span></span>
<span class="r-in"><span><span class="va">stan_code</span> <span class="op">&lt;-</span> <span class="fu">generate_stan_code</span><span class="op">(</span>num_layers <span class="op">=</span> <span class="fl">2</span>, nodes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">5</span><span class="op">)</span>, out_act_fn <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">stan_code</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; n;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; m;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; L;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; nodes[L];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, m] X;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n] int&lt;lower=0, upper=1&gt; y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; act_fn[L];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[m, nodes[1]] w1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[nodes[1]] b1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[nodes[1], nodes[2]] w2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[nodes[2]] b2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[nodes[L]] w_out;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real b_out;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[1]] z1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[1]] a1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[2]] z2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[2]] a2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[n] y_hat;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   z1 = X * w1 + rep_matrix(b1', n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (act_fn[1] == 1) a1 = tanh(z1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[1] == 2) a1 = inv_logit(z1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[1] == 3) a1 = log(1 + exp(z1));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[1] == 4) a1 = fmax(rep_matrix(0, n, nodes[1]), z1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else a1 = z1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   z2 = a1 * w2 + rep_matrix(b2', n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (act_fn[2] == 1) a2 = tanh(z2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[2] == 2) a2 = inv_logit(z2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[2] == 3) a2 = log(1 + exp(z2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[2] == 4) a2 = fmax(rep_matrix(0, n, nodes[2]), z2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else a2 = z2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y_hat = a2 * w_out + b_out;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(w1) ~ PRIOR_WEIGHT;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b1 ~ PRIOR_BIAS;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(w2) ~ PRIOR_WEIGHT;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b2 ~ PRIOR_BIAS;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   w_out ~ PRIOR_WEIGHT;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_out ~ PRIOR_BIAS;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y ~ bernoulli_logit(y_hat);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Generate Stan code for a categorical response model</span></span></span>
<span class="r-in"><span><span class="va">stan_code</span> <span class="op">&lt;-</span> <span class="fu">generate_stan_code</span><span class="op">(</span>num_layers <span class="op">=</span> <span class="fl">2</span>, nodes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">5</span><span class="op">)</span>, out_act_fn <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">stan_code</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; n;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; m;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; L;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; nodes[L];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, m] X;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   array[n] int&lt;lower=1&gt; y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; act_fn[L];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=2&gt; K; // Number of categories</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[m, nodes[1]] w1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[nodes[1]] b1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[nodes[1], nodes[2]] w2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[nodes[2]] b2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[nodes[L], K] w_out;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[K] b_out;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[1]] z1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[1]] a1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[2]] z2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, nodes[2]] a2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[n, K] y_hat;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   z1 = X * w1 + rep_matrix(b1', n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (act_fn[1] == 1) a1 = tanh(z1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[1] == 2) a1 = inv_logit(z1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[1] == 3) a1 = log(1 + exp(z1));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[1] == 4) a1 = fmax(rep_matrix(0, n, nodes[1]), z1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else a1 = z1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   z2 = a1 * w2 + rep_matrix(b2', n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   if (act_fn[2] == 1) a2 = tanh(z2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[2] == 2) a2 = inv_logit(z2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[2] == 3) a2 = log(1 + exp(z2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else if (act_fn[2] == 4) a2 = fmax(rep_matrix(0, n, nodes[2]), z2);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   else a2 = z2;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   y_hat = a2 * w_out + rep_matrix(b_out', n);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(w1) ~ PRIOR_WEIGHT;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b1 ~ PRIOR_BIAS;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(w2) ~ PRIOR_WEIGHT;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b2 ~ PRIOR_BIAS;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(w_out) ~ PRIOR_WEIGHT;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   b_out ~ PRIOR_BIAS;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:n) y[i] ~ categorical_logit(y_hat[i]');</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Swarnendu Chatterjee.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer></div>





  </body></html>

