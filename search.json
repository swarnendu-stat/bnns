[{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright [yyyy] [name of copyright owner]  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Getting Started with the bnns Package","text":"bnns package provides efficient user-friendly implementation Bayesian Neural Networks (BNNs) regression, binary classification, multiclass classification problems. integrating Bayesian inference, bnns allows uncertainty quantification predictions robust parameter estimation. vignette covers: 1. Installing loading package 2. Preparing data 3. Fitting BNN model 4. Summarizing model 5. Making predictions 6. Model evaluation","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"installation","dir":"Articles","previous_headings":"","what":"1. Installation","title":"Getting Started with the bnns Package","text":"install package, use following commands: Load package R session:","code":"# Install from CRAN (if available) #  install.packages(\"bnns\")  # Or install the development version from GitHub # devtools::install_github(\"swarnendu-stat/bnns\") library(bnns)"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"preparing-the-data","dir":"Articles","previous_headings":"","what":"2. Preparing the Data","title":"Getting Started with the bnns Package","text":"bnns package expects data form matrices predictors vector responses. ’s example generating synthetic data: binary multiclass classification:","code":"# Generate training data set.seed(123) df <- data.frame(x1 = runif(10), x2 = runif(10), y = rnorm(10)) # Binary classification response df$y_bin <- sample(0:1, 10, replace = TRUE)  # Multiclass classification response df$y_cat <- factor(sample(letters[1:3], 10, replace = TRUE))  # 3 classes"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"fitting-a-bayesian-neural-network-model","dir":"Articles","previous_headings":"","what":"3. Fitting a Bayesian Neural Network Model","title":"Getting Started with the bnns Package","text":"Fit Bayesian Neural Network using bnns() function. Specify network architecture using arguments like number layers (L), nodes per layer (nodes), activation functions (act_fn).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"regression-example","dir":"Articles","previous_headings":"3. Fitting a Bayesian Neural Network Model","what":"Regression Example","title":"Getting Started with the bnns Package","text":"","code":"model_reg <- bnns(   y ~ -1 + x1 + x2,   data = df,   L = 2,                  # Number of hidden layers   nodes = c(16, 8),       # Nodes per layer   act_fn = c(2, 3),       # Activation functions: 2 = Sigmoid, 3 = ReLU   out_act_fn = 1,          # Output activation function: 1 = Identity (for regression)   iter = 2e2,    warmup = 1e2,    chains = 1 ) #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found #>  #> TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW. #> OS: x86_64, linux-gnu; rstan: 2.32.6; Rcpp: 1.0.13.1; inline: 0.3.20  #>  >> setting environment variables:  #> PKG_LIBS =  '/home/runner/work/_temp/Library/rstan/lib//libStanServices.a' -L'/home/runner/work/_temp/Library/StanHeaders/lib/' -lStanHeaders -L'/home/runner/work/_temp/Library/RcppParallel/lib/' -ltbb  #> PKG_CPPFLAGS =   -I\"/home/runner/work/_temp/Library/Rcpp/include/\"  -I\"/home/runner/work/_temp/Library/RcppEigen/include/\"  -I\"/home/runner/work/_temp/Library/RcppEigen/include/unsupported\"  -I\"/home/runner/work/_temp/Library/BH/include\" -I\"/home/runner/work/_temp/Library/StanHeaders/include/src/\"  -I\"/home/runner/work/_temp/Library/StanHeaders/include/\"  -I\"/home/runner/work/_temp/Library/RcppParallel/include/\"  -I\"/home/runner/work/_temp/Library/rstan/include\" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/runner/work/_temp/Library/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1  #>  >> Program source : #>  #>    1 :  #>    2 : // includes from the plugin #>    3 : // [[Rcpp::plugins(cpp14)]] #>    4 :  #>    5 :  #>    6 : // user includes #>    7 : #include <Rcpp.h> #>    8 : using namespace Rcpp; #>    9 : #ifndef MODELS_HPP #>   10 : #define MODELS_HPP #>   11 : #define STAN__SERVICES__COMMAND_HPP #>   12 : #include <rstan/rstaninc.hpp> #>   13 : #ifndef USE_STANC3 #>   14 : #define USE_STANC3 #>   15 : #endif #>   16 : // Code generated by stanc v2.32.2 #>   17 : #include <stan/model/model_header.hpp> #>   18 : namespace model1d207ae671eb__namespace { #>   19 : using stan::model::model_base_crtp; #>   20 : using namespace stan::math; #>   21 : stan::math::profile_map profiles__; #>   22 : static constexpr std::array<const char*, 66> locations_array__ = #>   23 :   {\" (found before start of program)\", #>   24 :   \" (in 'anon_model', line 11, column 2 to column 25)\", #>   25 :   \" (in 'anon_model', line 12, column 2 to column 22)\", #>   26 :   \" (in 'anon_model', line 13, column 2 to column 32)\", #>   27 :   \" (in 'anon_model', line 14, column 2 to column 22)\", #>   28 :   \" (in 'anon_model', line 15, column 2 to column 25)\", #>   29 :   \" (in 'anon_model', line 16, column 2 to column 13)\", #>   30 :   \" (in 'anon_model', line 17, column 2 to column 22)\", #>   31 :   \" (in 'anon_model', line 20, column 2 to column 25)\", #>   32 :   \" (in 'anon_model', line 21, column 2 to column 25)\", #>   33 :   \" (in 'anon_model', line 22, column 2 to column 25)\", #>   34 :   \" (in 'anon_model', line 23, column 2 to column 25)\", #>   35 :   \" (in 'anon_model', line 24, column 2 to column 18)\", #>   36 :   \" (in 'anon_model', line 25, column 2 to column 35)\", #>   37 :   \" (in 'anon_model', line 29, column 7 to column 49)\", #>   38 :   \" (in 'anon_model', line 28, column 27 to column 49)\", #>   39 :   \" (in 'anon_model', line 28, column 7 to line 29, column 49)\", #>   40 :   \" (in 'anon_model', line 27, column 27 to column 46)\", #>   41 :   \" (in 'anon_model', line 27, column 7 to line 29, column 49)\", #>   42 :   \" (in 'anon_model', line 26, column 22 to column 36)\", #>   43 :   \" (in 'anon_model', line 26, column 2 to line 29, column 49)\", #>   44 :   \" (in 'anon_model', line 30, column 2 to column 36)\", #>   45 :   \" (in 'anon_model', line 34, column 7 to column 49)\", #>   46 :   \" (in 'anon_model', line 33, column 27 to column 49)\", #>   47 :   \" (in 'anon_model', line 33, column 7 to line 34, column 49)\", #>   48 :   \" (in 'anon_model', line 32, column 27 to column 46)\", #>   49 :   \" (in 'anon_model', line 32, column 7 to line 34, column 49)\", #>   50 :   \" (in 'anon_model', line 31, column 22 to column 36)\", #>   51 :   \" (in 'anon_model', line 31, column 2 to line 34, column 49)\", #>   52 :   \" (in 'anon_model', line 35, column 2 to column 29)\", #>   53 :   \" (in 'anon_model', line 38, column 2 to column 31)\", #>   54 :   \" (in 'anon_model', line 39, column 2 to column 20)\", #>   55 :   \" (in 'anon_model', line 40, column 2 to column 31)\", #>   56 :   \" (in 'anon_model', line 41, column 2 to column 20)\", #>   57 :   \" (in 'anon_model', line 42, column 2 to column 23)\", #>   58 :   \" (in 'anon_model', line 43, column 2 to column 23)\", #>   59 :   \" (in 'anon_model', line 44, column 2 to column 23)\", #>   60 :   \" (in 'anon_model', line 45, column 2 to column 27)\", #>   61 :   \" (in 'anon_model', line 2, column 2 to column 17)\", #>   62 :   \" (in 'anon_model', line 3, column 2 to column 17)\", #>   63 :   \" (in 'anon_model', line 4, column 2 to column 17)\", #>   64 :   \" (in 'anon_model', line 5, column 21 to column 22)\", #>   65 :   \" (in 'anon_model', line 5, column 2 to column 24)\", #>   66 :   \" (in 'anon_model', line 6, column 9 to column 10)\", #>   67 :   \" (in 'anon_model', line 6, column 12 to column 13)\", #>   68 :   \" (in 'anon_model', line 6, column 2 to column 17)\", #>   69 :   \" (in 'anon_model', line 7, column 9 to column 10)\", #>   70 :   \" (in 'anon_model', line 7, column 2 to column 14)\", #>   71 :   \" (in 'anon_model', line 8, column 22 to column 23)\", #>   72 :   \" (in 'anon_model', line 8, column 2 to column 25)\", #>   73 :   \" (in 'anon_model', line 11, column 9 to column 10)\", #>   74 :   \" (in 'anon_model', line 11, column 12 to column 20)\", #>   75 :   \" (in 'anon_model', line 12, column 9 to column 17)\", #>   76 :   \" (in 'anon_model', line 13, column 9 to column 17)\", #>   77 :   \" (in 'anon_model', line 13, column 19 to column 27)\", #>   78 :   \" (in 'anon_model', line 14, column 9 to column 17)\", #>   79 :   \" (in 'anon_model', line 15, column 9 to column 17)\", #>   80 :   \" (in 'anon_model', line 20, column 9 to column 10)\", #>   81 :   \" (in 'anon_model', line 20, column 12 to column 20)\", #>   82 :   \" (in 'anon_model', line 21, column 9 to column 10)\", #>   83 :   \" (in 'anon_model', line 21, column 12 to column 20)\", #>   84 :   \" (in 'anon_model', line 22, column 9 to column 10)\", #>   85 :   \" (in 'anon_model', line 22, column 12 to column 20)\", #>   86 :   \" (in 'anon_model', line 23, column 9 to column 10)\", #>   87 :   \" (in 'anon_model', line 23, column 12 to column 20)\", #>   88 :   \" (in 'anon_model', line 24, column 9 to column 10)\"}; #>   89 : class model1d207ae671eb_ final : public model_base_crtp<model1d207ae671eb_> { #>   90 : private: #>   91 :   int n; #>   92 :   int m; #>   93 :   int L; #>   94 :   std::vector<int> nodes; #>   95 :   Eigen::Matrix<double,-1,-1> X_data__; #>   96 :   Eigen::Matrix<double,-1,1> y_data__; #>   97 :   std::vector<int> act_fn; #>   98 :   int w1_2dim__; #>   99 :   int b1_1dim__; #>  100 :   int w2_1dim__; #>  101 :   int w2_2dim__; #>  102 :   int b2_1dim__; #>  103 :   int w_out_1dim__; #>  104 :   int z1_2dim__; #>  105 :   int a1_2dim__; #>  106 :   int z2_2dim__; #>  107 :   int a2_2dim__; #>  108 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> X{nullptr, 0, 0}; #>  109 :   Eigen::Map<Eigen::Matrix<double,-1,1>> y{nullptr, 0}; #>  110 : public: #>  111 :   ~model1d207ae671eb_() {} #>  112 :   model1d207ae671eb_(stan::io::var_context& context__, unsigned int #>  113 :                      random_seed__ = 0, std::ostream* pstream__ = nullptr) #>  114 :       : model_base_crtp(0) { #>  115 :     int current_statement__ = 0; #>  116 :     using local_scalar_t__ = double; #>  117 :     boost::ecuyer1988 base_rng__ = #>  118 :       stan::services::util::create_rng(random_seed__, 0); #>  119 :     // suppress unused var warning #>  120 :     (void) base_rng__; #>  121 :     static constexpr const char* function__ = #>  122 :       \"model1d207ae671eb__namespace::model1d207ae671eb_\"; #>  123 :     // suppress unused var warning #>  124 :     (void) function__; #>  125 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  126 :     // suppress unused var warning #>  127 :     (void) DUMMY_VAR__; #>  128 :     try { #>  129 :       int pos__ = std::numeric_limits<int>::min(); #>  130 :       pos__ = 1; #>  131 :       current_statement__ = 38; #>  132 :       context__.validate_dims(\"data initialization\", \"n\", \"int\", #>  133 :         std::vector<size_t>{}); #>  134 :       n = std::numeric_limits<int>::min(); #>  135 :       current_statement__ = 38; #>  136 :       n = context__.vals_i(\"n\")[(1 - 1)]; #>  137 :       current_statement__ = 38; #>  138 :       stan::math::check_greater_or_equal(function__, \"n\", n, 1); #>  139 :       current_statement__ = 39; #>  140 :       context__.validate_dims(\"data initialization\", \"m\", \"int\", #>  141 :         std::vector<size_t>{}); #>  142 :       m = std::numeric_limits<int>::min(); #>  143 :       current_statement__ = 39; #>  144 :       m = context__.vals_i(\"m\")[(1 - 1)]; #>  145 :       current_statement__ = 39; #>  146 :       stan::math::check_greater_or_equal(function__, \"m\", m, 1); #>  147 :       current_statement__ = 40; #>  148 :       context__.validate_dims(\"data initialization\", \"L\", \"int\", #>  149 :         std::vector<size_t>{}); #>  150 :       L = std::numeric_limits<int>::min(); #>  151 :       current_statement__ = 40; #>  152 :       L = context__.vals_i(\"L\")[(1 - 1)]; #>  153 :       current_statement__ = 40; #>  154 :       stan::math::check_greater_or_equal(function__, \"L\", L, 1); #>  155 :       current_statement__ = 41; #>  156 :       stan::math::validate_non_negative_index(\"nodes\", \"L\", L); #>  157 :       current_statement__ = 42; #>  158 :       context__.validate_dims(\"data initialization\", \"nodes\", \"int\", #>  159 :         std::vector<size_t>{static_cast<size_t>(L)}); #>  160 :       nodes = std::vector<int>(L, std::numeric_limits<int>::min()); #>  161 :       current_statement__ = 42; #>  162 :       nodes = context__.vals_i(\"nodes\"); #>  163 :       current_statement__ = 42; #>  164 :       stan::math::check_greater_or_equal(function__, \"nodes\", nodes, 1); #>  165 :       current_statement__ = 43; #>  166 :       stan::math::validate_non_negative_index(\"X\", \"n\", n); #>  167 :       current_statement__ = 44; #>  168 :       stan::math::validate_non_negative_index(\"X\", \"m\", m); #>  169 :       current_statement__ = 45; #>  170 :       context__.validate_dims(\"data initialization\", \"X\", \"double\", #>  171 :         std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m)}); #>  172 :       X_data__ = Eigen::Matrix<double,-1,-1>::Constant(n, m, #>  173 :                    std::numeric_limits<double>::quiet_NaN()); #>  174 :       new (&X) Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_data__.data(), n, m); #>  175 :       { #>  176 :         std::vector<local_scalar_t__> X_flat__; #>  177 :         current_statement__ = 45; #>  178 :         X_flat__ = context__.vals_r(\"X\"); #>  179 :         current_statement__ = 45; #>  180 :         pos__ = 1; #>  181 :         current_statement__ = 45; #>  182 :         for (int sym1__ = 1; sym1__ <= m; ++sym1__) { #>  183 :           current_statement__ = 45; #>  184 :           for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  185 :             current_statement__ = 45; #>  186 :             stan::model::assign(X, X_flat__[(pos__ - 1)], #>  187 :               \"assigning variable X\", stan::model::index_uni(sym2__), #>  188 :               stan::model::index_uni(sym1__)); #>  189 :             current_statement__ = 45; #>  190 :             pos__ = (pos__ + 1); #>  191 :           } #>  192 :         } #>  193 :       } #>  194 :       current_statement__ = 46; #>  195 :       stan::math::validate_non_negative_index(\"y\", \"n\", n); #>  196 :       current_statement__ = 47; #>  197 :       context__.validate_dims(\"data initialization\", \"y\", \"double\", #>  198 :         std::vector<size_t>{static_cast<size_t>(n)}); #>  199 :       y_data__ = Eigen::Matrix<double,-1,1>::Constant(n, #>  200 :                    std::numeric_limits<double>::quiet_NaN()); #>  201 :       new (&y) Eigen::Map<Eigen::Matrix<double,-1,1>>(y_data__.data(), n); #>  202 :       { #>  203 :         std::vector<local_scalar_t__> y_flat__; #>  204 :         current_statement__ = 47; #>  205 :         y_flat__ = context__.vals_r(\"y\"); #>  206 :         current_statement__ = 47; #>  207 :         pos__ = 1; #>  208 :         current_statement__ = 47; #>  209 :         for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #>  210 :           current_statement__ = 47; #>  211 :           stan::model::assign(y, y_flat__[(pos__ - 1)], #>  212 :             \"assigning variable y\", stan::model::index_uni(sym1__)); #>  213 :           current_statement__ = 47; #>  214 :           pos__ = (pos__ + 1); #>  215 :         } #>  216 :       } #>  217 :       current_statement__ = 48; #>  218 :       stan::math::validate_non_negative_index(\"act_fn\", \"L\", L); #>  219 :       current_statement__ = 49; #>  220 :       context__.validate_dims(\"data initialization\", \"act_fn\", \"int\", #>  221 :         std::vector<size_t>{static_cast<size_t>(L)}); #>  222 :       act_fn = std::vector<int>(L, std::numeric_limits<int>::min()); #>  223 :       current_statement__ = 49; #>  224 :       act_fn = context__.vals_i(\"act_fn\"); #>  225 :       current_statement__ = 49; #>  226 :       stan::math::check_greater_or_equal(function__, \"act_fn\", act_fn, 1); #>  227 :       current_statement__ = 50; #>  228 :       stan::math::validate_non_negative_index(\"w1\", \"m\", m); #>  229 :       current_statement__ = 51; #>  230 :       w1_2dim__ = std::numeric_limits<int>::min(); #>  231 :       current_statement__ = 51; #>  232 :       w1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  233 :                     stan::model::index_uni(1)); #>  234 :       current_statement__ = 51; #>  235 :       stan::math::validate_non_negative_index(\"w1\", \"nodes[1]\", w1_2dim__); #>  236 :       current_statement__ = 52; #>  237 :       b1_1dim__ = std::numeric_limits<int>::min(); #>  238 :       current_statement__ = 52; #>  239 :       b1_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  240 :                     stan::model::index_uni(1)); #>  241 :       current_statement__ = 52; #>  242 :       stan::math::validate_non_negative_index(\"b1\", \"nodes[1]\", b1_1dim__); #>  243 :       current_statement__ = 53; #>  244 :       w2_1dim__ = std::numeric_limits<int>::min(); #>  245 :       current_statement__ = 53; #>  246 :       w2_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  247 :                     stan::model::index_uni(1)); #>  248 :       current_statement__ = 53; #>  249 :       stan::math::validate_non_negative_index(\"w2\", \"nodes[1]\", w2_1dim__); #>  250 :       current_statement__ = 54; #>  251 :       w2_2dim__ = std::numeric_limits<int>::min(); #>  252 :       current_statement__ = 54; #>  253 :       w2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  254 :                     stan::model::index_uni(2)); #>  255 :       current_statement__ = 54; #>  256 :       stan::math::validate_non_negative_index(\"w2\", \"nodes[2]\", w2_2dim__); #>  257 :       current_statement__ = 55; #>  258 :       b2_1dim__ = std::numeric_limits<int>::min(); #>  259 :       current_statement__ = 55; #>  260 :       b2_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  261 :                     stan::model::index_uni(2)); #>  262 :       current_statement__ = 55; #>  263 :       stan::math::validate_non_negative_index(\"b2\", \"nodes[2]\", b2_1dim__); #>  264 :       current_statement__ = 56; #>  265 :       w_out_1dim__ = std::numeric_limits<int>::min(); #>  266 :       current_statement__ = 56; #>  267 :       w_out_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  268 :                        stan::model::index_uni(L)); #>  269 :       current_statement__ = 56; #>  270 :       stan::math::validate_non_negative_index(\"w_out\", \"nodes[L]\", #>  271 :         w_out_1dim__); #>  272 :       current_statement__ = 57; #>  273 :       stan::math::validate_non_negative_index(\"z1\", \"n\", n); #>  274 :       current_statement__ = 58; #>  275 :       z1_2dim__ = std::numeric_limits<int>::min(); #>  276 :       current_statement__ = 58; #>  277 :       z1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  278 :                     stan::model::index_uni(1)); #>  279 :       current_statement__ = 58; #>  280 :       stan::math::validate_non_negative_index(\"z1\", \"nodes[1]\", z1_2dim__); #>  281 :       current_statement__ = 59; #>  282 :       stan::math::validate_non_negative_index(\"a1\", \"n\", n); #>  283 :       current_statement__ = 60; #>  284 :       a1_2dim__ = std::numeric_limits<int>::min(); #>  285 :       current_statement__ = 60; #>  286 :       a1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  287 :                     stan::model::index_uni(1)); #>  288 :       current_statement__ = 60; #>  289 :       stan::math::validate_non_negative_index(\"a1\", \"nodes[1]\", a1_2dim__); #>  290 :       current_statement__ = 61; #>  291 :       stan::math::validate_non_negative_index(\"z2\", \"n\", n); #>  292 :       current_statement__ = 62; #>  293 :       z2_2dim__ = std::numeric_limits<int>::min(); #>  294 :       current_statement__ = 62; #>  295 :       z2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  296 :                     stan::model::index_uni(2)); #>  297 :       current_statement__ = 62; #>  298 :       stan::math::validate_non_negative_index(\"z2\", \"nodes[2]\", z2_2dim__); #>  299 :       current_statement__ = 63; #>  300 :       stan::math::validate_non_negative_index(\"a2\", \"n\", n); #>  301 :       current_statement__ = 64; #>  302 :       a2_2dim__ = std::numeric_limits<int>::min(); #>  303 :       current_statement__ = 64; #>  304 :       a2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  305 :                     stan::model::index_uni(2)); #>  306 :       current_statement__ = 64; #>  307 :       stan::math::validate_non_negative_index(\"a2\", \"nodes[2]\", a2_2dim__); #>  308 :       current_statement__ = 65; #>  309 :       stan::math::validate_non_negative_index(\"y_hat\", \"n\", n); #>  310 :     } catch (const std::exception& e) { #>  311 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  312 :     } #>  313 :     num_params_r__ = (m * w1_2dim__) + b1_1dim__ + (w2_1dim__ * w2_2dim__) + #>  314 :       b2_1dim__ + w_out_1dim__ + 1 + 1; #>  315 :   } #>  316 :   inline std::string model_name() const final { #>  317 :     return \"model1d207ae671eb_\"; #>  318 :   } #>  319 :   inline std::vector<std::string> model_compile_info() const noexcept { #>  320 :     return std::vector<std::string>{\"stanc_version = stanc3 v2.32.2\", #>  321 :              \"stancflags = --\"}; #>  322 :   } #>  323 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI, #>  324 :             stan::require_vector_like_t<VecR>* = nullptr, #>  325 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  326 :   inline stan::scalar_type_t<VecR> #>  327 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream* #>  328 :                 pstream__ = nullptr) const { #>  329 :     using T__ = stan::scalar_type_t<VecR>; #>  330 :     using local_scalar_t__ = T__; #>  331 :     T__ lp__(0.0); #>  332 :     stan::math::accumulator<T__> lp_accum__; #>  333 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  334 :     int current_statement__ = 0; #>  335 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  336 :     // suppress unused var warning #>  337 :     (void) DUMMY_VAR__; #>  338 :     static constexpr const char* function__ = #>  339 :       \"model1d207ae671eb__namespace::log_prob\"; #>  340 :     // suppress unused var warning #>  341 :     (void) function__; #>  342 :     try { #>  343 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  344 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  345 :           DUMMY_VAR__); #>  346 :       current_statement__ = 1; #>  347 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  348 :              w1_2dim__); #>  349 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  350 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  351 :           DUMMY_VAR__); #>  352 :       current_statement__ = 2; #>  353 :       b1 = in__.template read< #>  354 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__); #>  355 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  356 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  357 :           DUMMY_VAR__); #>  358 :       current_statement__ = 3; #>  359 :       w2 = in__.template read< #>  360 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, w2_2dim__); #>  361 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  362 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  363 :           DUMMY_VAR__); #>  364 :       current_statement__ = 4; #>  365 :       b2 = in__.template read< #>  366 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__); #>  367 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  368 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  369 :           DUMMY_VAR__); #>  370 :       current_statement__ = 5; #>  371 :       w_out = in__.template read< #>  372 :                 Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__); #>  373 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  374 :       current_statement__ = 6; #>  375 :       b_out = in__.template read<local_scalar_t__>(); #>  376 :       local_scalar_t__ sigma = DUMMY_VAR__; #>  377 :       current_statement__ = 7; #>  378 :       sigma = in__.template read_constrain_lb<local_scalar_t__, #>  379 :                 jacobian__>(0, lp__); #>  380 :       Eigen::Matrix<local_scalar_t__,-1,-1> z1 = #>  381 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z1_2dim__, #>  382 :           DUMMY_VAR__); #>  383 :       Eigen::Matrix<local_scalar_t__,-1,-1> a1 = #>  384 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a1_2dim__, #>  385 :           DUMMY_VAR__); #>  386 :       Eigen::Matrix<local_scalar_t__,-1,-1> z2 = #>  387 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z2_2dim__, #>  388 :           DUMMY_VAR__); #>  389 :       Eigen::Matrix<local_scalar_t__,-1,-1> a2 = #>  390 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a2_2dim__, #>  391 :           DUMMY_VAR__); #>  392 :       Eigen::Matrix<local_scalar_t__,-1,1> y_hat = #>  393 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n, DUMMY_VAR__); #>  394 :       current_statement__ = 13; #>  395 :       stan::model::assign(z1, #>  396 :         stan::math::add(stan::math::multiply(X, w1), #>  397 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  398 :         \"assigning variable z1\"); #>  399 :       current_statement__ = 20; #>  400 :       if (stan::math::logical_eq( #>  401 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  402 :             1)) { #>  403 :         current_statement__ = 19; #>  404 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  405 :       } else { #>  406 :         current_statement__ = 18; #>  407 :         if (stan::math::logical_eq( #>  408 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  409 :               2)) { #>  410 :           current_statement__ = 17; #>  411 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  412 :             \"assigning variable a1\"); #>  413 :         } else { #>  414 :           current_statement__ = 16; #>  415 :           if (stan::math::logical_eq( #>  416 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  417 :                   stan::model::index_uni(1)), 3)) { #>  418 :             current_statement__ = 15; #>  419 :             stan::model::assign(a1, #>  420 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  421 :               \"assigning variable a1\"); #>  422 :           } else { #>  423 :             current_statement__ = 14; #>  424 :             stan::model::assign(a1, #>  425 :               stan::math::fmax( #>  426 :                 stan::math::rep_matrix(0, n, #>  427 :                   stan::model::rvalue(nodes, \"nodes\", #>  428 :                     stan::model::index_uni(1))), z1), \"assigning variable a1\"); #>  429 :           } #>  430 :         } #>  431 :       } #>  432 :       current_statement__ = 21; #>  433 :       stan::model::assign(z2, #>  434 :         stan::math::add(stan::math::multiply(a1, w2), #>  435 :           stan::math::rep_matrix(stan::math::transpose(b2), n)), #>  436 :         \"assigning variable z2\"); #>  437 :       current_statement__ = 28; #>  438 :       if (stan::math::logical_eq( #>  439 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  440 :             1)) { #>  441 :         current_statement__ = 27; #>  442 :         stan::model::assign(a2, stan::math::tanh(z2), \"assigning variable a2\"); #>  443 :       } else { #>  444 :         current_statement__ = 26; #>  445 :         if (stan::math::logical_eq( #>  446 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  447 :               2)) { #>  448 :           current_statement__ = 25; #>  449 :           stan::model::assign(a2, stan::math::inv_logit(z2), #>  450 :             \"assigning variable a2\"); #>  451 :         } else { #>  452 :           current_statement__ = 24; #>  453 :           if (stan::math::logical_eq( #>  454 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  455 :                   stan::model::index_uni(2)), 3)) { #>  456 :             current_statement__ = 23; #>  457 :             stan::model::assign(a2, #>  458 :               stan::math::log(stan::math::add(1, stan::math::exp(z2))), #>  459 :               \"assigning variable a2\"); #>  460 :           } else { #>  461 :             current_statement__ = 22; #>  462 :             stan::model::assign(a2, #>  463 :               stan::math::fmax( #>  464 :                 stan::math::rep_matrix(0, n, #>  465 :                   stan::model::rvalue(nodes, \"nodes\", #>  466 :                     stan::model::index_uni(2))), z2), \"assigning variable a2\"); #>  467 :           } #>  468 :         } #>  469 :       } #>  470 :       current_statement__ = 29; #>  471 :       stan::model::assign(y_hat, #>  472 :         stan::math::add(stan::math::multiply(a2, w_out), b_out), #>  473 :         \"assigning variable y_hat\"); #>  474 :       { #>  475 :         current_statement__ = 30; #>  476 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  477 :                          stan::math::to_vector(w1), 0, 1)); #>  478 :         current_statement__ = 31; #>  479 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b1, 0, 1)); #>  480 :         current_statement__ = 32; #>  481 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  482 :                          stan::math::to_vector(w2), 0, 1)); #>  483 :         current_statement__ = 33; #>  484 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b2, 0, 1)); #>  485 :         current_statement__ = 34; #>  486 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(w_out, 0, 1)); #>  487 :         current_statement__ = 35; #>  488 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b_out, 0, 1)); #>  489 :         current_statement__ = 36; #>  490 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(sigma, 0, 1)); #>  491 :         current_statement__ = 37; #>  492 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(y, y_hat, sigma)); #>  493 :       } #>  494 :     } catch (const std::exception& e) { #>  495 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  496 :     } #>  497 :     lp_accum__.add(lp__); #>  498 :     return lp_accum__.sum(); #>  499 :   } #>  500 :   template <typename RNG, typename VecR, typename VecI, typename VecVar, #>  501 :             stan::require_vector_like_vt<std::is_floating_point, #>  502 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, #>  503 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point, #>  504 :             VecVar>* = nullptr> #>  505 :   inline void #>  506 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__, #>  507 :                    VecVar& vars__, const bool #>  508 :                    emit_transformed_parameters__ = true, const bool #>  509 :                    emit_generated_quantities__ = true, std::ostream* #>  510 :                    pstream__ = nullptr) const { #>  511 :     using local_scalar_t__ = double; #>  512 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  513 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  514 :     static constexpr bool propto__ = true; #>  515 :     // suppress unused var warning #>  516 :     (void) propto__; #>  517 :     double lp__ = 0.0; #>  518 :     // suppress unused var warning #>  519 :     (void) lp__; #>  520 :     int current_statement__ = 0; #>  521 :     stan::math::accumulator<double> lp_accum__; #>  522 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  523 :     // suppress unused var warning #>  524 :     (void) DUMMY_VAR__; #>  525 :     constexpr bool jacobian__ = false; #>  526 :     static constexpr const char* function__ = #>  527 :       \"model1d207ae671eb__namespace::write_array\"; #>  528 :     // suppress unused var warning #>  529 :     (void) function__; #>  530 :     try { #>  531 :       Eigen::Matrix<double,-1,-1> w1 = #>  532 :         Eigen::Matrix<double,-1,-1>::Constant(m, w1_2dim__, #>  533 :           std::numeric_limits<double>::quiet_NaN()); #>  534 :       current_statement__ = 1; #>  535 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  536 :              w1_2dim__); #>  537 :       Eigen::Matrix<double,-1,1> b1 = #>  538 :         Eigen::Matrix<double,-1,1>::Constant(b1_1dim__, #>  539 :           std::numeric_limits<double>::quiet_NaN()); #>  540 :       current_statement__ = 2; #>  541 :       b1 = in__.template read< #>  542 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__); #>  543 :       Eigen::Matrix<double,-1,-1> w2 = #>  544 :         Eigen::Matrix<double,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  545 :           std::numeric_limits<double>::quiet_NaN()); #>  546 :       current_statement__ = 3; #>  547 :       w2 = in__.template read< #>  548 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, w2_2dim__); #>  549 :       Eigen::Matrix<double,-1,1> b2 = #>  550 :         Eigen::Matrix<double,-1,1>::Constant(b2_1dim__, #>  551 :           std::numeric_limits<double>::quiet_NaN()); #>  552 :       current_statement__ = 4; #>  553 :       b2 = in__.template read< #>  554 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__); #>  555 :       Eigen::Matrix<double,-1,1> w_out = #>  556 :         Eigen::Matrix<double,-1,1>::Constant(w_out_1dim__, #>  557 :           std::numeric_limits<double>::quiet_NaN()); #>  558 :       current_statement__ = 5; #>  559 :       w_out = in__.template read< #>  560 :                 Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__); #>  561 :       double b_out = std::numeric_limits<double>::quiet_NaN(); #>  562 :       current_statement__ = 6; #>  563 :       b_out = in__.template read<local_scalar_t__>(); #>  564 :       double sigma = std::numeric_limits<double>::quiet_NaN(); #>  565 :       current_statement__ = 7; #>  566 :       sigma = in__.template read_constrain_lb<local_scalar_t__, #>  567 :                 jacobian__>(0, lp__); #>  568 :       Eigen::Matrix<double,-1,-1> z1 = #>  569 :         Eigen::Matrix<double,-1,-1>::Constant(n, z1_2dim__, #>  570 :           std::numeric_limits<double>::quiet_NaN()); #>  571 :       Eigen::Matrix<double,-1,-1> a1 = #>  572 :         Eigen::Matrix<double,-1,-1>::Constant(n, a1_2dim__, #>  573 :           std::numeric_limits<double>::quiet_NaN()); #>  574 :       Eigen::Matrix<double,-1,-1> z2 = #>  575 :         Eigen::Matrix<double,-1,-1>::Constant(n, z2_2dim__, #>  576 :           std::numeric_limits<double>::quiet_NaN()); #>  577 :       Eigen::Matrix<double,-1,-1> a2 = #>  578 :         Eigen::Matrix<double,-1,-1>::Constant(n, a2_2dim__, #>  579 :           std::numeric_limits<double>::quiet_NaN()); #>  580 :       Eigen::Matrix<double,-1,1> y_hat = #>  581 :         Eigen::Matrix<double,-1,1>::Constant(n, #>  582 :           std::numeric_limits<double>::quiet_NaN()); #>  583 :       out__.write(w1); #>  584 :       out__.write(b1); #>  585 :       out__.write(w2); #>  586 :       out__.write(b2); #>  587 :       out__.write(w_out); #>  588 :       out__.write(b_out); #>  589 :       out__.write(sigma); #>  590 :       if (stan::math::logical_negation( #>  591 :             (stan::math::primitive_value(emit_transformed_parameters__) || #>  592 :             stan::math::primitive_value(emit_generated_quantities__)))) { #>  593 :         return ; #>  594 :       } #>  595 :       current_statement__ = 13; #>  596 :       stan::model::assign(z1, #>  597 :         stan::math::add(stan::math::multiply(X, w1), #>  598 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  599 :         \"assigning variable z1\"); #>  600 :       current_statement__ = 20; #>  601 :       if (stan::math::logical_eq( #>  602 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  603 :             1)) { #>  604 :         current_statement__ = 19; #>  605 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  606 :       } else { #>  607 :         current_statement__ = 18; #>  608 :         if (stan::math::logical_eq( #>  609 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  610 :               2)) { #>  611 :           current_statement__ = 17; #>  612 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  613 :             \"assigning variable a1\"); #>  614 :         } else { #>  615 :           current_statement__ = 16; #>  616 :           if (stan::math::logical_eq( #>  617 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  618 :                   stan::model::index_uni(1)), 3)) { #>  619 :             current_statement__ = 15; #>  620 :             stan::model::assign(a1, #>  621 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  622 :               \"assigning variable a1\"); #>  623 :           } else { #>  624 :             current_statement__ = 14; #>  625 :             stan::model::assign(a1, #>  626 :               stan::math::fmax( #>  627 :                 stan::math::rep_matrix(0, n, #>  628 :                   stan::model::rvalue(nodes, \"nodes\", #>  629 :                     stan::model::index_uni(1))), z1), \"assigning variable a1\"); #>  630 :           } #>  631 :         } #>  632 :       } #>  633 :       current_statement__ = 21; #>  634 :       stan::model::assign(z2, #>  635 :         stan::math::add(stan::math::multiply(a1, w2), #>  636 :           stan::math::rep_matrix(stan::math::transpose(b2), n)), #>  637 :         \"assigning variable z2\"); #>  638 :       current_statement__ = 28; #>  639 :       if (stan::math::logical_eq( #>  640 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  641 :             1)) { #>  642 :         current_statement__ = 27; #>  643 :         stan::model::assign(a2, stan::math::tanh(z2), \"assigning variable a2\"); #>  644 :       } else { #>  645 :         current_statement__ = 26; #>  646 :         if (stan::math::logical_eq( #>  647 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  648 :               2)) { #>  649 :           current_statement__ = 25; #>  650 :           stan::model::assign(a2, stan::math::inv_logit(z2), #>  651 :             \"assigning variable a2\"); #>  652 :         } else { #>  653 :           current_statement__ = 24; #>  654 :           if (stan::math::logical_eq( #>  655 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  656 :                   stan::model::index_uni(2)), 3)) { #>  657 :             current_statement__ = 23; #>  658 :             stan::model::assign(a2, #>  659 :               stan::math::log(stan::math::add(1, stan::math::exp(z2))), #>  660 :               \"assigning variable a2\"); #>  661 :           } else { #>  662 :             current_statement__ = 22; #>  663 :             stan::model::assign(a2, #>  664 :               stan::math::fmax( #>  665 :                 stan::math::rep_matrix(0, n, #>  666 :                   stan::model::rvalue(nodes, \"nodes\", #>  667 :                     stan::model::index_uni(2))), z2), \"assigning variable a2\"); #>  668 :           } #>  669 :         } #>  670 :       } #>  671 :       current_statement__ = 29; #>  672 :       stan::model::assign(y_hat, #>  673 :         stan::math::add(stan::math::multiply(a2, w_out), b_out), #>  674 :         \"assigning variable y_hat\"); #>  675 :       if (emit_transformed_parameters__) { #>  676 :         out__.write(z1); #>  677 :         out__.write(a1); #>  678 :         out__.write(z2); #>  679 :         out__.write(a2); #>  680 :         out__.write(y_hat); #>  681 :       } #>  682 :       if (stan::math::logical_negation(emit_generated_quantities__)) { #>  683 :         return ; #>  684 :       } #>  685 :     } catch (const std::exception& e) { #>  686 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  687 :     } #>  688 :   } #>  689 :   template <typename VecVar, typename VecI, #>  690 :             stan::require_vector_t<VecVar>* = nullptr, #>  691 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  692 :   inline void #>  693 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__, #>  694 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const { #>  695 :     using local_scalar_t__ = double; #>  696 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  697 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  698 :     int current_statement__ = 0; #>  699 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  700 :     // suppress unused var warning #>  701 :     (void) DUMMY_VAR__; #>  702 :     try { #>  703 :       int pos__ = std::numeric_limits<int>::min(); #>  704 :       pos__ = 1; #>  705 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  706 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  707 :           DUMMY_VAR__); #>  708 :       current_statement__ = 1; #>  709 :       stan::model::assign(w1, #>  710 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, w1_2dim__), #>  711 :         \"assigning variable w1\"); #>  712 :       out__.write(w1); #>  713 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  714 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  715 :           DUMMY_VAR__); #>  716 :       current_statement__ = 2; #>  717 :       stan::model::assign(b1, #>  718 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__), #>  719 :         \"assigning variable b1\"); #>  720 :       out__.write(b1); #>  721 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  722 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  723 :           DUMMY_VAR__); #>  724 :       current_statement__ = 3; #>  725 :       stan::model::assign(w2, #>  726 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, #>  727 :           w2_2dim__), \"assigning variable w2\"); #>  728 :       out__.write(w2); #>  729 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  730 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  731 :           DUMMY_VAR__); #>  732 :       current_statement__ = 4; #>  733 :       stan::model::assign(b2, #>  734 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__), #>  735 :         \"assigning variable b2\"); #>  736 :       out__.write(b2); #>  737 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  738 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  739 :           DUMMY_VAR__); #>  740 :       current_statement__ = 5; #>  741 :       stan::model::assign(w_out, #>  742 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__), #>  743 :         \"assigning variable w_out\"); #>  744 :       out__.write(w_out); #>  745 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  746 :       current_statement__ = 6; #>  747 :       b_out = in__.read<local_scalar_t__>(); #>  748 :       out__.write(b_out); #>  749 :       local_scalar_t__ sigma = DUMMY_VAR__; #>  750 :       current_statement__ = 7; #>  751 :       sigma = in__.read<local_scalar_t__>(); #>  752 :       out__.write_free_lb(0, sigma); #>  753 :     } catch (const std::exception& e) { #>  754 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  755 :     } #>  756 :   } #>  757 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr> #>  758 :   inline void #>  759 :   transform_inits_impl(const stan::io::var_context& context__, VecVar& #>  760 :                        vars__, std::ostream* pstream__ = nullptr) const { #>  761 :     using local_scalar_t__ = double; #>  762 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  763 :     int current_statement__ = 0; #>  764 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  765 :     // suppress unused var warning #>  766 :     (void) DUMMY_VAR__; #>  767 :     try { #>  768 :       current_statement__ = 1; #>  769 :       context__.validate_dims(\"parameter initialization\", \"w1\", \"double\", #>  770 :         std::vector<size_t>{static_cast<size_t>(m), #>  771 :           static_cast<size_t>(w1_2dim__)}); #>  772 :       current_statement__ = 2; #>  773 :       context__.validate_dims(\"parameter initialization\", \"b1\", \"double\", #>  774 :         std::vector<size_t>{static_cast<size_t>(b1_1dim__)}); #>  775 :       current_statement__ = 3; #>  776 :       context__.validate_dims(\"parameter initialization\", \"w2\", \"double\", #>  777 :         std::vector<size_t>{static_cast<size_t>(w2_1dim__), #>  778 :           static_cast<size_t>(w2_2dim__)}); #>  779 :       current_statement__ = 4; #>  780 :       context__.validate_dims(\"parameter initialization\", \"b2\", \"double\", #>  781 :         std::vector<size_t>{static_cast<size_t>(b2_1dim__)}); #>  782 :       current_statement__ = 5; #>  783 :       context__.validate_dims(\"parameter initialization\", \"w_out\", \"double\", #>  784 :         std::vector<size_t>{static_cast<size_t>(w_out_1dim__)}); #>  785 :       current_statement__ = 6; #>  786 :       context__.validate_dims(\"parameter initialization\", \"b_out\", \"double\", #>  787 :         std::vector<size_t>{}); #>  788 :       current_statement__ = 7; #>  789 :       context__.validate_dims(\"parameter initialization\", \"sigma\", \"double\", #>  790 :         std::vector<size_t>{}); #>  791 :       int pos__ = std::numeric_limits<int>::min(); #>  792 :       pos__ = 1; #>  793 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  794 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  795 :           DUMMY_VAR__); #>  796 :       { #>  797 :         std::vector<local_scalar_t__> w1_flat__; #>  798 :         current_statement__ = 1; #>  799 :         w1_flat__ = context__.vals_r(\"w1\"); #>  800 :         current_statement__ = 1; #>  801 :         pos__ = 1; #>  802 :         current_statement__ = 1; #>  803 :         for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #>  804 :           current_statement__ = 1; #>  805 :           for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  806 :             current_statement__ = 1; #>  807 :             stan::model::assign(w1, w1_flat__[(pos__ - 1)], #>  808 :               \"assigning variable w1\", stan::model::index_uni(sym2__), #>  809 :               stan::model::index_uni(sym1__)); #>  810 :             current_statement__ = 1; #>  811 :             pos__ = (pos__ + 1); #>  812 :           } #>  813 :         } #>  814 :       } #>  815 :       out__.write(w1); #>  816 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  817 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  818 :           DUMMY_VAR__); #>  819 :       { #>  820 :         std::vector<local_scalar_t__> b1_flat__; #>  821 :         current_statement__ = 2; #>  822 :         b1_flat__ = context__.vals_r(\"b1\"); #>  823 :         current_statement__ = 2; #>  824 :         pos__ = 1; #>  825 :         current_statement__ = 2; #>  826 :         for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #>  827 :           current_statement__ = 2; #>  828 :           stan::model::assign(b1, b1_flat__[(pos__ - 1)], #>  829 :             \"assigning variable b1\", stan::model::index_uni(sym1__)); #>  830 :           current_statement__ = 2; #>  831 :           pos__ = (pos__ + 1); #>  832 :         } #>  833 :       } #>  834 :       out__.write(b1); #>  835 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  836 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  837 :           DUMMY_VAR__); #>  838 :       { #>  839 :         std::vector<local_scalar_t__> w2_flat__; #>  840 :         current_statement__ = 3; #>  841 :         w2_flat__ = context__.vals_r(\"w2\"); #>  842 :         current_statement__ = 3; #>  843 :         pos__ = 1; #>  844 :         current_statement__ = 3; #>  845 :         for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #>  846 :           current_statement__ = 3; #>  847 :           for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #>  848 :             current_statement__ = 3; #>  849 :             stan::model::assign(w2, w2_flat__[(pos__ - 1)], #>  850 :               \"assigning variable w2\", stan::model::index_uni(sym2__), #>  851 :               stan::model::index_uni(sym1__)); #>  852 :             current_statement__ = 3; #>  853 :             pos__ = (pos__ + 1); #>  854 :           } #>  855 :         } #>  856 :       } #>  857 :       out__.write(w2); #>  858 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  859 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  860 :           DUMMY_VAR__); #>  861 :       { #>  862 :         std::vector<local_scalar_t__> b2_flat__; #>  863 :         current_statement__ = 4; #>  864 :         b2_flat__ = context__.vals_r(\"b2\"); #>  865 :         current_statement__ = 4; #>  866 :         pos__ = 1; #>  867 :         current_statement__ = 4; #>  868 :         for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #>  869 :           current_statement__ = 4; #>  870 :           stan::model::assign(b2, b2_flat__[(pos__ - 1)], #>  871 :             \"assigning variable b2\", stan::model::index_uni(sym1__)); #>  872 :           current_statement__ = 4; #>  873 :           pos__ = (pos__ + 1); #>  874 :         } #>  875 :       } #>  876 :       out__.write(b2); #>  877 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  878 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  879 :           DUMMY_VAR__); #>  880 :       { #>  881 :         std::vector<local_scalar_t__> w_out_flat__; #>  882 :         current_statement__ = 5; #>  883 :         w_out_flat__ = context__.vals_r(\"w_out\"); #>  884 :         current_statement__ = 5; #>  885 :         pos__ = 1; #>  886 :         current_statement__ = 5; #>  887 :         for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #>  888 :           current_statement__ = 5; #>  889 :           stan::model::assign(w_out, w_out_flat__[(pos__ - 1)], #>  890 :             \"assigning variable w_out\", stan::model::index_uni(sym1__)); #>  891 :           current_statement__ = 5; #>  892 :           pos__ = (pos__ + 1); #>  893 :         } #>  894 :       } #>  895 :       out__.write(w_out); #>  896 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  897 :       current_statement__ = 6; #>  898 :       b_out = context__.vals_r(\"b_out\")[(1 - 1)]; #>  899 :       out__.write(b_out); #>  900 :       local_scalar_t__ sigma = DUMMY_VAR__; #>  901 :       current_statement__ = 7; #>  902 :       sigma = context__.vals_r(\"sigma\")[(1 - 1)]; #>  903 :       out__.write_free_lb(0, sigma); #>  904 :     } catch (const std::exception& e) { #>  905 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  906 :     } #>  907 :   } #>  908 :   inline void #>  909 :   get_param_names(std::vector<std::string>& names__, const bool #>  910 :                   emit_transformed_parameters__ = true, const bool #>  911 :                   emit_generated_quantities__ = true) const { #>  912 :     names__ = std::vector<std::string>{\"w1\", \"b1\", \"w2\", \"b2\", \"w_out\", #>  913 :                 \"b_out\", \"sigma\"}; #>  914 :     if (emit_transformed_parameters__) { #>  915 :       std::vector<std::string> temp{\"z1\", \"a1\", \"z2\", \"a2\", \"y_hat\"}; #>  916 :       names__.reserve(names__.size() + temp.size()); #>  917 :       names__.insert(names__.end(), temp.begin(), temp.end()); #>  918 :     } #>  919 :     if (emit_generated_quantities__) {} #>  920 :   } #>  921 :   inline void #>  922 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool #>  923 :            emit_transformed_parameters__ = true, const bool #>  924 :            emit_generated_quantities__ = true) const { #>  925 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast< #>  926 :                                                                     size_t>(m), #>  927 :                                                  static_cast<size_t>( #>  928 :                                                    w1_2dim__)}, #>  929 :                 std::vector<size_t>{static_cast<size_t>(b1_1dim__)}, #>  930 :                 std::vector<size_t>{static_cast<size_t>(w2_1dim__), #>  931 :                   static_cast<size_t>(w2_2dim__)}, #>  932 :                 std::vector<size_t>{static_cast<size_t>(b2_1dim__)}, #>  933 :                 std::vector<size_t>{static_cast<size_t>(w_out_1dim__)}, #>  934 :                 std::vector<size_t>{}, std::vector<size_t>{}}; #>  935 :     if (emit_transformed_parameters__) { #>  936 :       std::vector<std::vector<size_t>> #>  937 :         temp{std::vector<size_t>{static_cast<size_t>(n), #>  938 :                static_cast<size_t>(z1_2dim__)}, #>  939 :              std::vector<size_t>{static_cast<size_t>(n), #>  940 :                static_cast<size_t>(a1_2dim__)}, #>  941 :              std::vector<size_t>{static_cast<size_t>(n), #>  942 :                static_cast<size_t>(z2_2dim__)}, #>  943 :              std::vector<size_t>{static_cast<size_t>(n), #>  944 :                static_cast<size_t>(a2_2dim__)}, #>  945 :              std::vector<size_t>{static_cast<size_t>(n)}}; #>  946 :       dimss__.reserve(dimss__.size() + temp.size()); #>  947 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end()); #>  948 :     } #>  949 :     if (emit_generated_quantities__) {} #>  950 :   } #>  951 :   inline void #>  952 :   constrained_param_names(std::vector<std::string>& param_names__, bool #>  953 :                           emit_transformed_parameters__ = true, bool #>  954 :                           emit_generated_quantities__ = true) const final { #>  955 :     for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #>  956 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  957 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #>  958 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  959 :       } #>  960 :     } #>  961 :     for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #>  962 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #>  963 :         std::to_string(sym1__)); #>  964 :     } #>  965 :     for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #>  966 :       for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #>  967 :         param_names__.emplace_back(std::string() + \"w2\" + '.' + #>  968 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  969 :       } #>  970 :     } #>  971 :     for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #>  972 :       param_names__.emplace_back(std::string() + \"b2\" + '.' + #>  973 :         std::to_string(sym1__)); #>  974 :     } #>  975 :     for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #>  976 :       param_names__.emplace_back(std::string() + \"w_out\" + '.' + #>  977 :         std::to_string(sym1__)); #>  978 :     } #>  979 :     param_names__.emplace_back(std::string() + \"b_out\"); #>  980 :     param_names__.emplace_back(std::string() + \"sigma\"); #>  981 :     if (emit_transformed_parameters__) { #>  982 :       for (int sym1__ = 1; sym1__ <= z1_2dim__; ++sym1__) { #>  983 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  984 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #>  985 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  986 :         } #>  987 :       } #>  988 :       for (int sym1__ = 1; sym1__ <= a1_2dim__; ++sym1__) { #>  989 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  990 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #>  991 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  992 :         } #>  993 :       } #>  994 :       for (int sym1__ = 1; sym1__ <= z2_2dim__; ++sym1__) { #>  995 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  996 :           param_names__.emplace_back(std::string() + \"z2\" + '.' + #>  997 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  998 :         } #>  999 :       } #> 1000 :       for (int sym1__ = 1; sym1__ <= a2_2dim__; ++sym1__) { #> 1001 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1002 :           param_names__.emplace_back(std::string() + \"a2\" + '.' + #> 1003 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1004 :         } #> 1005 :       } #> 1006 :       for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #> 1007 :         param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #> 1008 :           std::to_string(sym1__)); #> 1009 :       } #> 1010 :     } #> 1011 :     if (emit_generated_quantities__) {} #> 1012 :   } #> 1013 :   inline void #> 1014 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool #> 1015 :                             emit_transformed_parameters__ = true, bool #> 1016 :                             emit_generated_quantities__ = true) const final { #> 1017 :     for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #> 1018 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #> 1019 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #> 1020 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1021 :       } #> 1022 :     } #> 1023 :     for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #> 1024 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #> 1025 :         std::to_string(sym1__)); #> 1026 :     } #> 1027 :     for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #> 1028 :       for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #> 1029 :         param_names__.emplace_back(std::string() + \"w2\" + '.' + #> 1030 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1031 :       } #> 1032 :     } #> 1033 :     for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #> 1034 :       param_names__.emplace_back(std::string() + \"b2\" + '.' + #> 1035 :         std::to_string(sym1__)); #> 1036 :     } #> 1037 :     for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #> 1038 :       param_names__.emplace_back(std::string() + \"w_out\" + '.' + #> 1039 :         std::to_string(sym1__)); #> 1040 :     } #> 1041 :     param_names__.emplace_back(std::string() + \"b_out\"); #> 1042 :     param_names__.emplace_back(std::string() + \"sigma\"); #> 1043 :     if (emit_transformed_parameters__) { #> 1044 :       for (int sym1__ = 1; sym1__ <= z1_2dim__; ++sym1__) { #> 1045 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1046 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #> 1047 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1048 :         } #> 1049 :       } #> 1050 :       for (int sym1__ = 1; sym1__ <= a1_2dim__; ++sym1__) { #> 1051 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1052 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #> 1053 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1054 :         } #> 1055 :       } #> 1056 :       for (int sym1__ = 1; sym1__ <= z2_2dim__; ++sym1__) { #> 1057 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1058 :           param_names__.emplace_back(std::string() + \"z2\" + '.' + #> 1059 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1060 :         } #> 1061 :       } #> 1062 :       for (int sym1__ = 1; sym1__ <= a2_2dim__; ++sym1__) { #> 1063 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1064 :           param_names__.emplace_back(std::string() + \"a2\" + '.' + #> 1065 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1066 :         } #> 1067 :       } #> 1068 :       for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #> 1069 :         param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #> 1070 :           std::to_string(sym1__)); #> 1071 :       } #> 1072 :     } #> 1073 :     if (emit_generated_quantities__) {} #> 1074 :   } #> 1075 :   inline std::string get_constrained_sizedtypes() const { #> 1076 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(w1_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b1_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w2_1dim__) + \",\\\"cols\\\":\" + std::to_string(w2_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b2\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b2_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(w_out_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"sigma\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(n) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #> 1077 :   } #> 1078 :   inline std::string get_unconstrained_sizedtypes() const { #> 1079 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(w1_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b1_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w2_1dim__) + \",\\\"cols\\\":\" + std::to_string(w2_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b2\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b2_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(w_out_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"sigma\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(n) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #> 1080 :   } #> 1081 :   // Begin method overload boilerplate #> 1082 :   template <typename RNG> inline void #> 1083 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r, #> 1084 :               Eigen::Matrix<double,-1,1>& vars, const bool #> 1085 :               emit_transformed_parameters = true, const bool #> 1086 :               emit_generated_quantities = true, std::ostream* #> 1087 :               pstream = nullptr) const { #> 1088 :     const size_t num_params__ = (((((((m * w1_2dim__) + b1_1dim__) + #> 1089 :       (w2_1dim__ * w2_2dim__)) + b2_1dim__) + w_out_1dim__) + 1) + 1); #> 1090 :     const size_t num_transformed = emit_transformed_parameters * ((((((n * #> 1091 :       z1_2dim__) + (n * a1_2dim__)) + (n * z2_2dim__)) + (n * a2_2dim__)) + #> 1092 :       n)); #> 1093 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #> 1094 :     const size_t num_to_write = num_params__ + num_transformed + #> 1095 :       num_gen_quantities; #> 1096 :     std::vector<int> params_i; #> 1097 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write, #> 1098 :              std::numeric_limits<double>::quiet_NaN()); #> 1099 :     write_array_impl(base_rng, params_r, params_i, vars, #> 1100 :       emit_transformed_parameters, emit_generated_quantities, pstream); #> 1101 :   } #> 1102 :   template <typename RNG> inline void #> 1103 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>& #> 1104 :               params_i, std::vector<double>& vars, bool #> 1105 :               emit_transformed_parameters = true, bool #> 1106 :               emit_generated_quantities = true, std::ostream* #> 1107 :               pstream = nullptr) const { #> 1108 :     const size_t num_params__ = (((((((m * w1_2dim__) + b1_1dim__) + #> 1109 :       (w2_1dim__ * w2_2dim__)) + b2_1dim__) + w_out_1dim__) + 1) + 1); #> 1110 :     const size_t num_transformed = emit_transformed_parameters * ((((((n * #> 1111 :       z1_2dim__) + (n * a1_2dim__)) + (n * z2_2dim__)) + (n * a2_2dim__)) + #> 1112 :       n)); #> 1113 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #> 1114 :     const size_t num_to_write = num_params__ + num_transformed + #> 1115 :       num_gen_quantities; #> 1116 :     vars = std::vector<double>(num_to_write, #> 1117 :              std::numeric_limits<double>::quiet_NaN()); #> 1118 :     write_array_impl(base_rng, params_r, params_i, vars, #> 1119 :       emit_transformed_parameters, emit_generated_quantities, pstream); #> 1120 :   } #> 1121 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #> 1122 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const { #> 1123 :     Eigen::Matrix<int,-1,1> params_i; #> 1124 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #> 1125 :   } #> 1126 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #> 1127 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i, #> 1128 :            std::ostream* pstream = nullptr) const { #> 1129 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #> 1130 :   } #> 1131 :   inline void #> 1132 :   transform_inits(const stan::io::var_context& context, #> 1133 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream* #> 1134 :                   pstream = nullptr) const final { #> 1135 :     std::vector<double> params_r_vec(params_r.size()); #> 1136 :     std::vector<int> params_i; #> 1137 :     transform_inits(context, params_i, params_r_vec, pstream); #> 1138 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(), #> 1139 :                  params_r_vec.size()); #> 1140 :   } #> 1141 :   inline void #> 1142 :   transform_inits(const stan::io::var_context& context, std::vector<int>& #> 1143 :                   params_i, std::vector<double>& vars, std::ostream* #> 1144 :                   pstream__ = nullptr) const { #> 1145 :     vars.resize(num_params_r__); #> 1146 :     transform_inits_impl(context, vars, pstream__); #> 1147 :   } #> 1148 :   inline void #> 1149 :   unconstrain_array(const std::vector<double>& params_constrained, #> 1150 :                     std::vector<double>& params_unconstrained, std::ostream* #> 1151 :                     pstream = nullptr) const { #> 1152 :     const std::vector<int> params_i; #> 1153 :     params_unconstrained = std::vector<double>(num_params_r__, #> 1154 :                              std::numeric_limits<double>::quiet_NaN()); #> 1155 :     unconstrain_array_impl(params_constrained, params_i, #> 1156 :       params_unconstrained, pstream); #> 1157 :   } #> 1158 :   inline void #> 1159 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained, #> 1160 :                     Eigen::Matrix<double,-1,1>& params_unconstrained, #> 1161 :                     std::ostream* pstream = nullptr) const { #> 1162 :     const std::vector<int> params_i; #> 1163 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__, #> 1164 :                              std::numeric_limits<double>::quiet_NaN()); #> 1165 :     unconstrain_array_impl(params_constrained, params_i, #> 1166 :       params_unconstrained, pstream); #> 1167 :   } #> 1168 : }; #> 1169 : } #> 1170 : using stan_model = model1d207ae671eb__namespace::model1d207ae671eb_; #> 1171 : #ifndef USING_R #> 1172 : // Boilerplate #> 1173 : stan::model::model_base& #> 1174 : new_model(stan::io::var_context& data_context, unsigned int seed, #> 1175 :           std::ostream* msg_stream) { #> 1176 :   stan_model* m = new stan_model(data_context, seed, msg_stream); #> 1177 :   return *m; #> 1178 : } #> 1179 : stan::math::profile_map& get_stan_profile_data() { #> 1180 :   return model1d207ae671eb__namespace::profiles__; #> 1181 : } #> 1182 : #endif #> 1183 : #endif #> 1184 :  #> 1185 : RCPP_MODULE(stan_fit4model1d207ae671eb__mod) { #> 1186 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >( #> 1187 :       \"stan_fit4model1d207ae671eb_\") #> 1188 :  #> 1189 :       .constructor<SEXP, SEXP, SEXP>() #> 1190 :  #> 1191 :       .method( #> 1192 :           \"call_sampler\", #> 1193 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler) #> 1194 :       .method( #> 1195 :           \"param_names\", #> 1196 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names) #> 1197 :       .method(\"param_names_oi\", #> 1198 :               &rstan::stan_fit<stan_model, #> 1199 :                                boost::random::ecuyer1988>::param_names_oi) #> 1200 :       .method(\"param_fnames_oi\", #> 1201 :               &rstan::stan_fit<stan_model, #> 1202 :                                boost::random::ecuyer1988>::param_fnames_oi) #> 1203 :       .method( #> 1204 :           \"param_dims\", #> 1205 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims) #> 1206 :       .method(\"param_dims_oi\", #> 1207 :               &rstan::stan_fit<stan_model, #> 1208 :                                boost::random::ecuyer1988>::param_dims_oi) #> 1209 :       .method(\"update_param_oi\", #> 1210 :               &rstan::stan_fit<stan_model, #> 1211 :                                boost::random::ecuyer1988>::update_param_oi) #> 1212 :       .method(\"param_oi_tidx\", #> 1213 :               &rstan::stan_fit<stan_model, #> 1214 :                                boost::random::ecuyer1988>::param_oi_tidx) #> 1215 :       .method(\"grad_log_prob\", #> 1216 :               &rstan::stan_fit<stan_model, #> 1217 :                                boost::random::ecuyer1988>::grad_log_prob) #> 1218 :       .method(\"log_prob\", #> 1219 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob) #> 1220 :       .method(\"unconstrain_pars\", #> 1221 :               &rstan::stan_fit<stan_model, #> 1222 :                                boost::random::ecuyer1988>::unconstrain_pars) #> 1223 :       .method(\"constrain_pars\", #> 1224 :               &rstan::stan_fit<stan_model, #> 1225 :                                boost::random::ecuyer1988>::constrain_pars) #> 1226 :       .method( #> 1227 :           \"num_pars_unconstrained\", #> 1228 :           &rstan::stan_fit<stan_model, #> 1229 :                            boost::random::ecuyer1988>::num_pars_unconstrained) #> 1230 :       .method( #> 1231 :           \"unconstrained_param_names\", #> 1232 :           &rstan::stan_fit< #> 1233 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names) #> 1234 :       .method( #> 1235 :           \"constrained_param_names\", #> 1236 :           &rstan::stan_fit<stan_model, #> 1237 :                            boost::random::ecuyer1988>::constrained_param_names) #> 1238 :       .method(\"standalone_gqs\", #> 1239 :               &rstan::stan_fit<stan_model, #> 1240 :                                boost::random::ecuyer1988>::standalone_gqs); #> 1241 : } #> 1242 :  #> 1243 :  #> 1244 : // declarations #> 1245 : extern \"C\" { #> 1246 : SEXP file1d204d6df04b( ) ; #> 1247 : } #> 1248 :  #> 1249 : // definition #> 1250 : SEXP file1d204d6df04b() { #> 1251 :  return Rcpp::wrap(\"anon_model\"); #> 1252 : } #>  #> CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW. #>  #> COMPILING MODEL 'anon_model' NOW. #>  #> STARTING SAMPLER FOR MODEL 'anon_model' NOW."},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"binary-classification-example","dir":"Articles","previous_headings":"3. Fitting a Bayesian Neural Network Model","what":"Binary Classification Example","title":"Getting Started with the bnns Package","text":"","code":"model_bin <- bnns(   y_bin ~ -1  + x1 + x2,   data = df,   L = 1,   nodes = c(16),   act_fn = c(2),   out_act_fn = 2,          # Output activation: 2 = Logistic sigmoid   iter = 2e2,    warmup = 1e2,    chains = 1 ) #>  #> TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW. #> OS: x86_64, linux-gnu; rstan: 2.32.6; Rcpp: 1.0.13.1; inline: 0.3.20  #>  >> setting environment variables:  #> PKG_LIBS =  '/home/runner/work/_temp/Library/rstan/lib//libStanServices.a' -L'/home/runner/work/_temp/Library/StanHeaders/lib/' -lStanHeaders -L'/home/runner/work/_temp/Library/RcppParallel/lib/' -ltbb  #> PKG_CPPFLAGS =   -I\"/home/runner/work/_temp/Library/Rcpp/include/\"  -I\"/home/runner/work/_temp/Library/RcppEigen/include/\"  -I\"/home/runner/work/_temp/Library/RcppEigen/include/unsupported\"  -I\"/home/runner/work/_temp/Library/BH/include\" -I\"/home/runner/work/_temp/Library/StanHeaders/include/src/\"  -I\"/home/runner/work/_temp/Library/StanHeaders/include/\"  -I\"/home/runner/work/_temp/Library/RcppParallel/include/\"  -I\"/home/runner/work/_temp/Library/rstan/include\" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/runner/work/_temp/Library/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1  #>  >> Program source : #>  #>    1 :  #>    2 : // includes from the plugin #>    3 : // [[Rcpp::plugins(cpp14)]] #>    4 :  #>    5 :  #>    6 : // user includes #>    7 : #include <Rcpp.h> #>    8 : using namespace Rcpp; #>    9 : #ifndef MODELS_HPP #>   10 : #define MODELS_HPP #>   11 : #define STAN__SERVICES__COMMAND_HPP #>   12 : #include <rstan/rstaninc.hpp> #>   13 : #ifndef USE_STANC3 #>   14 : #define USE_STANC3 #>   15 : #endif #>   16 : // Code generated by stanc v2.32.2 #>   17 : #include <stan/model/model_header.hpp> #>   18 : namespace model1d203428b5a4__namespace { #>   19 : using stan::model::model_base_crtp; #>   20 : using namespace stan::math; #>   21 : stan::math::profile_map profiles__; #>   22 : static constexpr std::array<const char*, 41> locations_array__ = #>   23 :   {\" (found before start of program)\", #>   24 :   \" (in 'anon_model', line 11, column 2 to column 22)\", #>   25 :   \" (in 'anon_model', line 12, column 2 to column 19)\", #>   26 :   \" (in 'anon_model', line 13, column 2 to column 22)\", #>   27 :   \" (in 'anon_model', line 14, column 2 to column 13)\", #>   28 :   \" (in 'anon_model', line 17, column 2 to column 22)\", #>   29 :   \" (in 'anon_model', line 18, column 2 to column 22)\", #>   30 :   \" (in 'anon_model', line 19, column 2 to column 18)\", #>   31 :   \" (in 'anon_model', line 20, column 2 to column 35)\", #>   32 :   \" (in 'anon_model', line 24, column 7 to column 46)\", #>   33 :   \" (in 'anon_model', line 23, column 24 to column 46)\", #>   34 :   \" (in 'anon_model', line 23, column 7 to line 24, column 46)\", #>   35 :   \" (in 'anon_model', line 22, column 24 to column 43)\", #>   36 :   \" (in 'anon_model', line 22, column 7 to line 24, column 46)\", #>   37 :   \" (in 'anon_model', line 21, column 19 to column 33)\", #>   38 :   \" (in 'anon_model', line 21, column 2 to line 24, column 46)\", #>   39 :   \" (in 'anon_model', line 25, column 2 to column 29)\", #>   40 :   \" (in 'anon_model', line 28, column 2 to column 31)\", #>   41 :   \" (in 'anon_model', line 29, column 2 to column 20)\", #>   42 :   \" (in 'anon_model', line 30, column 2 to column 23)\", #>   43 :   \" (in 'anon_model', line 31, column 2 to column 23)\", #>   44 :   \" (in 'anon_model', line 32, column 2 to column 29)\", #>   45 :   \" (in 'anon_model', line 2, column 2 to column 17)\", #>   46 :   \" (in 'anon_model', line 3, column 2 to column 17)\", #>   47 :   \" (in 'anon_model', line 4, column 2 to column 17)\", #>   48 :   \" (in 'anon_model', line 5, column 2 to column 21)\", #>   49 :   \" (in 'anon_model', line 6, column 9 to column 10)\", #>   50 :   \" (in 'anon_model', line 6, column 12 to column 13)\", #>   51 :   \" (in 'anon_model', line 6, column 2 to column 17)\", #>   52 :   \" (in 'anon_model', line 7, column 8 to column 9)\", #>   53 :   \" (in 'anon_model', line 7, column 2 to column 35)\", #>   54 :   \" (in 'anon_model', line 8, column 2 to column 31)\", #>   55 :   \" (in 'anon_model', line 11, column 9 to column 10)\", #>   56 :   \" (in 'anon_model', line 11, column 12 to column 17)\", #>   57 :   \" (in 'anon_model', line 12, column 9 to column 14)\", #>   58 :   \" (in 'anon_model', line 13, column 9 to column 14)\", #>   59 :   \" (in 'anon_model', line 17, column 9 to column 10)\", #>   60 :   \" (in 'anon_model', line 17, column 12 to column 17)\", #>   61 :   \" (in 'anon_model', line 18, column 9 to column 10)\", #>   62 :   \" (in 'anon_model', line 18, column 12 to column 17)\", #>   63 :   \" (in 'anon_model', line 19, column 9 to column 10)\"}; #>   64 : class model1d203428b5a4_ final : public model_base_crtp<model1d203428b5a4_> { #>   65 : private: #>   66 :   int n; #>   67 :   int m; #>   68 :   int L; #>   69 :   int nodes; #>   70 :   Eigen::Matrix<double,-1,-1> X_data__; #>   71 :   std::vector<int> y; #>   72 :   int act_fn; #>   73 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> X{nullptr, 0, 0}; #>   74 : public: #>   75 :   ~model1d203428b5a4_() {} #>   76 :   model1d203428b5a4_(stan::io::var_context& context__, unsigned int #>   77 :                      random_seed__ = 0, std::ostream* pstream__ = nullptr) #>   78 :       : model_base_crtp(0) { #>   79 :     int current_statement__ = 0; #>   80 :     using local_scalar_t__ = double; #>   81 :     boost::ecuyer1988 base_rng__ = #>   82 :       stan::services::util::create_rng(random_seed__, 0); #>   83 :     // suppress unused var warning #>   84 :     (void) base_rng__; #>   85 :     static constexpr const char* function__ = #>   86 :       \"model1d203428b5a4__namespace::model1d203428b5a4_\"; #>   87 :     // suppress unused var warning #>   88 :     (void) function__; #>   89 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>   90 :     // suppress unused var warning #>   91 :     (void) DUMMY_VAR__; #>   92 :     try { #>   93 :       int pos__ = std::numeric_limits<int>::min(); #>   94 :       pos__ = 1; #>   95 :       current_statement__ = 22; #>   96 :       context__.validate_dims(\"data initialization\", \"n\", \"int\", #>   97 :         std::vector<size_t>{}); #>   98 :       n = std::numeric_limits<int>::min(); #>   99 :       current_statement__ = 22; #>  100 :       n = context__.vals_i(\"n\")[(1 - 1)]; #>  101 :       current_statement__ = 22; #>  102 :       stan::math::check_greater_or_equal(function__, \"n\", n, 1); #>  103 :       current_statement__ = 23; #>  104 :       context__.validate_dims(\"data initialization\", \"m\", \"int\", #>  105 :         std::vector<size_t>{}); #>  106 :       m = std::numeric_limits<int>::min(); #>  107 :       current_statement__ = 23; #>  108 :       m = context__.vals_i(\"m\")[(1 - 1)]; #>  109 :       current_statement__ = 23; #>  110 :       stan::math::check_greater_or_equal(function__, \"m\", m, 1); #>  111 :       current_statement__ = 24; #>  112 :       context__.validate_dims(\"data initialization\", \"L\", \"int\", #>  113 :         std::vector<size_t>{}); #>  114 :       L = std::numeric_limits<int>::min(); #>  115 :       current_statement__ = 24; #>  116 :       L = context__.vals_i(\"L\")[(1 - 1)]; #>  117 :       current_statement__ = 24; #>  118 :       stan::math::check_greater_or_equal(function__, \"L\", L, 1); #>  119 :       current_statement__ = 25; #>  120 :       context__.validate_dims(\"data initialization\", \"nodes\", \"int\", #>  121 :         std::vector<size_t>{}); #>  122 :       nodes = std::numeric_limits<int>::min(); #>  123 :       current_statement__ = 25; #>  124 :       nodes = context__.vals_i(\"nodes\")[(1 - 1)]; #>  125 :       current_statement__ = 25; #>  126 :       stan::math::check_greater_or_equal(function__, \"nodes\", nodes, 1); #>  127 :       current_statement__ = 26; #>  128 :       stan::math::validate_non_negative_index(\"X\", \"n\", n); #>  129 :       current_statement__ = 27; #>  130 :       stan::math::validate_non_negative_index(\"X\", \"m\", m); #>  131 :       current_statement__ = 28; #>  132 :       context__.validate_dims(\"data initialization\", \"X\", \"double\", #>  133 :         std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m)}); #>  134 :       X_data__ = Eigen::Matrix<double,-1,-1>::Constant(n, m, #>  135 :                    std::numeric_limits<double>::quiet_NaN()); #>  136 :       new (&X) Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_data__.data(), n, m); #>  137 :       { #>  138 :         std::vector<local_scalar_t__> X_flat__; #>  139 :         current_statement__ = 28; #>  140 :         X_flat__ = context__.vals_r(\"X\"); #>  141 :         current_statement__ = 28; #>  142 :         pos__ = 1; #>  143 :         current_statement__ = 28; #>  144 :         for (int sym1__ = 1; sym1__ <= m; ++sym1__) { #>  145 :           current_statement__ = 28; #>  146 :           for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  147 :             current_statement__ = 28; #>  148 :             stan::model::assign(X, X_flat__[(pos__ - 1)], #>  149 :               \"assigning variable X\", stan::model::index_uni(sym2__), #>  150 :               stan::model::index_uni(sym1__)); #>  151 :             current_statement__ = 28; #>  152 :             pos__ = (pos__ + 1); #>  153 :           } #>  154 :         } #>  155 :       } #>  156 :       current_statement__ = 29; #>  157 :       stan::math::validate_non_negative_index(\"y\", \"n\", n); #>  158 :       current_statement__ = 30; #>  159 :       context__.validate_dims(\"data initialization\", \"y\", \"int\", #>  160 :         std::vector<size_t>{static_cast<size_t>(n)}); #>  161 :       y = std::vector<int>(n, std::numeric_limits<int>::min()); #>  162 :       current_statement__ = 30; #>  163 :       y = context__.vals_i(\"y\"); #>  164 :       current_statement__ = 30; #>  165 :       stan::math::check_greater_or_equal(function__, \"y\", y, 0); #>  166 :       current_statement__ = 30; #>  167 :       stan::math::check_less_or_equal(function__, \"y\", y, 1); #>  168 :       current_statement__ = 31; #>  169 :       context__.validate_dims(\"data initialization\", \"act_fn\", \"int\", #>  170 :         std::vector<size_t>{}); #>  171 :       act_fn = std::numeric_limits<int>::min(); #>  172 :       current_statement__ = 31; #>  173 :       act_fn = context__.vals_i(\"act_fn\")[(1 - 1)]; #>  174 :       current_statement__ = 31; #>  175 :       stan::math::check_greater_or_equal(function__, \"act_fn\", act_fn, 1); #>  176 :       current_statement__ = 31; #>  177 :       stan::math::check_less_or_equal(function__, \"act_fn\", act_fn, 3); #>  178 :       current_statement__ = 32; #>  179 :       stan::math::validate_non_negative_index(\"w1\", \"m\", m); #>  180 :       current_statement__ = 33; #>  181 :       stan::math::validate_non_negative_index(\"w1\", \"nodes\", nodes); #>  182 :       current_statement__ = 34; #>  183 :       stan::math::validate_non_negative_index(\"b1\", \"nodes\", nodes); #>  184 :       current_statement__ = 35; #>  185 :       stan::math::validate_non_negative_index(\"w_out\", \"nodes\", nodes); #>  186 :       current_statement__ = 36; #>  187 :       stan::math::validate_non_negative_index(\"z1\", \"n\", n); #>  188 :       current_statement__ = 37; #>  189 :       stan::math::validate_non_negative_index(\"z1\", \"nodes\", nodes); #>  190 :       current_statement__ = 38; #>  191 :       stan::math::validate_non_negative_index(\"a1\", \"n\", n); #>  192 :       current_statement__ = 39; #>  193 :       stan::math::validate_non_negative_index(\"a1\", \"nodes\", nodes); #>  194 :       current_statement__ = 40; #>  195 :       stan::math::validate_non_negative_index(\"y_hat\", \"n\", n); #>  196 :     } catch (const std::exception& e) { #>  197 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  198 :     } #>  199 :     num_params_r__ = (m * nodes) + nodes + nodes + 1; #>  200 :   } #>  201 :   inline std::string model_name() const final { #>  202 :     return \"model1d203428b5a4_\"; #>  203 :   } #>  204 :   inline std::vector<std::string> model_compile_info() const noexcept { #>  205 :     return std::vector<std::string>{\"stanc_version = stanc3 v2.32.2\", #>  206 :              \"stancflags = --\"}; #>  207 :   } #>  208 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI, #>  209 :             stan::require_vector_like_t<VecR>* = nullptr, #>  210 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  211 :   inline stan::scalar_type_t<VecR> #>  212 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream* #>  213 :                 pstream__ = nullptr) const { #>  214 :     using T__ = stan::scalar_type_t<VecR>; #>  215 :     using local_scalar_t__ = T__; #>  216 :     T__ lp__(0.0); #>  217 :     stan::math::accumulator<T__> lp_accum__; #>  218 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  219 :     int current_statement__ = 0; #>  220 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  221 :     // suppress unused var warning #>  222 :     (void) DUMMY_VAR__; #>  223 :     static constexpr const char* function__ = #>  224 :       \"model1d203428b5a4__namespace::log_prob\"; #>  225 :     // suppress unused var warning #>  226 :     (void) function__; #>  227 :     try { #>  228 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  229 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, nodes, #>  230 :           DUMMY_VAR__); #>  231 :       current_statement__ = 1; #>  232 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  233 :              nodes); #>  234 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  235 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nodes, DUMMY_VAR__); #>  236 :       current_statement__ = 2; #>  237 :       b1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(nodes); #>  238 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  239 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nodes, DUMMY_VAR__); #>  240 :       current_statement__ = 3; #>  241 :       w_out = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(nodes); #>  242 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  243 :       current_statement__ = 4; #>  244 :       b_out = in__.template read<local_scalar_t__>(); #>  245 :       Eigen::Matrix<local_scalar_t__,-1,-1> z1 = #>  246 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, nodes, #>  247 :           DUMMY_VAR__); #>  248 :       Eigen::Matrix<local_scalar_t__,-1,-1> a1 = #>  249 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, nodes, #>  250 :           DUMMY_VAR__); #>  251 :       Eigen::Matrix<local_scalar_t__,-1,1> y_hat = #>  252 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n, DUMMY_VAR__); #>  253 :       current_statement__ = 8; #>  254 :       stan::model::assign(z1, #>  255 :         stan::math::add(stan::math::multiply(X, w1), #>  256 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  257 :         \"assigning variable z1\"); #>  258 :       current_statement__ = 15; #>  259 :       if (stan::math::logical_eq(act_fn, 1)) { #>  260 :         current_statement__ = 14; #>  261 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  262 :       } else { #>  263 :         current_statement__ = 13; #>  264 :         if (stan::math::logical_eq(act_fn, 2)) { #>  265 :           current_statement__ = 12; #>  266 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  267 :             \"assigning variable a1\"); #>  268 :         } else { #>  269 :           current_statement__ = 11; #>  270 :           if (stan::math::logical_eq(act_fn, 3)) { #>  271 :             current_statement__ = 10; #>  272 :             stan::model::assign(a1, #>  273 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  274 :               \"assigning variable a1\"); #>  275 :           } else { #>  276 :             current_statement__ = 9; #>  277 :             stan::model::assign(a1, #>  278 :               stan::math::fmax(stan::math::rep_matrix(0, n, nodes), z1), #>  279 :               \"assigning variable a1\"); #>  280 :           } #>  281 :         } #>  282 :       } #>  283 :       current_statement__ = 16; #>  284 :       stan::model::assign(y_hat, #>  285 :         stan::math::add(stan::math::multiply(a1, w_out), b_out), #>  286 :         \"assigning variable y_hat\"); #>  287 :       { #>  288 :         current_statement__ = 17; #>  289 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  290 :                          stan::math::to_vector(w1), 0, 1)); #>  291 :         current_statement__ = 18; #>  292 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b1, 0, 1)); #>  293 :         current_statement__ = 19; #>  294 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(w_out, 0, 1)); #>  295 :         current_statement__ = 20; #>  296 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b_out, 0, 1)); #>  297 :         current_statement__ = 21; #>  298 :         lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(y, y_hat)); #>  299 :       } #>  300 :     } catch (const std::exception& e) { #>  301 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  302 :     } #>  303 :     lp_accum__.add(lp__); #>  304 :     return lp_accum__.sum(); #>  305 :   } #>  306 :   template <typename RNG, typename VecR, typename VecI, typename VecVar, #>  307 :             stan::require_vector_like_vt<std::is_floating_point, #>  308 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, #>  309 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point, #>  310 :             VecVar>* = nullptr> #>  311 :   inline void #>  312 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__, #>  313 :                    VecVar& vars__, const bool #>  314 :                    emit_transformed_parameters__ = true, const bool #>  315 :                    emit_generated_quantities__ = true, std::ostream* #>  316 :                    pstream__ = nullptr) const { #>  317 :     using local_scalar_t__ = double; #>  318 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  319 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  320 :     static constexpr bool propto__ = true; #>  321 :     // suppress unused var warning #>  322 :     (void) propto__; #>  323 :     double lp__ = 0.0; #>  324 :     // suppress unused var warning #>  325 :     (void) lp__; #>  326 :     int current_statement__ = 0; #>  327 :     stan::math::accumulator<double> lp_accum__; #>  328 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  329 :     // suppress unused var warning #>  330 :     (void) DUMMY_VAR__; #>  331 :     constexpr bool jacobian__ = false; #>  332 :     static constexpr const char* function__ = #>  333 :       \"model1d203428b5a4__namespace::write_array\"; #>  334 :     // suppress unused var warning #>  335 :     (void) function__; #>  336 :     try { #>  337 :       Eigen::Matrix<double,-1,-1> w1 = #>  338 :         Eigen::Matrix<double,-1,-1>::Constant(m, nodes, #>  339 :           std::numeric_limits<double>::quiet_NaN()); #>  340 :       current_statement__ = 1; #>  341 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  342 :              nodes); #>  343 :       Eigen::Matrix<double,-1,1> b1 = #>  344 :         Eigen::Matrix<double,-1,1>::Constant(nodes, #>  345 :           std::numeric_limits<double>::quiet_NaN()); #>  346 :       current_statement__ = 2; #>  347 :       b1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(nodes); #>  348 :       Eigen::Matrix<double,-1,1> w_out = #>  349 :         Eigen::Matrix<double,-1,1>::Constant(nodes, #>  350 :           std::numeric_limits<double>::quiet_NaN()); #>  351 :       current_statement__ = 3; #>  352 :       w_out = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(nodes); #>  353 :       double b_out = std::numeric_limits<double>::quiet_NaN(); #>  354 :       current_statement__ = 4; #>  355 :       b_out = in__.template read<local_scalar_t__>(); #>  356 :       Eigen::Matrix<double,-1,-1> z1 = #>  357 :         Eigen::Matrix<double,-1,-1>::Constant(n, nodes, #>  358 :           std::numeric_limits<double>::quiet_NaN()); #>  359 :       Eigen::Matrix<double,-1,-1> a1 = #>  360 :         Eigen::Matrix<double,-1,-1>::Constant(n, nodes, #>  361 :           std::numeric_limits<double>::quiet_NaN()); #>  362 :       Eigen::Matrix<double,-1,1> y_hat = #>  363 :         Eigen::Matrix<double,-1,1>::Constant(n, #>  364 :           std::numeric_limits<double>::quiet_NaN()); #>  365 :       out__.write(w1); #>  366 :       out__.write(b1); #>  367 :       out__.write(w_out); #>  368 :       out__.write(b_out); #>  369 :       if (stan::math::logical_negation( #>  370 :             (stan::math::primitive_value(emit_transformed_parameters__) || #>  371 :             stan::math::primitive_value(emit_generated_quantities__)))) { #>  372 :         return ; #>  373 :       } #>  374 :       current_statement__ = 8; #>  375 :       stan::model::assign(z1, #>  376 :         stan::math::add(stan::math::multiply(X, w1), #>  377 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  378 :         \"assigning variable z1\"); #>  379 :       current_statement__ = 15; #>  380 :       if (stan::math::logical_eq(act_fn, 1)) { #>  381 :         current_statement__ = 14; #>  382 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  383 :       } else { #>  384 :         current_statement__ = 13; #>  385 :         if (stan::math::logical_eq(act_fn, 2)) { #>  386 :           current_statement__ = 12; #>  387 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  388 :             \"assigning variable a1\"); #>  389 :         } else { #>  390 :           current_statement__ = 11; #>  391 :           if (stan::math::logical_eq(act_fn, 3)) { #>  392 :             current_statement__ = 10; #>  393 :             stan::model::assign(a1, #>  394 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  395 :               \"assigning variable a1\"); #>  396 :           } else { #>  397 :             current_statement__ = 9; #>  398 :             stan::model::assign(a1, #>  399 :               stan::math::fmax(stan::math::rep_matrix(0, n, nodes), z1), #>  400 :               \"assigning variable a1\"); #>  401 :           } #>  402 :         } #>  403 :       } #>  404 :       current_statement__ = 16; #>  405 :       stan::model::assign(y_hat, #>  406 :         stan::math::add(stan::math::multiply(a1, w_out), b_out), #>  407 :         \"assigning variable y_hat\"); #>  408 :       if (emit_transformed_parameters__) { #>  409 :         out__.write(z1); #>  410 :         out__.write(a1); #>  411 :         out__.write(y_hat); #>  412 :       } #>  413 :       if (stan::math::logical_negation(emit_generated_quantities__)) { #>  414 :         return ; #>  415 :       } #>  416 :     } catch (const std::exception& e) { #>  417 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  418 :     } #>  419 :   } #>  420 :   template <typename VecVar, typename VecI, #>  421 :             stan::require_vector_t<VecVar>* = nullptr, #>  422 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  423 :   inline void #>  424 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__, #>  425 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const { #>  426 :     using local_scalar_t__ = double; #>  427 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  428 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  429 :     int current_statement__ = 0; #>  430 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  431 :     // suppress unused var warning #>  432 :     (void) DUMMY_VAR__; #>  433 :     try { #>  434 :       int pos__ = std::numeric_limits<int>::min(); #>  435 :       pos__ = 1; #>  436 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  437 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, nodes, #>  438 :           DUMMY_VAR__); #>  439 :       current_statement__ = 1; #>  440 :       stan::model::assign(w1, #>  441 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, nodes), #>  442 :         \"assigning variable w1\"); #>  443 :       out__.write(w1); #>  444 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  445 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nodes, DUMMY_VAR__); #>  446 :       current_statement__ = 2; #>  447 :       stan::model::assign(b1, #>  448 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(nodes), #>  449 :         \"assigning variable b1\"); #>  450 :       out__.write(b1); #>  451 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  452 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nodes, DUMMY_VAR__); #>  453 :       current_statement__ = 3; #>  454 :       stan::model::assign(w_out, #>  455 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(nodes), #>  456 :         \"assigning variable w_out\"); #>  457 :       out__.write(w_out); #>  458 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  459 :       current_statement__ = 4; #>  460 :       b_out = in__.read<local_scalar_t__>(); #>  461 :       out__.write(b_out); #>  462 :     } catch (const std::exception& e) { #>  463 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  464 :     } #>  465 :   } #>  466 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr> #>  467 :   inline void #>  468 :   transform_inits_impl(const stan::io::var_context& context__, VecVar& #>  469 :                        vars__, std::ostream* pstream__ = nullptr) const { #>  470 :     using local_scalar_t__ = double; #>  471 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  472 :     int current_statement__ = 0; #>  473 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  474 :     // suppress unused var warning #>  475 :     (void) DUMMY_VAR__; #>  476 :     try { #>  477 :       current_statement__ = 1; #>  478 :       context__.validate_dims(\"parameter initialization\", \"w1\", \"double\", #>  479 :         std::vector<size_t>{static_cast<size_t>(m), #>  480 :           static_cast<size_t>(nodes)}); #>  481 :       current_statement__ = 2; #>  482 :       context__.validate_dims(\"parameter initialization\", \"b1\", \"double\", #>  483 :         std::vector<size_t>{static_cast<size_t>(nodes)}); #>  484 :       current_statement__ = 3; #>  485 :       context__.validate_dims(\"parameter initialization\", \"w_out\", \"double\", #>  486 :         std::vector<size_t>{static_cast<size_t>(nodes)}); #>  487 :       current_statement__ = 4; #>  488 :       context__.validate_dims(\"parameter initialization\", \"b_out\", \"double\", #>  489 :         std::vector<size_t>{}); #>  490 :       int pos__ = std::numeric_limits<int>::min(); #>  491 :       pos__ = 1; #>  492 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  493 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, nodes, #>  494 :           DUMMY_VAR__); #>  495 :       { #>  496 :         std::vector<local_scalar_t__> w1_flat__; #>  497 :         current_statement__ = 1; #>  498 :         w1_flat__ = context__.vals_r(\"w1\"); #>  499 :         current_statement__ = 1; #>  500 :         pos__ = 1; #>  501 :         current_statement__ = 1; #>  502 :         for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  503 :           current_statement__ = 1; #>  504 :           for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  505 :             current_statement__ = 1; #>  506 :             stan::model::assign(w1, w1_flat__[(pos__ - 1)], #>  507 :               \"assigning variable w1\", stan::model::index_uni(sym2__), #>  508 :               stan::model::index_uni(sym1__)); #>  509 :             current_statement__ = 1; #>  510 :             pos__ = (pos__ + 1); #>  511 :           } #>  512 :         } #>  513 :       } #>  514 :       out__.write(w1); #>  515 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  516 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nodes, DUMMY_VAR__); #>  517 :       { #>  518 :         std::vector<local_scalar_t__> b1_flat__; #>  519 :         current_statement__ = 2; #>  520 :         b1_flat__ = context__.vals_r(\"b1\"); #>  521 :         current_statement__ = 2; #>  522 :         pos__ = 1; #>  523 :         current_statement__ = 2; #>  524 :         for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  525 :           current_statement__ = 2; #>  526 :           stan::model::assign(b1, b1_flat__[(pos__ - 1)], #>  527 :             \"assigning variable b1\", stan::model::index_uni(sym1__)); #>  528 :           current_statement__ = 2; #>  529 :           pos__ = (pos__ + 1); #>  530 :         } #>  531 :       } #>  532 :       out__.write(b1); #>  533 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  534 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(nodes, DUMMY_VAR__); #>  535 :       { #>  536 :         std::vector<local_scalar_t__> w_out_flat__; #>  537 :         current_statement__ = 3; #>  538 :         w_out_flat__ = context__.vals_r(\"w_out\"); #>  539 :         current_statement__ = 3; #>  540 :         pos__ = 1; #>  541 :         current_statement__ = 3; #>  542 :         for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  543 :           current_statement__ = 3; #>  544 :           stan::model::assign(w_out, w_out_flat__[(pos__ - 1)], #>  545 :             \"assigning variable w_out\", stan::model::index_uni(sym1__)); #>  546 :           current_statement__ = 3; #>  547 :           pos__ = (pos__ + 1); #>  548 :         } #>  549 :       } #>  550 :       out__.write(w_out); #>  551 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  552 :       current_statement__ = 4; #>  553 :       b_out = context__.vals_r(\"b_out\")[(1 - 1)]; #>  554 :       out__.write(b_out); #>  555 :     } catch (const std::exception& e) { #>  556 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  557 :     } #>  558 :   } #>  559 :   inline void #>  560 :   get_param_names(std::vector<std::string>& names__, const bool #>  561 :                   emit_transformed_parameters__ = true, const bool #>  562 :                   emit_generated_quantities__ = true) const { #>  563 :     names__ = std::vector<std::string>{\"w1\", \"b1\", \"w_out\", \"b_out\"}; #>  564 :     if (emit_transformed_parameters__) { #>  565 :       std::vector<std::string> temp{\"z1\", \"a1\", \"y_hat\"}; #>  566 :       names__.reserve(names__.size() + temp.size()); #>  567 :       names__.insert(names__.end(), temp.begin(), temp.end()); #>  568 :     } #>  569 :     if (emit_generated_quantities__) {} #>  570 :   } #>  571 :   inline void #>  572 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool #>  573 :            emit_transformed_parameters__ = true, const bool #>  574 :            emit_generated_quantities__ = true) const { #>  575 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast< #>  576 :                                                                     size_t>(m), #>  577 :                                                  static_cast<size_t>(nodes)}, #>  578 :                 std::vector<size_t>{static_cast<size_t>(nodes)}, #>  579 :                 std::vector<size_t>{static_cast<size_t>(nodes)}, #>  580 :                 std::vector<size_t>{}}; #>  581 :     if (emit_transformed_parameters__) { #>  582 :       std::vector<std::vector<size_t>> #>  583 :         temp{std::vector<size_t>{static_cast<size_t>(n), #>  584 :                static_cast<size_t>(nodes)}, #>  585 :              std::vector<size_t>{static_cast<size_t>(n), #>  586 :                static_cast<size_t>(nodes)}, #>  587 :              std::vector<size_t>{static_cast<size_t>(n)}}; #>  588 :       dimss__.reserve(dimss__.size() + temp.size()); #>  589 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end()); #>  590 :     } #>  591 :     if (emit_generated_quantities__) {} #>  592 :   } #>  593 :   inline void #>  594 :   constrained_param_names(std::vector<std::string>& param_names__, bool #>  595 :                           emit_transformed_parameters__ = true, bool #>  596 :                           emit_generated_quantities__ = true) const final { #>  597 :     for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  598 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  599 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #>  600 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  601 :       } #>  602 :     } #>  603 :     for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  604 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #>  605 :         std::to_string(sym1__)); #>  606 :     } #>  607 :     for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  608 :       param_names__.emplace_back(std::string() + \"w_out\" + '.' + #>  609 :         std::to_string(sym1__)); #>  610 :     } #>  611 :     param_names__.emplace_back(std::string() + \"b_out\"); #>  612 :     if (emit_transformed_parameters__) { #>  613 :       for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  614 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  615 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #>  616 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  617 :         } #>  618 :       } #>  619 :       for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  620 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  621 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #>  622 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  623 :         } #>  624 :       } #>  625 :       for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #>  626 :         param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #>  627 :           std::to_string(sym1__)); #>  628 :       } #>  629 :     } #>  630 :     if (emit_generated_quantities__) {} #>  631 :   } #>  632 :   inline void #>  633 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool #>  634 :                             emit_transformed_parameters__ = true, bool #>  635 :                             emit_generated_quantities__ = true) const final { #>  636 :     for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  637 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  638 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #>  639 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  640 :       } #>  641 :     } #>  642 :     for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  643 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #>  644 :         std::to_string(sym1__)); #>  645 :     } #>  646 :     for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  647 :       param_names__.emplace_back(std::string() + \"w_out\" + '.' + #>  648 :         std::to_string(sym1__)); #>  649 :     } #>  650 :     param_names__.emplace_back(std::string() + \"b_out\"); #>  651 :     if (emit_transformed_parameters__) { #>  652 :       for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  653 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  654 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #>  655 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  656 :         } #>  657 :       } #>  658 :       for (int sym1__ = 1; sym1__ <= nodes; ++sym1__) { #>  659 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  660 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #>  661 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  662 :         } #>  663 :       } #>  664 :       for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #>  665 :         param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #>  666 :           std::to_string(sym1__)); #>  667 :       } #>  668 :     } #>  669 :     if (emit_generated_quantities__) {} #>  670 :   } #>  671 :   inline std::string get_constrained_sizedtypes() const { #>  672 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(nodes) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(nodes) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(nodes) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(nodes) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(nodes) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(n) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #>  673 :   } #>  674 :   inline std::string get_unconstrained_sizedtypes() const { #>  675 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(nodes) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(nodes) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(nodes) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(nodes) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(nodes) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(n) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #>  676 :   } #>  677 :   // Begin method overload boilerplate #>  678 :   template <typename RNG> inline void #>  679 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r, #>  680 :               Eigen::Matrix<double,-1,1>& vars, const bool #>  681 :               emit_transformed_parameters = true, const bool #>  682 :               emit_generated_quantities = true, std::ostream* #>  683 :               pstream = nullptr) const { #>  684 :     const size_t num_params__ = ((((m * nodes) + nodes) + nodes) + 1); #>  685 :     const size_t num_transformed = emit_transformed_parameters * ((((n * #>  686 :       nodes) + (n * nodes)) + n)); #>  687 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #>  688 :     const size_t num_to_write = num_params__ + num_transformed + #>  689 :       num_gen_quantities; #>  690 :     std::vector<int> params_i; #>  691 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write, #>  692 :              std::numeric_limits<double>::quiet_NaN()); #>  693 :     write_array_impl(base_rng, params_r, params_i, vars, #>  694 :       emit_transformed_parameters, emit_generated_quantities, pstream); #>  695 :   } #>  696 :   template <typename RNG> inline void #>  697 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>& #>  698 :               params_i, std::vector<double>& vars, bool #>  699 :               emit_transformed_parameters = true, bool #>  700 :               emit_generated_quantities = true, std::ostream* #>  701 :               pstream = nullptr) const { #>  702 :     const size_t num_params__ = ((((m * nodes) + nodes) + nodes) + 1); #>  703 :     const size_t num_transformed = emit_transformed_parameters * ((((n * #>  704 :       nodes) + (n * nodes)) + n)); #>  705 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #>  706 :     const size_t num_to_write = num_params__ + num_transformed + #>  707 :       num_gen_quantities; #>  708 :     vars = std::vector<double>(num_to_write, #>  709 :              std::numeric_limits<double>::quiet_NaN()); #>  710 :     write_array_impl(base_rng, params_r, params_i, vars, #>  711 :       emit_transformed_parameters, emit_generated_quantities, pstream); #>  712 :   } #>  713 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #>  714 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const { #>  715 :     Eigen::Matrix<int,-1,1> params_i; #>  716 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #>  717 :   } #>  718 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #>  719 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i, #>  720 :            std::ostream* pstream = nullptr) const { #>  721 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #>  722 :   } #>  723 :   inline void #>  724 :   transform_inits(const stan::io::var_context& context, #>  725 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream* #>  726 :                   pstream = nullptr) const final { #>  727 :     std::vector<double> params_r_vec(params_r.size()); #>  728 :     std::vector<int> params_i; #>  729 :     transform_inits(context, params_i, params_r_vec, pstream); #>  730 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(), #>  731 :                  params_r_vec.size()); #>  732 :   } #>  733 :   inline void #>  734 :   transform_inits(const stan::io::var_context& context, std::vector<int>& #>  735 :                   params_i, std::vector<double>& vars, std::ostream* #>  736 :                   pstream__ = nullptr) const { #>  737 :     vars.resize(num_params_r__); #>  738 :     transform_inits_impl(context, vars, pstream__); #>  739 :   } #>  740 :   inline void #>  741 :   unconstrain_array(const std::vector<double>& params_constrained, #>  742 :                     std::vector<double>& params_unconstrained, std::ostream* #>  743 :                     pstream = nullptr) const { #>  744 :     const std::vector<int> params_i; #>  745 :     params_unconstrained = std::vector<double>(num_params_r__, #>  746 :                              std::numeric_limits<double>::quiet_NaN()); #>  747 :     unconstrain_array_impl(params_constrained, params_i, #>  748 :       params_unconstrained, pstream); #>  749 :   } #>  750 :   inline void #>  751 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained, #>  752 :                     Eigen::Matrix<double,-1,1>& params_unconstrained, #>  753 :                     std::ostream* pstream = nullptr) const { #>  754 :     const std::vector<int> params_i; #>  755 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__, #>  756 :                              std::numeric_limits<double>::quiet_NaN()); #>  757 :     unconstrain_array_impl(params_constrained, params_i, #>  758 :       params_unconstrained, pstream); #>  759 :   } #>  760 : }; #>  761 : } #>  762 : using stan_model = model1d203428b5a4__namespace::model1d203428b5a4_; #>  763 : #ifndef USING_R #>  764 : // Boilerplate #>  765 : stan::model::model_base& #>  766 : new_model(stan::io::var_context& data_context, unsigned int seed, #>  767 :           std::ostream* msg_stream) { #>  768 :   stan_model* m = new stan_model(data_context, seed, msg_stream); #>  769 :   return *m; #>  770 : } #>  771 : stan::math::profile_map& get_stan_profile_data() { #>  772 :   return model1d203428b5a4__namespace::profiles__; #>  773 : } #>  774 : #endif #>  775 : #endif #>  776 :  #>  777 : RCPP_MODULE(stan_fit4model1d203428b5a4__mod) { #>  778 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >( #>  779 :       \"stan_fit4model1d203428b5a4_\") #>  780 :  #>  781 :       .constructor<SEXP, SEXP, SEXP>() #>  782 :  #>  783 :       .method( #>  784 :           \"call_sampler\", #>  785 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler) #>  786 :       .method( #>  787 :           \"param_names\", #>  788 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names) #>  789 :       .method(\"param_names_oi\", #>  790 :               &rstan::stan_fit<stan_model, #>  791 :                                boost::random::ecuyer1988>::param_names_oi) #>  792 :       .method(\"param_fnames_oi\", #>  793 :               &rstan::stan_fit<stan_model, #>  794 :                                boost::random::ecuyer1988>::param_fnames_oi) #>  795 :       .method( #>  796 :           \"param_dims\", #>  797 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims) #>  798 :       .method(\"param_dims_oi\", #>  799 :               &rstan::stan_fit<stan_model, #>  800 :                                boost::random::ecuyer1988>::param_dims_oi) #>  801 :       .method(\"update_param_oi\", #>  802 :               &rstan::stan_fit<stan_model, #>  803 :                                boost::random::ecuyer1988>::update_param_oi) #>  804 :       .method(\"param_oi_tidx\", #>  805 :               &rstan::stan_fit<stan_model, #>  806 :                                boost::random::ecuyer1988>::param_oi_tidx) #>  807 :       .method(\"grad_log_prob\", #>  808 :               &rstan::stan_fit<stan_model, #>  809 :                                boost::random::ecuyer1988>::grad_log_prob) #>  810 :       .method(\"log_prob\", #>  811 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob) #>  812 :       .method(\"unconstrain_pars\", #>  813 :               &rstan::stan_fit<stan_model, #>  814 :                                boost::random::ecuyer1988>::unconstrain_pars) #>  815 :       .method(\"constrain_pars\", #>  816 :               &rstan::stan_fit<stan_model, #>  817 :                                boost::random::ecuyer1988>::constrain_pars) #>  818 :       .method( #>  819 :           \"num_pars_unconstrained\", #>  820 :           &rstan::stan_fit<stan_model, #>  821 :                            boost::random::ecuyer1988>::num_pars_unconstrained) #>  822 :       .method( #>  823 :           \"unconstrained_param_names\", #>  824 :           &rstan::stan_fit< #>  825 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names) #>  826 :       .method( #>  827 :           \"constrained_param_names\", #>  828 :           &rstan::stan_fit<stan_model, #>  829 :                            boost::random::ecuyer1988>::constrained_param_names) #>  830 :       .method(\"standalone_gqs\", #>  831 :               &rstan::stan_fit<stan_model, #>  832 :                                boost::random::ecuyer1988>::standalone_gqs); #>  833 : } #>  834 :  #>  835 :  #>  836 : // declarations #>  837 : extern \"C\" { #>  838 : SEXP file1d2017ae8875( ) ; #>  839 : } #>  840 :  #>  841 : // definition #>  842 : SEXP file1d2017ae8875() { #>  843 :  return Rcpp::wrap(\"anon_model\"); #>  844 : } #>  #> CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW. #>  #> COMPILING MODEL 'anon_model' NOW. #>  #> STARTING SAMPLER FOR MODEL 'anon_model' NOW."},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"multiclass-classification-example","dir":"Articles","previous_headings":"3. Fitting a Bayesian Neural Network Model","what":"Multiclass Classification Example","title":"Getting Started with the bnns Package","text":"","code":"model_cat <- bnns(   y_cat ~ -1  + x1 + x2,   data = df,   L = 3,   nodes = c(32, 16, 8),   act_fn = c(3, 2, 2),   out_act_fn = 3,          # Output activation: 3 = Softmax   iter = 2e2,    warmup = 1e2,    chains = 1 ) #>  #> TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW. #> OS: x86_64, linux-gnu; rstan: 2.32.6; Rcpp: 1.0.13.1; inline: 0.3.20  #>  >> setting environment variables:  #> PKG_LIBS =  '/home/runner/work/_temp/Library/rstan/lib//libStanServices.a' -L'/home/runner/work/_temp/Library/StanHeaders/lib/' -lStanHeaders -L'/home/runner/work/_temp/Library/RcppParallel/lib/' -ltbb  #> PKG_CPPFLAGS =   -I\"/home/runner/work/_temp/Library/Rcpp/include/\"  -I\"/home/runner/work/_temp/Library/RcppEigen/include/\"  -I\"/home/runner/work/_temp/Library/RcppEigen/include/unsupported\"  -I\"/home/runner/work/_temp/Library/BH/include\" -I\"/home/runner/work/_temp/Library/StanHeaders/include/src/\"  -I\"/home/runner/work/_temp/Library/StanHeaders/include/\"  -I\"/home/runner/work/_temp/Library/RcppParallel/include/\"  -I\"/home/runner/work/_temp/Library/rstan/include\" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/runner/work/_temp/Library/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1  #>  >> Program source : #>  #>    1 :  #>    2 : // includes from the plugin #>    3 : // [[Rcpp::plugins(cpp14)]] #>    4 :  #>    5 :  #>    6 : // user includes #>    7 : #include <Rcpp.h> #>    8 : using namespace Rcpp; #>    9 : #ifndef MODELS_HPP #>   10 : #define MODELS_HPP #>   11 : #define STAN__SERVICES__COMMAND_HPP #>   12 : #include <rstan/rstaninc.hpp> #>   13 : #ifndef USE_STANC3 #>   14 : #define USE_STANC3 #>   15 : #endif #>   16 : // Code generated by stanc v2.32.2 #>   17 : #include <stan/model/model_header.hpp> #>   18 : namespace model1d20eab5182__namespace { #>   19 : using stan::model::model_base_crtp; #>   20 : using namespace stan::math; #>   21 : stan::math::profile_map profiles__; #>   22 : static constexpr std::array<const char*, 90> locations_array__ = #>   23 :   {\" (found before start of program)\", #>   24 :   \" (in 'anon_model', line 12, column 2 to column 25)\", #>   25 :   \" (in 'anon_model', line 13, column 2 to column 22)\", #>   26 :   \" (in 'anon_model', line 14, column 2 to column 32)\", #>   27 :   \" (in 'anon_model', line 15, column 2 to column 22)\", #>   28 :   \" (in 'anon_model', line 16, column 2 to column 32)\", #>   29 :   \" (in 'anon_model', line 17, column 2 to column 22)\", #>   30 :   \" (in 'anon_model', line 18, column 2 to column 28)\", #>   31 :   \" (in 'anon_model', line 19, column 2 to column 18)\", #>   32 :   \" (in 'anon_model', line 22, column 2 to column 25)\", #>   33 :   \" (in 'anon_model', line 23, column 2 to column 25)\", #>   34 :   \" (in 'anon_model', line 24, column 2 to column 25)\", #>   35 :   \" (in 'anon_model', line 25, column 2 to column 25)\", #>   36 :   \" (in 'anon_model', line 26, column 2 to column 25)\", #>   37 :   \" (in 'anon_model', line 27, column 2 to column 25)\", #>   38 :   \" (in 'anon_model', line 28, column 2 to column 21)\", #>   39 :   \" (in 'anon_model', line 29, column 2 to column 35)\", #>   40 :   \" (in 'anon_model', line 33, column 7 to column 49)\", #>   41 :   \" (in 'anon_model', line 32, column 27 to column 49)\", #>   42 :   \" (in 'anon_model', line 32, column 7 to line 33, column 49)\", #>   43 :   \" (in 'anon_model', line 31, column 27 to column 46)\", #>   44 :   \" (in 'anon_model', line 31, column 7 to line 33, column 49)\", #>   45 :   \" (in 'anon_model', line 30, column 22 to column 36)\", #>   46 :   \" (in 'anon_model', line 30, column 2 to line 33, column 49)\", #>   47 :   \" (in 'anon_model', line 34, column 2 to column 36)\", #>   48 :   \" (in 'anon_model', line 38, column 7 to column 49)\", #>   49 :   \" (in 'anon_model', line 37, column 27 to column 49)\", #>   50 :   \" (in 'anon_model', line 37, column 7 to line 38, column 49)\", #>   51 :   \" (in 'anon_model', line 36, column 27 to column 46)\", #>   52 :   \" (in 'anon_model', line 36, column 7 to line 38, column 49)\", #>   53 :   \" (in 'anon_model', line 35, column 22 to column 36)\", #>   54 :   \" (in 'anon_model', line 35, column 2 to line 38, column 49)\", #>   55 :   \" (in 'anon_model', line 39, column 2 to column 36)\", #>   56 :   \" (in 'anon_model', line 43, column 7 to column 49)\", #>   57 :   \" (in 'anon_model', line 42, column 27 to column 49)\", #>   58 :   \" (in 'anon_model', line 42, column 7 to line 43, column 49)\", #>   59 :   \" (in 'anon_model', line 41, column 27 to column 46)\", #>   60 :   \" (in 'anon_model', line 41, column 7 to line 43, column 49)\", #>   61 :   \" (in 'anon_model', line 40, column 22 to column 36)\", #>   62 :   \" (in 'anon_model', line 40, column 2 to line 43, column 49)\", #>   63 :   \" (in 'anon_model', line 44, column 2 to column 45)\", #>   64 :   \" (in 'anon_model', line 47, column 2 to column 31)\", #>   65 :   \" (in 'anon_model', line 48, column 2 to column 20)\", #>   66 :   \" (in 'anon_model', line 49, column 2 to column 31)\", #>   67 :   \" (in 'anon_model', line 50, column 2 to column 20)\", #>   68 :   \" (in 'anon_model', line 51, column 2 to column 31)\", #>   69 :   \" (in 'anon_model', line 52, column 2 to column 20)\", #>   70 :   \" (in 'anon_model', line 53, column 2 to column 34)\", #>   71 :   \" (in 'anon_model', line 54, column 2 to column 23)\", #>   72 :   \" (in 'anon_model', line 55, column 17 to column 53)\", #>   73 :   \" (in 'anon_model', line 55, column 2 to column 53)\", #>   74 :   \" (in 'anon_model', line 2, column 2 to column 17)\", #>   75 :   \" (in 'anon_model', line 3, column 2 to column 17)\", #>   76 :   \" (in 'anon_model', line 4, column 2 to column 17)\", #>   77 :   \" (in 'anon_model', line 5, column 21 to column 22)\", #>   78 :   \" (in 'anon_model', line 5, column 2 to column 24)\", #>   79 :   \" (in 'anon_model', line 6, column 9 to column 10)\", #>   80 :   \" (in 'anon_model', line 6, column 12 to column 13)\", #>   81 :   \" (in 'anon_model', line 6, column 2 to column 17)\", #>   82 :   \" (in 'anon_model', line 7, column 8 to column 9)\", #>   83 :   \" (in 'anon_model', line 7, column 2 to column 26)\", #>   84 :   \" (in 'anon_model', line 8, column 22 to column 23)\", #>   85 :   \" (in 'anon_model', line 8, column 2 to column 25)\", #>   86 :   \" (in 'anon_model', line 9, column 2 to column 17)\", #>   87 :   \" (in 'anon_model', line 12, column 9 to column 10)\", #>   88 :   \" (in 'anon_model', line 12, column 12 to column 20)\", #>   89 :   \" (in 'anon_model', line 13, column 9 to column 17)\", #>   90 :   \" (in 'anon_model', line 14, column 9 to column 17)\", #>   91 :   \" (in 'anon_model', line 14, column 19 to column 27)\", #>   92 :   \" (in 'anon_model', line 15, column 9 to column 17)\", #>   93 :   \" (in 'anon_model', line 16, column 9 to column 17)\", #>   94 :   \" (in 'anon_model', line 16, column 19 to column 27)\", #>   95 :   \" (in 'anon_model', line 17, column 9 to column 17)\", #>   96 :   \" (in 'anon_model', line 18, column 9 to column 17)\", #>   97 :   \" (in 'anon_model', line 18, column 19 to column 20)\", #>   98 :   \" (in 'anon_model', line 19, column 9 to column 10)\", #>   99 :   \" (in 'anon_model', line 22, column 9 to column 10)\", #>  100 :   \" (in 'anon_model', line 22, column 12 to column 20)\", #>  101 :   \" (in 'anon_model', line 23, column 9 to column 10)\", #>  102 :   \" (in 'anon_model', line 23, column 12 to column 20)\", #>  103 :   \" (in 'anon_model', line 24, column 9 to column 10)\", #>  104 :   \" (in 'anon_model', line 24, column 12 to column 20)\", #>  105 :   \" (in 'anon_model', line 25, column 9 to column 10)\", #>  106 :   \" (in 'anon_model', line 25, column 12 to column 20)\", #>  107 :   \" (in 'anon_model', line 26, column 9 to column 10)\", #>  108 :   \" (in 'anon_model', line 26, column 12 to column 20)\", #>  109 :   \" (in 'anon_model', line 27, column 9 to column 10)\", #>  110 :   \" (in 'anon_model', line 27, column 12 to column 20)\", #>  111 :   \" (in 'anon_model', line 28, column 9 to column 10)\", #>  112 :   \" (in 'anon_model', line 28, column 12 to column 13)\"}; #>  113 : class model1d20eab5182_ final : public model_base_crtp<model1d20eab5182_> { #>  114 : private: #>  115 :   int n; #>  116 :   int m; #>  117 :   int L; #>  118 :   std::vector<int> nodes; #>  119 :   Eigen::Matrix<double,-1,-1> X_data__; #>  120 :   std::vector<int> y; #>  121 :   std::vector<int> act_fn; #>  122 :   int K; #>  123 :   int w1_2dim__; #>  124 :   int b1_1dim__; #>  125 :   int w2_1dim__; #>  126 :   int w2_2dim__; #>  127 :   int b2_1dim__; #>  128 :   int w3_1dim__; #>  129 :   int w3_2dim__; #>  130 :   int b3_1dim__; #>  131 :   int w_out_1dim__; #>  132 :   int z1_2dim__; #>  133 :   int a1_2dim__; #>  134 :   int z2_2dim__; #>  135 :   int a2_2dim__; #>  136 :   int z3_2dim__; #>  137 :   int a3_2dim__; #>  138 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> X{nullptr, 0, 0}; #>  139 : public: #>  140 :   ~model1d20eab5182_() {} #>  141 :   model1d20eab5182_(stan::io::var_context& context__, unsigned int #>  142 :                     random_seed__ = 0, std::ostream* pstream__ = nullptr) #>  143 :       : model_base_crtp(0) { #>  144 :     int current_statement__ = 0; #>  145 :     using local_scalar_t__ = double; #>  146 :     boost::ecuyer1988 base_rng__ = #>  147 :       stan::services::util::create_rng(random_seed__, 0); #>  148 :     // suppress unused var warning #>  149 :     (void) base_rng__; #>  150 :     static constexpr const char* function__ = #>  151 :       \"model1d20eab5182__namespace::model1d20eab5182_\"; #>  152 :     // suppress unused var warning #>  153 :     (void) function__; #>  154 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  155 :     // suppress unused var warning #>  156 :     (void) DUMMY_VAR__; #>  157 :     try { #>  158 :       int pos__ = std::numeric_limits<int>::min(); #>  159 :       pos__ = 1; #>  160 :       current_statement__ = 51; #>  161 :       context__.validate_dims(\"data initialization\", \"n\", \"int\", #>  162 :         std::vector<size_t>{}); #>  163 :       n = std::numeric_limits<int>::min(); #>  164 :       current_statement__ = 51; #>  165 :       n = context__.vals_i(\"n\")[(1 - 1)]; #>  166 :       current_statement__ = 51; #>  167 :       stan::math::check_greater_or_equal(function__, \"n\", n, 1); #>  168 :       current_statement__ = 52; #>  169 :       context__.validate_dims(\"data initialization\", \"m\", \"int\", #>  170 :         std::vector<size_t>{}); #>  171 :       m = std::numeric_limits<int>::min(); #>  172 :       current_statement__ = 52; #>  173 :       m = context__.vals_i(\"m\")[(1 - 1)]; #>  174 :       current_statement__ = 52; #>  175 :       stan::math::check_greater_or_equal(function__, \"m\", m, 1); #>  176 :       current_statement__ = 53; #>  177 :       context__.validate_dims(\"data initialization\", \"L\", \"int\", #>  178 :         std::vector<size_t>{}); #>  179 :       L = std::numeric_limits<int>::min(); #>  180 :       current_statement__ = 53; #>  181 :       L = context__.vals_i(\"L\")[(1 - 1)]; #>  182 :       current_statement__ = 53; #>  183 :       stan::math::check_greater_or_equal(function__, \"L\", L, 1); #>  184 :       current_statement__ = 54; #>  185 :       stan::math::validate_non_negative_index(\"nodes\", \"L\", L); #>  186 :       current_statement__ = 55; #>  187 :       context__.validate_dims(\"data initialization\", \"nodes\", \"int\", #>  188 :         std::vector<size_t>{static_cast<size_t>(L)}); #>  189 :       nodes = std::vector<int>(L, std::numeric_limits<int>::min()); #>  190 :       current_statement__ = 55; #>  191 :       nodes = context__.vals_i(\"nodes\"); #>  192 :       current_statement__ = 55; #>  193 :       stan::math::check_greater_or_equal(function__, \"nodes\", nodes, 1); #>  194 :       current_statement__ = 56; #>  195 :       stan::math::validate_non_negative_index(\"X\", \"n\", n); #>  196 :       current_statement__ = 57; #>  197 :       stan::math::validate_non_negative_index(\"X\", \"m\", m); #>  198 :       current_statement__ = 58; #>  199 :       context__.validate_dims(\"data initialization\", \"X\", \"double\", #>  200 :         std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m)}); #>  201 :       X_data__ = Eigen::Matrix<double,-1,-1>::Constant(n, m, #>  202 :                    std::numeric_limits<double>::quiet_NaN()); #>  203 :       new (&X) Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_data__.data(), n, m); #>  204 :       { #>  205 :         std::vector<local_scalar_t__> X_flat__; #>  206 :         current_statement__ = 58; #>  207 :         X_flat__ = context__.vals_r(\"X\"); #>  208 :         current_statement__ = 58; #>  209 :         pos__ = 1; #>  210 :         current_statement__ = 58; #>  211 :         for (int sym1__ = 1; sym1__ <= m; ++sym1__) { #>  212 :           current_statement__ = 58; #>  213 :           for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  214 :             current_statement__ = 58; #>  215 :             stan::model::assign(X, X_flat__[(pos__ - 1)], #>  216 :               \"assigning variable X\", stan::model::index_uni(sym2__), #>  217 :               stan::model::index_uni(sym1__)); #>  218 :             current_statement__ = 58; #>  219 :             pos__ = (pos__ + 1); #>  220 :           } #>  221 :         } #>  222 :       } #>  223 :       current_statement__ = 59; #>  224 :       stan::math::validate_non_negative_index(\"y\", \"n\", n); #>  225 :       current_statement__ = 60; #>  226 :       context__.validate_dims(\"data initialization\", \"y\", \"int\", #>  227 :         std::vector<size_t>{static_cast<size_t>(n)}); #>  228 :       y = std::vector<int>(n, std::numeric_limits<int>::min()); #>  229 :       current_statement__ = 60; #>  230 :       y = context__.vals_i(\"y\"); #>  231 :       current_statement__ = 60; #>  232 :       stan::math::check_greater_or_equal(function__, \"y\", y, 1); #>  233 :       current_statement__ = 61; #>  234 :       stan::math::validate_non_negative_index(\"act_fn\", \"L\", L); #>  235 :       current_statement__ = 62; #>  236 :       context__.validate_dims(\"data initialization\", \"act_fn\", \"int\", #>  237 :         std::vector<size_t>{static_cast<size_t>(L)}); #>  238 :       act_fn = std::vector<int>(L, std::numeric_limits<int>::min()); #>  239 :       current_statement__ = 62; #>  240 :       act_fn = context__.vals_i(\"act_fn\"); #>  241 :       current_statement__ = 62; #>  242 :       stan::math::check_greater_or_equal(function__, \"act_fn\", act_fn, 1); #>  243 :       current_statement__ = 63; #>  244 :       context__.validate_dims(\"data initialization\", \"K\", \"int\", #>  245 :         std::vector<size_t>{}); #>  246 :       K = std::numeric_limits<int>::min(); #>  247 :       current_statement__ = 63; #>  248 :       K = context__.vals_i(\"K\")[(1 - 1)]; #>  249 :       current_statement__ = 63; #>  250 :       stan::math::check_greater_or_equal(function__, \"K\", K, 2); #>  251 :       current_statement__ = 64; #>  252 :       stan::math::validate_non_negative_index(\"w1\", \"m\", m); #>  253 :       current_statement__ = 65; #>  254 :       w1_2dim__ = std::numeric_limits<int>::min(); #>  255 :       current_statement__ = 65; #>  256 :       w1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  257 :                     stan::model::index_uni(1)); #>  258 :       current_statement__ = 65; #>  259 :       stan::math::validate_non_negative_index(\"w1\", \"nodes[1]\", w1_2dim__); #>  260 :       current_statement__ = 66; #>  261 :       b1_1dim__ = std::numeric_limits<int>::min(); #>  262 :       current_statement__ = 66; #>  263 :       b1_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  264 :                     stan::model::index_uni(1)); #>  265 :       current_statement__ = 66; #>  266 :       stan::math::validate_non_negative_index(\"b1\", \"nodes[1]\", b1_1dim__); #>  267 :       current_statement__ = 67; #>  268 :       w2_1dim__ = std::numeric_limits<int>::min(); #>  269 :       current_statement__ = 67; #>  270 :       w2_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  271 :                     stan::model::index_uni(1)); #>  272 :       current_statement__ = 67; #>  273 :       stan::math::validate_non_negative_index(\"w2\", \"nodes[1]\", w2_1dim__); #>  274 :       current_statement__ = 68; #>  275 :       w2_2dim__ = std::numeric_limits<int>::min(); #>  276 :       current_statement__ = 68; #>  277 :       w2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  278 :                     stan::model::index_uni(2)); #>  279 :       current_statement__ = 68; #>  280 :       stan::math::validate_non_negative_index(\"w2\", \"nodes[2]\", w2_2dim__); #>  281 :       current_statement__ = 69; #>  282 :       b2_1dim__ = std::numeric_limits<int>::min(); #>  283 :       current_statement__ = 69; #>  284 :       b2_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  285 :                     stan::model::index_uni(2)); #>  286 :       current_statement__ = 69; #>  287 :       stan::math::validate_non_negative_index(\"b2\", \"nodes[2]\", b2_1dim__); #>  288 :       current_statement__ = 70; #>  289 :       w3_1dim__ = std::numeric_limits<int>::min(); #>  290 :       current_statement__ = 70; #>  291 :       w3_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  292 :                     stan::model::index_uni(2)); #>  293 :       current_statement__ = 70; #>  294 :       stan::math::validate_non_negative_index(\"w3\", \"nodes[2]\", w3_1dim__); #>  295 :       current_statement__ = 71; #>  296 :       w3_2dim__ = std::numeric_limits<int>::min(); #>  297 :       current_statement__ = 71; #>  298 :       w3_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  299 :                     stan::model::index_uni(3)); #>  300 :       current_statement__ = 71; #>  301 :       stan::math::validate_non_negative_index(\"w3\", \"nodes[3]\", w3_2dim__); #>  302 :       current_statement__ = 72; #>  303 :       b3_1dim__ = std::numeric_limits<int>::min(); #>  304 :       current_statement__ = 72; #>  305 :       b3_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  306 :                     stan::model::index_uni(3)); #>  307 :       current_statement__ = 72; #>  308 :       stan::math::validate_non_negative_index(\"b3\", \"nodes[3]\", b3_1dim__); #>  309 :       current_statement__ = 73; #>  310 :       w_out_1dim__ = std::numeric_limits<int>::min(); #>  311 :       current_statement__ = 73; #>  312 :       w_out_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  313 :                        stan::model::index_uni(L)); #>  314 :       current_statement__ = 73; #>  315 :       stan::math::validate_non_negative_index(\"w_out\", \"nodes[L]\", #>  316 :         w_out_1dim__); #>  317 :       current_statement__ = 74; #>  318 :       stan::math::validate_non_negative_index(\"w_out\", \"K\", K); #>  319 :       current_statement__ = 75; #>  320 :       stan::math::validate_non_negative_index(\"b_out\", \"K\", K); #>  321 :       current_statement__ = 76; #>  322 :       stan::math::validate_non_negative_index(\"z1\", \"n\", n); #>  323 :       current_statement__ = 77; #>  324 :       z1_2dim__ = std::numeric_limits<int>::min(); #>  325 :       current_statement__ = 77; #>  326 :       z1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  327 :                     stan::model::index_uni(1)); #>  328 :       current_statement__ = 77; #>  329 :       stan::math::validate_non_negative_index(\"z1\", \"nodes[1]\", z1_2dim__); #>  330 :       current_statement__ = 78; #>  331 :       stan::math::validate_non_negative_index(\"a1\", \"n\", n); #>  332 :       current_statement__ = 79; #>  333 :       a1_2dim__ = std::numeric_limits<int>::min(); #>  334 :       current_statement__ = 79; #>  335 :       a1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  336 :                     stan::model::index_uni(1)); #>  337 :       current_statement__ = 79; #>  338 :       stan::math::validate_non_negative_index(\"a1\", \"nodes[1]\", a1_2dim__); #>  339 :       current_statement__ = 80; #>  340 :       stan::math::validate_non_negative_index(\"z2\", \"n\", n); #>  341 :       current_statement__ = 81; #>  342 :       z2_2dim__ = std::numeric_limits<int>::min(); #>  343 :       current_statement__ = 81; #>  344 :       z2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  345 :                     stan::model::index_uni(2)); #>  346 :       current_statement__ = 81; #>  347 :       stan::math::validate_non_negative_index(\"z2\", \"nodes[2]\", z2_2dim__); #>  348 :       current_statement__ = 82; #>  349 :       stan::math::validate_non_negative_index(\"a2\", \"n\", n); #>  350 :       current_statement__ = 83; #>  351 :       a2_2dim__ = std::numeric_limits<int>::min(); #>  352 :       current_statement__ = 83; #>  353 :       a2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  354 :                     stan::model::index_uni(2)); #>  355 :       current_statement__ = 83; #>  356 :       stan::math::validate_non_negative_index(\"a2\", \"nodes[2]\", a2_2dim__); #>  357 :       current_statement__ = 84; #>  358 :       stan::math::validate_non_negative_index(\"z3\", \"n\", n); #>  359 :       current_statement__ = 85; #>  360 :       z3_2dim__ = std::numeric_limits<int>::min(); #>  361 :       current_statement__ = 85; #>  362 :       z3_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  363 :                     stan::model::index_uni(3)); #>  364 :       current_statement__ = 85; #>  365 :       stan::math::validate_non_negative_index(\"z3\", \"nodes[3]\", z3_2dim__); #>  366 :       current_statement__ = 86; #>  367 :       stan::math::validate_non_negative_index(\"a3\", \"n\", n); #>  368 :       current_statement__ = 87; #>  369 :       a3_2dim__ = std::numeric_limits<int>::min(); #>  370 :       current_statement__ = 87; #>  371 :       a3_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  372 :                     stan::model::index_uni(3)); #>  373 :       current_statement__ = 87; #>  374 :       stan::math::validate_non_negative_index(\"a3\", \"nodes[3]\", a3_2dim__); #>  375 :       current_statement__ = 88; #>  376 :       stan::math::validate_non_negative_index(\"y_hat\", \"n\", n); #>  377 :       current_statement__ = 89; #>  378 :       stan::math::validate_non_negative_index(\"y_hat\", \"K\", K); #>  379 :     } catch (const std::exception& e) { #>  380 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  381 :     } #>  382 :     num_params_r__ = (m * w1_2dim__) + b1_1dim__ + (w2_1dim__ * w2_2dim__) + #>  383 :       b2_1dim__ + (w3_1dim__ * w3_2dim__) + b3_1dim__ + (w_out_1dim__ * K) + #>  384 :       K; #>  385 :   } #>  386 :   inline std::string model_name() const final { #>  387 :     return \"model1d20eab5182_\"; #>  388 :   } #>  389 :   inline std::vector<std::string> model_compile_info() const noexcept { #>  390 :     return std::vector<std::string>{\"stanc_version = stanc3 v2.32.2\", #>  391 :              \"stancflags = --\"}; #>  392 :   } #>  393 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI, #>  394 :             stan::require_vector_like_t<VecR>* = nullptr, #>  395 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  396 :   inline stan::scalar_type_t<VecR> #>  397 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream* #>  398 :                 pstream__ = nullptr) const { #>  399 :     using T__ = stan::scalar_type_t<VecR>; #>  400 :     using local_scalar_t__ = T__; #>  401 :     T__ lp__(0.0); #>  402 :     stan::math::accumulator<T__> lp_accum__; #>  403 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  404 :     int current_statement__ = 0; #>  405 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  406 :     // suppress unused var warning #>  407 :     (void) DUMMY_VAR__; #>  408 :     static constexpr const char* function__ = #>  409 :       \"model1d20eab5182__namespace::log_prob\"; #>  410 :     // suppress unused var warning #>  411 :     (void) function__; #>  412 :     try { #>  413 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  414 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  415 :           DUMMY_VAR__); #>  416 :       current_statement__ = 1; #>  417 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  418 :              w1_2dim__); #>  419 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  420 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  421 :           DUMMY_VAR__); #>  422 :       current_statement__ = 2; #>  423 :       b1 = in__.template read< #>  424 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__); #>  425 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  426 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  427 :           DUMMY_VAR__); #>  428 :       current_statement__ = 3; #>  429 :       w2 = in__.template read< #>  430 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, w2_2dim__); #>  431 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  432 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  433 :           DUMMY_VAR__); #>  434 :       current_statement__ = 4; #>  435 :       b2 = in__.template read< #>  436 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__); #>  437 :       Eigen::Matrix<local_scalar_t__,-1,-1> w3 = #>  438 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w3_1dim__, w3_2dim__, #>  439 :           DUMMY_VAR__); #>  440 :       current_statement__ = 5; #>  441 :       w3 = in__.template read< #>  442 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w3_1dim__, w3_2dim__); #>  443 :       Eigen::Matrix<local_scalar_t__,-1,1> b3 = #>  444 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b3_1dim__, #>  445 :           DUMMY_VAR__); #>  446 :       current_statement__ = 6; #>  447 :       b3 = in__.template read< #>  448 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b3_1dim__); #>  449 :       Eigen::Matrix<local_scalar_t__,-1,-1> w_out = #>  450 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w_out_1dim__, K, #>  451 :           DUMMY_VAR__); #>  452 :       current_statement__ = 7; #>  453 :       w_out = in__.template read< #>  454 :                 Eigen::Matrix<local_scalar_t__,-1,-1>>(w_out_1dim__, K); #>  455 :       Eigen::Matrix<local_scalar_t__,-1,1> b_out = #>  456 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__); #>  457 :       current_statement__ = 8; #>  458 :       b_out = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K); #>  459 :       Eigen::Matrix<local_scalar_t__,-1,-1> z1 = #>  460 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z1_2dim__, #>  461 :           DUMMY_VAR__); #>  462 :       Eigen::Matrix<local_scalar_t__,-1,-1> a1 = #>  463 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a1_2dim__, #>  464 :           DUMMY_VAR__); #>  465 :       Eigen::Matrix<local_scalar_t__,-1,-1> z2 = #>  466 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z2_2dim__, #>  467 :           DUMMY_VAR__); #>  468 :       Eigen::Matrix<local_scalar_t__,-1,-1> a2 = #>  469 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a2_2dim__, #>  470 :           DUMMY_VAR__); #>  471 :       Eigen::Matrix<local_scalar_t__,-1,-1> z3 = #>  472 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z3_2dim__, #>  473 :           DUMMY_VAR__); #>  474 :       Eigen::Matrix<local_scalar_t__,-1,-1> a3 = #>  475 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a3_2dim__, #>  476 :           DUMMY_VAR__); #>  477 :       Eigen::Matrix<local_scalar_t__,-1,-1> y_hat = #>  478 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, K, DUMMY_VAR__); #>  479 :       current_statement__ = 16; #>  480 :       stan::model::assign(z1, #>  481 :         stan::math::add(stan::math::multiply(X, w1), #>  482 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  483 :         \"assigning variable z1\"); #>  484 :       current_statement__ = 23; #>  485 :       if (stan::math::logical_eq( #>  486 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  487 :             1)) { #>  488 :         current_statement__ = 22; #>  489 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  490 :       } else { #>  491 :         current_statement__ = 21; #>  492 :         if (stan::math::logical_eq( #>  493 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  494 :               2)) { #>  495 :           current_statement__ = 20; #>  496 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  497 :             \"assigning variable a1\"); #>  498 :         } else { #>  499 :           current_statement__ = 19; #>  500 :           if (stan::math::logical_eq( #>  501 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  502 :                   stan::model::index_uni(1)), 3)) { #>  503 :             current_statement__ = 18; #>  504 :             stan::model::assign(a1, #>  505 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  506 :               \"assigning variable a1\"); #>  507 :           } else { #>  508 :             current_statement__ = 17; #>  509 :             stan::model::assign(a1, #>  510 :               stan::math::fmax( #>  511 :                 stan::math::rep_matrix(0, n, #>  512 :                   stan::model::rvalue(nodes, \"nodes\", #>  513 :                     stan::model::index_uni(1))), z1), \"assigning variable a1\"); #>  514 :           } #>  515 :         } #>  516 :       } #>  517 :       current_statement__ = 24; #>  518 :       stan::model::assign(z2, #>  519 :         stan::math::add(stan::math::multiply(a1, w2), #>  520 :           stan::math::rep_matrix(stan::math::transpose(b2), n)), #>  521 :         \"assigning variable z2\"); #>  522 :       current_statement__ = 31; #>  523 :       if (stan::math::logical_eq( #>  524 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  525 :             1)) { #>  526 :         current_statement__ = 30; #>  527 :         stan::model::assign(a2, stan::math::tanh(z2), \"assigning variable a2\"); #>  528 :       } else { #>  529 :         current_statement__ = 29; #>  530 :         if (stan::math::logical_eq( #>  531 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  532 :               2)) { #>  533 :           current_statement__ = 28; #>  534 :           stan::model::assign(a2, stan::math::inv_logit(z2), #>  535 :             \"assigning variable a2\"); #>  536 :         } else { #>  537 :           current_statement__ = 27; #>  538 :           if (stan::math::logical_eq( #>  539 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  540 :                   stan::model::index_uni(2)), 3)) { #>  541 :             current_statement__ = 26; #>  542 :             stan::model::assign(a2, #>  543 :               stan::math::log(stan::math::add(1, stan::math::exp(z2))), #>  544 :               \"assigning variable a2\"); #>  545 :           } else { #>  546 :             current_statement__ = 25; #>  547 :             stan::model::assign(a2, #>  548 :               stan::math::fmax( #>  549 :                 stan::math::rep_matrix(0, n, #>  550 :                   stan::model::rvalue(nodes, \"nodes\", #>  551 :                     stan::model::index_uni(2))), z2), \"assigning variable a2\"); #>  552 :           } #>  553 :         } #>  554 :       } #>  555 :       current_statement__ = 32; #>  556 :       stan::model::assign(z3, #>  557 :         stan::math::add(stan::math::multiply(a2, w3), #>  558 :           stan::math::rep_matrix(stan::math::transpose(b3), n)), #>  559 :         \"assigning variable z3\"); #>  560 :       current_statement__ = 39; #>  561 :       if (stan::math::logical_eq( #>  562 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(3)), #>  563 :             1)) { #>  564 :         current_statement__ = 38; #>  565 :         stan::model::assign(a3, stan::math::tanh(z3), \"assigning variable a3\"); #>  566 :       } else { #>  567 :         current_statement__ = 37; #>  568 :         if (stan::math::logical_eq( #>  569 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(3)), #>  570 :               2)) { #>  571 :           current_statement__ = 36; #>  572 :           stan::model::assign(a3, stan::math::inv_logit(z3), #>  573 :             \"assigning variable a3\"); #>  574 :         } else { #>  575 :           current_statement__ = 35; #>  576 :           if (stan::math::logical_eq( #>  577 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  578 :                   stan::model::index_uni(3)), 3)) { #>  579 :             current_statement__ = 34; #>  580 :             stan::model::assign(a3, #>  581 :               stan::math::log(stan::math::add(1, stan::math::exp(z3))), #>  582 :               \"assigning variable a3\"); #>  583 :           } else { #>  584 :             current_statement__ = 33; #>  585 :             stan::model::assign(a3, #>  586 :               stan::math::fmax( #>  587 :                 stan::math::rep_matrix(0, n, #>  588 :                   stan::model::rvalue(nodes, \"nodes\", #>  589 :                     stan::model::index_uni(3))), z3), \"assigning variable a3\"); #>  590 :           } #>  591 :         } #>  592 :       } #>  593 :       current_statement__ = 40; #>  594 :       stan::model::assign(y_hat, #>  595 :         stan::math::add(stan::math::multiply(a3, w_out), #>  596 :           stan::math::rep_matrix(stan::math::transpose(b_out), n)), #>  597 :         \"assigning variable y_hat\"); #>  598 :       { #>  599 :         current_statement__ = 41; #>  600 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  601 :                          stan::math::to_vector(w1), 0, 1)); #>  602 :         current_statement__ = 42; #>  603 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b1, 0, 1)); #>  604 :         current_statement__ = 43; #>  605 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  606 :                          stan::math::to_vector(w2), 0, 1)); #>  607 :         current_statement__ = 44; #>  608 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b2, 0, 1)); #>  609 :         current_statement__ = 45; #>  610 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  611 :                          stan::math::to_vector(w3), 0, 1)); #>  612 :         current_statement__ = 46; #>  613 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b3, 0, 1)); #>  614 :         current_statement__ = 47; #>  615 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  616 :                          stan::math::to_vector(w_out), 0, 1)); #>  617 :         current_statement__ = 48; #>  618 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b_out, 0, 1)); #>  619 :         current_statement__ = 50; #>  620 :         for (int i = 1; i <= n; ++i) { #>  621 :           current_statement__ = 49; #>  622 :           lp_accum__.add(stan::math::categorical_logit_lpmf<propto__>( #>  623 :                            stan::model::rvalue(y, \"y\", #>  624 :                              stan::model::index_uni(i)), #>  625 :                            stan::math::transpose( #>  626 :                              stan::model::rvalue(y_hat, \"y_hat\", #>  627 :                                stan::model::index_uni(i))))); #>  628 :         } #>  629 :       } #>  630 :     } catch (const std::exception& e) { #>  631 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  632 :     } #>  633 :     lp_accum__.add(lp__); #>  634 :     return lp_accum__.sum(); #>  635 :   } #>  636 :   template <typename RNG, typename VecR, typename VecI, typename VecVar, #>  637 :             stan::require_vector_like_vt<std::is_floating_point, #>  638 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, #>  639 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point, #>  640 :             VecVar>* = nullptr> #>  641 :   inline void #>  642 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__, #>  643 :                    VecVar& vars__, const bool #>  644 :                    emit_transformed_parameters__ = true, const bool #>  645 :                    emit_generated_quantities__ = true, std::ostream* #>  646 :                    pstream__ = nullptr) const { #>  647 :     using local_scalar_t__ = double; #>  648 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  649 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  650 :     static constexpr bool propto__ = true; #>  651 :     // suppress unused var warning #>  652 :     (void) propto__; #>  653 :     double lp__ = 0.0; #>  654 :     // suppress unused var warning #>  655 :     (void) lp__; #>  656 :     int current_statement__ = 0; #>  657 :     stan::math::accumulator<double> lp_accum__; #>  658 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  659 :     // suppress unused var warning #>  660 :     (void) DUMMY_VAR__; #>  661 :     constexpr bool jacobian__ = false; #>  662 :     static constexpr const char* function__ = #>  663 :       \"model1d20eab5182__namespace::write_array\"; #>  664 :     // suppress unused var warning #>  665 :     (void) function__; #>  666 :     try { #>  667 :       Eigen::Matrix<double,-1,-1> w1 = #>  668 :         Eigen::Matrix<double,-1,-1>::Constant(m, w1_2dim__, #>  669 :           std::numeric_limits<double>::quiet_NaN()); #>  670 :       current_statement__ = 1; #>  671 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  672 :              w1_2dim__); #>  673 :       Eigen::Matrix<double,-1,1> b1 = #>  674 :         Eigen::Matrix<double,-1,1>::Constant(b1_1dim__, #>  675 :           std::numeric_limits<double>::quiet_NaN()); #>  676 :       current_statement__ = 2; #>  677 :       b1 = in__.template read< #>  678 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__); #>  679 :       Eigen::Matrix<double,-1,-1> w2 = #>  680 :         Eigen::Matrix<double,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  681 :           std::numeric_limits<double>::quiet_NaN()); #>  682 :       current_statement__ = 3; #>  683 :       w2 = in__.template read< #>  684 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, w2_2dim__); #>  685 :       Eigen::Matrix<double,-1,1> b2 = #>  686 :         Eigen::Matrix<double,-1,1>::Constant(b2_1dim__, #>  687 :           std::numeric_limits<double>::quiet_NaN()); #>  688 :       current_statement__ = 4; #>  689 :       b2 = in__.template read< #>  690 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__); #>  691 :       Eigen::Matrix<double,-1,-1> w3 = #>  692 :         Eigen::Matrix<double,-1,-1>::Constant(w3_1dim__, w3_2dim__, #>  693 :           std::numeric_limits<double>::quiet_NaN()); #>  694 :       current_statement__ = 5; #>  695 :       w3 = in__.template read< #>  696 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w3_1dim__, w3_2dim__); #>  697 :       Eigen::Matrix<double,-1,1> b3 = #>  698 :         Eigen::Matrix<double,-1,1>::Constant(b3_1dim__, #>  699 :           std::numeric_limits<double>::quiet_NaN()); #>  700 :       current_statement__ = 6; #>  701 :       b3 = in__.template read< #>  702 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b3_1dim__); #>  703 :       Eigen::Matrix<double,-1,-1> w_out = #>  704 :         Eigen::Matrix<double,-1,-1>::Constant(w_out_1dim__, K, #>  705 :           std::numeric_limits<double>::quiet_NaN()); #>  706 :       current_statement__ = 7; #>  707 :       w_out = in__.template read< #>  708 :                 Eigen::Matrix<local_scalar_t__,-1,-1>>(w_out_1dim__, K); #>  709 :       Eigen::Matrix<double,-1,1> b_out = #>  710 :         Eigen::Matrix<double,-1,1>::Constant(K, #>  711 :           std::numeric_limits<double>::quiet_NaN()); #>  712 :       current_statement__ = 8; #>  713 :       b_out = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K); #>  714 :       Eigen::Matrix<double,-1,-1> z1 = #>  715 :         Eigen::Matrix<double,-1,-1>::Constant(n, z1_2dim__, #>  716 :           std::numeric_limits<double>::quiet_NaN()); #>  717 :       Eigen::Matrix<double,-1,-1> a1 = #>  718 :         Eigen::Matrix<double,-1,-1>::Constant(n, a1_2dim__, #>  719 :           std::numeric_limits<double>::quiet_NaN()); #>  720 :       Eigen::Matrix<double,-1,-1> z2 = #>  721 :         Eigen::Matrix<double,-1,-1>::Constant(n, z2_2dim__, #>  722 :           std::numeric_limits<double>::quiet_NaN()); #>  723 :       Eigen::Matrix<double,-1,-1> a2 = #>  724 :         Eigen::Matrix<double,-1,-1>::Constant(n, a2_2dim__, #>  725 :           std::numeric_limits<double>::quiet_NaN()); #>  726 :       Eigen::Matrix<double,-1,-1> z3 = #>  727 :         Eigen::Matrix<double,-1,-1>::Constant(n, z3_2dim__, #>  728 :           std::numeric_limits<double>::quiet_NaN()); #>  729 :       Eigen::Matrix<double,-1,-1> a3 = #>  730 :         Eigen::Matrix<double,-1,-1>::Constant(n, a3_2dim__, #>  731 :           std::numeric_limits<double>::quiet_NaN()); #>  732 :       Eigen::Matrix<double,-1,-1> y_hat = #>  733 :         Eigen::Matrix<double,-1,-1>::Constant(n, K, #>  734 :           std::numeric_limits<double>::quiet_NaN()); #>  735 :       out__.write(w1); #>  736 :       out__.write(b1); #>  737 :       out__.write(w2); #>  738 :       out__.write(b2); #>  739 :       out__.write(w3); #>  740 :       out__.write(b3); #>  741 :       out__.write(w_out); #>  742 :       out__.write(b_out); #>  743 :       if (stan::math::logical_negation( #>  744 :             (stan::math::primitive_value(emit_transformed_parameters__) || #>  745 :             stan::math::primitive_value(emit_generated_quantities__)))) { #>  746 :         return ; #>  747 :       } #>  748 :       current_statement__ = 16; #>  749 :       stan::model::assign(z1, #>  750 :         stan::math::add(stan::math::multiply(X, w1), #>  751 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  752 :         \"assigning variable z1\"); #>  753 :       current_statement__ = 23; #>  754 :       if (stan::math::logical_eq( #>  755 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  756 :             1)) { #>  757 :         current_statement__ = 22; #>  758 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  759 :       } else { #>  760 :         current_statement__ = 21; #>  761 :         if (stan::math::logical_eq( #>  762 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  763 :               2)) { #>  764 :           current_statement__ = 20; #>  765 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  766 :             \"assigning variable a1\"); #>  767 :         } else { #>  768 :           current_statement__ = 19; #>  769 :           if (stan::math::logical_eq( #>  770 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  771 :                   stan::model::index_uni(1)), 3)) { #>  772 :             current_statement__ = 18; #>  773 :             stan::model::assign(a1, #>  774 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  775 :               \"assigning variable a1\"); #>  776 :           } else { #>  777 :             current_statement__ = 17; #>  778 :             stan::model::assign(a1, #>  779 :               stan::math::fmax( #>  780 :                 stan::math::rep_matrix(0, n, #>  781 :                   stan::model::rvalue(nodes, \"nodes\", #>  782 :                     stan::model::index_uni(1))), z1), \"assigning variable a1\"); #>  783 :           } #>  784 :         } #>  785 :       } #>  786 :       current_statement__ = 24; #>  787 :       stan::model::assign(z2, #>  788 :         stan::math::add(stan::math::multiply(a1, w2), #>  789 :           stan::math::rep_matrix(stan::math::transpose(b2), n)), #>  790 :         \"assigning variable z2\"); #>  791 :       current_statement__ = 31; #>  792 :       if (stan::math::logical_eq( #>  793 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  794 :             1)) { #>  795 :         current_statement__ = 30; #>  796 :         stan::model::assign(a2, stan::math::tanh(z2), \"assigning variable a2\"); #>  797 :       } else { #>  798 :         current_statement__ = 29; #>  799 :         if (stan::math::logical_eq( #>  800 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  801 :               2)) { #>  802 :           current_statement__ = 28; #>  803 :           stan::model::assign(a2, stan::math::inv_logit(z2), #>  804 :             \"assigning variable a2\"); #>  805 :         } else { #>  806 :           current_statement__ = 27; #>  807 :           if (stan::math::logical_eq( #>  808 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  809 :                   stan::model::index_uni(2)), 3)) { #>  810 :             current_statement__ = 26; #>  811 :             stan::model::assign(a2, #>  812 :               stan::math::log(stan::math::add(1, stan::math::exp(z2))), #>  813 :               \"assigning variable a2\"); #>  814 :           } else { #>  815 :             current_statement__ = 25; #>  816 :             stan::model::assign(a2, #>  817 :               stan::math::fmax( #>  818 :                 stan::math::rep_matrix(0, n, #>  819 :                   stan::model::rvalue(nodes, \"nodes\", #>  820 :                     stan::model::index_uni(2))), z2), \"assigning variable a2\"); #>  821 :           } #>  822 :         } #>  823 :       } #>  824 :       current_statement__ = 32; #>  825 :       stan::model::assign(z3, #>  826 :         stan::math::add(stan::math::multiply(a2, w3), #>  827 :           stan::math::rep_matrix(stan::math::transpose(b3), n)), #>  828 :         \"assigning variable z3\"); #>  829 :       current_statement__ = 39; #>  830 :       if (stan::math::logical_eq( #>  831 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(3)), #>  832 :             1)) { #>  833 :         current_statement__ = 38; #>  834 :         stan::model::assign(a3, stan::math::tanh(z3), \"assigning variable a3\"); #>  835 :       } else { #>  836 :         current_statement__ = 37; #>  837 :         if (stan::math::logical_eq( #>  838 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(3)), #>  839 :               2)) { #>  840 :           current_statement__ = 36; #>  841 :           stan::model::assign(a3, stan::math::inv_logit(z3), #>  842 :             \"assigning variable a3\"); #>  843 :         } else { #>  844 :           current_statement__ = 35; #>  845 :           if (stan::math::logical_eq( #>  846 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  847 :                   stan::model::index_uni(3)), 3)) { #>  848 :             current_statement__ = 34; #>  849 :             stan::model::assign(a3, #>  850 :               stan::math::log(stan::math::add(1, stan::math::exp(z3))), #>  851 :               \"assigning variable a3\"); #>  852 :           } else { #>  853 :             current_statement__ = 33; #>  854 :             stan::model::assign(a3, #>  855 :               stan::math::fmax( #>  856 :                 stan::math::rep_matrix(0, n, #>  857 :                   stan::model::rvalue(nodes, \"nodes\", #>  858 :                     stan::model::index_uni(3))), z3), \"assigning variable a3\"); #>  859 :           } #>  860 :         } #>  861 :       } #>  862 :       current_statement__ = 40; #>  863 :       stan::model::assign(y_hat, #>  864 :         stan::math::add(stan::math::multiply(a3, w_out), #>  865 :           stan::math::rep_matrix(stan::math::transpose(b_out), n)), #>  866 :         \"assigning variable y_hat\"); #>  867 :       if (emit_transformed_parameters__) { #>  868 :         out__.write(z1); #>  869 :         out__.write(a1); #>  870 :         out__.write(z2); #>  871 :         out__.write(a2); #>  872 :         out__.write(z3); #>  873 :         out__.write(a3); #>  874 :         out__.write(y_hat); #>  875 :       } #>  876 :       if (stan::math::logical_negation(emit_generated_quantities__)) { #>  877 :         return ; #>  878 :       } #>  879 :     } catch (const std::exception& e) { #>  880 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  881 :     } #>  882 :   } #>  883 :   template <typename VecVar, typename VecI, #>  884 :             stan::require_vector_t<VecVar>* = nullptr, #>  885 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  886 :   inline void #>  887 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__, #>  888 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const { #>  889 :     using local_scalar_t__ = double; #>  890 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  891 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  892 :     int current_statement__ = 0; #>  893 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  894 :     // suppress unused var warning #>  895 :     (void) DUMMY_VAR__; #>  896 :     try { #>  897 :       int pos__ = std::numeric_limits<int>::min(); #>  898 :       pos__ = 1; #>  899 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  900 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  901 :           DUMMY_VAR__); #>  902 :       current_statement__ = 1; #>  903 :       stan::model::assign(w1, #>  904 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, w1_2dim__), #>  905 :         \"assigning variable w1\"); #>  906 :       out__.write(w1); #>  907 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  908 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  909 :           DUMMY_VAR__); #>  910 :       current_statement__ = 2; #>  911 :       stan::model::assign(b1, #>  912 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__), #>  913 :         \"assigning variable b1\"); #>  914 :       out__.write(b1); #>  915 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  916 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  917 :           DUMMY_VAR__); #>  918 :       current_statement__ = 3; #>  919 :       stan::model::assign(w2, #>  920 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, #>  921 :           w2_2dim__), \"assigning variable w2\"); #>  922 :       out__.write(w2); #>  923 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  924 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  925 :           DUMMY_VAR__); #>  926 :       current_statement__ = 4; #>  927 :       stan::model::assign(b2, #>  928 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__), #>  929 :         \"assigning variable b2\"); #>  930 :       out__.write(b2); #>  931 :       Eigen::Matrix<local_scalar_t__,-1,-1> w3 = #>  932 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w3_1dim__, w3_2dim__, #>  933 :           DUMMY_VAR__); #>  934 :       current_statement__ = 5; #>  935 :       stan::model::assign(w3, #>  936 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(w3_1dim__, #>  937 :           w3_2dim__), \"assigning variable w3\"); #>  938 :       out__.write(w3); #>  939 :       Eigen::Matrix<local_scalar_t__,-1,1> b3 = #>  940 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b3_1dim__, #>  941 :           DUMMY_VAR__); #>  942 :       current_statement__ = 6; #>  943 :       stan::model::assign(b3, #>  944 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b3_1dim__), #>  945 :         \"assigning variable b3\"); #>  946 :       out__.write(b3); #>  947 :       Eigen::Matrix<local_scalar_t__,-1,-1> w_out = #>  948 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w_out_1dim__, K, #>  949 :           DUMMY_VAR__); #>  950 :       current_statement__ = 7; #>  951 :       stan::model::assign(w_out, #>  952 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(w_out_1dim__, K), #>  953 :         \"assigning variable w_out\"); #>  954 :       out__.write(w_out); #>  955 :       Eigen::Matrix<local_scalar_t__,-1,1> b_out = #>  956 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__); #>  957 :       current_statement__ = 8; #>  958 :       stan::model::assign(b_out, #>  959 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K), #>  960 :         \"assigning variable b_out\"); #>  961 :       out__.write(b_out); #>  962 :     } catch (const std::exception& e) { #>  963 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  964 :     } #>  965 :   } #>  966 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr> #>  967 :   inline void #>  968 :   transform_inits_impl(const stan::io::var_context& context__, VecVar& #>  969 :                        vars__, std::ostream* pstream__ = nullptr) const { #>  970 :     using local_scalar_t__ = double; #>  971 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  972 :     int current_statement__ = 0; #>  973 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  974 :     // suppress unused var warning #>  975 :     (void) DUMMY_VAR__; #>  976 :     try { #>  977 :       current_statement__ = 1; #>  978 :       context__.validate_dims(\"parameter initialization\", \"w1\", \"double\", #>  979 :         std::vector<size_t>{static_cast<size_t>(m), #>  980 :           static_cast<size_t>(w1_2dim__)}); #>  981 :       current_statement__ = 2; #>  982 :       context__.validate_dims(\"parameter initialization\", \"b1\", \"double\", #>  983 :         std::vector<size_t>{static_cast<size_t>(b1_1dim__)}); #>  984 :       current_statement__ = 3; #>  985 :       context__.validate_dims(\"parameter initialization\", \"w2\", \"double\", #>  986 :         std::vector<size_t>{static_cast<size_t>(w2_1dim__), #>  987 :           static_cast<size_t>(w2_2dim__)}); #>  988 :       current_statement__ = 4; #>  989 :       context__.validate_dims(\"parameter initialization\", \"b2\", \"double\", #>  990 :         std::vector<size_t>{static_cast<size_t>(b2_1dim__)}); #>  991 :       current_statement__ = 5; #>  992 :       context__.validate_dims(\"parameter initialization\", \"w3\", \"double\", #>  993 :         std::vector<size_t>{static_cast<size_t>(w3_1dim__), #>  994 :           static_cast<size_t>(w3_2dim__)}); #>  995 :       current_statement__ = 6; #>  996 :       context__.validate_dims(\"parameter initialization\", \"b3\", \"double\", #>  997 :         std::vector<size_t>{static_cast<size_t>(b3_1dim__)}); #>  998 :       current_statement__ = 7; #>  999 :       context__.validate_dims(\"parameter initialization\", \"w_out\", \"double\", #> 1000 :         std::vector<size_t>{static_cast<size_t>(w_out_1dim__), #> 1001 :           static_cast<size_t>(K)}); #> 1002 :       current_statement__ = 8; #> 1003 :       context__.validate_dims(\"parameter initialization\", \"b_out\", \"double\", #> 1004 :         std::vector<size_t>{static_cast<size_t>(K)}); #> 1005 :       int pos__ = std::numeric_limits<int>::min(); #> 1006 :       pos__ = 1; #> 1007 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #> 1008 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #> 1009 :           DUMMY_VAR__); #> 1010 :       { #> 1011 :         std::vector<local_scalar_t__> w1_flat__; #> 1012 :         current_statement__ = 1; #> 1013 :         w1_flat__ = context__.vals_r(\"w1\"); #> 1014 :         current_statement__ = 1; #> 1015 :         pos__ = 1; #> 1016 :         current_statement__ = 1; #> 1017 :         for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #> 1018 :           current_statement__ = 1; #> 1019 :           for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #> 1020 :             current_statement__ = 1; #> 1021 :             stan::model::assign(w1, w1_flat__[(pos__ - 1)], #> 1022 :               \"assigning variable w1\", stan::model::index_uni(sym2__), #> 1023 :               stan::model::index_uni(sym1__)); #> 1024 :             current_statement__ = 1; #> 1025 :             pos__ = (pos__ + 1); #> 1026 :           } #> 1027 :         } #> 1028 :       } #> 1029 :       out__.write(w1); #> 1030 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #> 1031 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #> 1032 :           DUMMY_VAR__); #> 1033 :       { #> 1034 :         std::vector<local_scalar_t__> b1_flat__; #> 1035 :         current_statement__ = 2; #> 1036 :         b1_flat__ = context__.vals_r(\"b1\"); #> 1037 :         current_statement__ = 2; #> 1038 :         pos__ = 1; #> 1039 :         current_statement__ = 2; #> 1040 :         for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #> 1041 :           current_statement__ = 2; #> 1042 :           stan::model::assign(b1, b1_flat__[(pos__ - 1)], #> 1043 :             \"assigning variable b1\", stan::model::index_uni(sym1__)); #> 1044 :           current_statement__ = 2; #> 1045 :           pos__ = (pos__ + 1); #> 1046 :         } #> 1047 :       } #> 1048 :       out__.write(b1); #> 1049 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #> 1050 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #> 1051 :           DUMMY_VAR__); #> 1052 :       { #> 1053 :         std::vector<local_scalar_t__> w2_flat__; #> 1054 :         current_statement__ = 3; #> 1055 :         w2_flat__ = context__.vals_r(\"w2\"); #> 1056 :         current_statement__ = 3; #> 1057 :         pos__ = 1; #> 1058 :         current_statement__ = 3; #> 1059 :         for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #> 1060 :           current_statement__ = 3; #> 1061 :           for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #> 1062 :             current_statement__ = 3; #> 1063 :             stan::model::assign(w2, w2_flat__[(pos__ - 1)], #> 1064 :               \"assigning variable w2\", stan::model::index_uni(sym2__), #> 1065 :               stan::model::index_uni(sym1__)); #> 1066 :             current_statement__ = 3; #> 1067 :             pos__ = (pos__ + 1); #> 1068 :           } #> 1069 :         } #> 1070 :       } #> 1071 :       out__.write(w2); #> 1072 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #> 1073 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #> 1074 :           DUMMY_VAR__); #> 1075 :       { #> 1076 :         std::vector<local_scalar_t__> b2_flat__; #> 1077 :         current_statement__ = 4; #> 1078 :         b2_flat__ = context__.vals_r(\"b2\"); #> 1079 :         current_statement__ = 4; #> 1080 :         pos__ = 1; #> 1081 :         current_statement__ = 4; #> 1082 :         for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #> 1083 :           current_statement__ = 4; #> 1084 :           stan::model::assign(b2, b2_flat__[(pos__ - 1)], #> 1085 :             \"assigning variable b2\", stan::model::index_uni(sym1__)); #> 1086 :           current_statement__ = 4; #> 1087 :           pos__ = (pos__ + 1); #> 1088 :         } #> 1089 :       } #> 1090 :       out__.write(b2); #> 1091 :       Eigen::Matrix<local_scalar_t__,-1,-1> w3 = #> 1092 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w3_1dim__, w3_2dim__, #> 1093 :           DUMMY_VAR__); #> 1094 :       { #> 1095 :         std::vector<local_scalar_t__> w3_flat__; #> 1096 :         current_statement__ = 5; #> 1097 :         w3_flat__ = context__.vals_r(\"w3\"); #> 1098 :         current_statement__ = 5; #> 1099 :         pos__ = 1; #> 1100 :         current_statement__ = 5; #> 1101 :         for (int sym1__ = 1; sym1__ <= w3_2dim__; ++sym1__) { #> 1102 :           current_statement__ = 5; #> 1103 :           for (int sym2__ = 1; sym2__ <= w3_1dim__; ++sym2__) { #> 1104 :             current_statement__ = 5; #> 1105 :             stan::model::assign(w3, w3_flat__[(pos__ - 1)], #> 1106 :               \"assigning variable w3\", stan::model::index_uni(sym2__), #> 1107 :               stan::model::index_uni(sym1__)); #> 1108 :             current_statement__ = 5; #> 1109 :             pos__ = (pos__ + 1); #> 1110 :           } #> 1111 :         } #> 1112 :       } #> 1113 :       out__.write(w3); #> 1114 :       Eigen::Matrix<local_scalar_t__,-1,1> b3 = #> 1115 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b3_1dim__, #> 1116 :           DUMMY_VAR__); #> 1117 :       { #> 1118 :         std::vector<local_scalar_t__> b3_flat__; #> 1119 :         current_statement__ = 6; #> 1120 :         b3_flat__ = context__.vals_r(\"b3\"); #> 1121 :         current_statement__ = 6; #> 1122 :         pos__ = 1; #> 1123 :         current_statement__ = 6; #> 1124 :         for (int sym1__ = 1; sym1__ <= b3_1dim__; ++sym1__) { #> 1125 :           current_statement__ = 6; #> 1126 :           stan::model::assign(b3, b3_flat__[(pos__ - 1)], #> 1127 :             \"assigning variable b3\", stan::model::index_uni(sym1__)); #> 1128 :           current_statement__ = 6; #> 1129 :           pos__ = (pos__ + 1); #> 1130 :         } #> 1131 :       } #> 1132 :       out__.write(b3); #> 1133 :       Eigen::Matrix<local_scalar_t__,-1,-1> w_out = #> 1134 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w_out_1dim__, K, #> 1135 :           DUMMY_VAR__); #> 1136 :       { #> 1137 :         std::vector<local_scalar_t__> w_out_flat__; #> 1138 :         current_statement__ = 7; #> 1139 :         w_out_flat__ = context__.vals_r(\"w_out\"); #> 1140 :         current_statement__ = 7; #> 1141 :         pos__ = 1; #> 1142 :         current_statement__ = 7; #> 1143 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) { #> 1144 :           current_statement__ = 7; #> 1145 :           for (int sym2__ = 1; sym2__ <= w_out_1dim__; ++sym2__) { #> 1146 :             current_statement__ = 7; #> 1147 :             stan::model::assign(w_out, w_out_flat__[(pos__ - 1)], #> 1148 :               \"assigning variable w_out\", stan::model::index_uni(sym2__), #> 1149 :               stan::model::index_uni(sym1__)); #> 1150 :             current_statement__ = 7; #> 1151 :             pos__ = (pos__ + 1); #> 1152 :           } #> 1153 :         } #> 1154 :       } #> 1155 :       out__.write(w_out); #> 1156 :       Eigen::Matrix<local_scalar_t__,-1,1> b_out = #> 1157 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__); #> 1158 :       { #> 1159 :         std::vector<local_scalar_t__> b_out_flat__; #> 1160 :         current_statement__ = 8; #> 1161 :         b_out_flat__ = context__.vals_r(\"b_out\"); #> 1162 :         current_statement__ = 8; #> 1163 :         pos__ = 1; #> 1164 :         current_statement__ = 8; #> 1165 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) { #> 1166 :           current_statement__ = 8; #> 1167 :           stan::model::assign(b_out, b_out_flat__[(pos__ - 1)], #> 1168 :             \"assigning variable b_out\", stan::model::index_uni(sym1__)); #> 1169 :           current_statement__ = 8; #> 1170 :           pos__ = (pos__ + 1); #> 1171 :         } #> 1172 :       } #> 1173 :       out__.write(b_out); #> 1174 :     } catch (const std::exception& e) { #> 1175 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #> 1176 :     } #> 1177 :   } #> 1178 :   inline void #> 1179 :   get_param_names(std::vector<std::string>& names__, const bool #> 1180 :                   emit_transformed_parameters__ = true, const bool #> 1181 :                   emit_generated_quantities__ = true) const { #> 1182 :     names__ = std::vector<std::string>{\"w1\", \"b1\", \"w2\", \"b2\", \"w3\", \"b3\", #> 1183 :                 \"w_out\", \"b_out\"}; #> 1184 :     if (emit_transformed_parameters__) { #> 1185 :       std::vector<std::string> #> 1186 :         temp{\"z1\", \"a1\", \"z2\", \"a2\", \"z3\", \"a3\", \"y_hat\"}; #> 1187 :       names__.reserve(names__.size() + temp.size()); #> 1188 :       names__.insert(names__.end(), temp.begin(), temp.end()); #> 1189 :     } #> 1190 :     if (emit_generated_quantities__) {} #> 1191 :   } #> 1192 :   inline void #> 1193 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool #> 1194 :            emit_transformed_parameters__ = true, const bool #> 1195 :            emit_generated_quantities__ = true) const { #> 1196 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast< #> 1197 :                                                                     size_t>(m), #> 1198 :                                                  static_cast<size_t>( #> 1199 :                                                    w1_2dim__)}, #> 1200 :                 std::vector<size_t>{static_cast<size_t>(b1_1dim__)}, #> 1201 :                 std::vector<size_t>{static_cast<size_t>(w2_1dim__), #> 1202 :                   static_cast<size_t>(w2_2dim__)}, #> 1203 :                 std::vector<size_t>{static_cast<size_t>(b2_1dim__)}, #> 1204 :                 std::vector<size_t>{static_cast<size_t>(w3_1dim__), #> 1205 :                   static_cast<size_t>(w3_2dim__)}, #> 1206 :                 std::vector<size_t>{static_cast<size_t>(b3_1dim__)}, #> 1207 :                 std::vector<size_t>{static_cast<size_t>(w_out_1dim__), #> 1208 :                   static_cast<size_t>(K)}, #> 1209 :                 std::vector<size_t>{static_cast<size_t>(K)}}; #> 1210 :     if (emit_transformed_parameters__) { #> 1211 :       std::vector<std::vector<size_t>> #> 1212 :         temp{std::vector<size_t>{static_cast<size_t>(n), #> 1213 :                static_cast<size_t>(z1_2dim__)}, #> 1214 :              std::vector<size_t>{static_cast<size_t>(n), #> 1215 :                static_cast<size_t>(a1_2dim__)}, #> 1216 :              std::vector<size_t>{static_cast<size_t>(n), #> 1217 :                static_cast<size_t>(z2_2dim__)}, #> 1218 :              std::vector<size_t>{static_cast<size_t>(n), #> 1219 :                static_cast<size_t>(a2_2dim__)}, #> 1220 :              std::vector<size_t>{static_cast<size_t>(n), #> 1221 :                static_cast<size_t>(z3_2dim__)}, #> 1222 :              std::vector<size_t>{static_cast<size_t>(n), #> 1223 :                static_cast<size_t>(a3_2dim__)}, #> 1224 :              std::vector<size_t>{static_cast<size_t>(n), #> 1225 :                static_cast<size_t>(K)}}; #> 1226 :       dimss__.reserve(dimss__.size() + temp.size()); #> 1227 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end()); #> 1228 :     } #> 1229 :     if (emit_generated_quantities__) {} #> 1230 :   } #> 1231 :   inline void #> 1232 :   constrained_param_names(std::vector<std::string>& param_names__, bool #> 1233 :                           emit_transformed_parameters__ = true, bool #> 1234 :                           emit_generated_quantities__ = true) const final { #> 1235 :     for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #> 1236 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #> 1237 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #> 1238 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1239 :       } #> 1240 :     } #> 1241 :     for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #> 1242 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #> 1243 :         std::to_string(sym1__)); #> 1244 :     } #> 1245 :     for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #> 1246 :       for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #> 1247 :         param_names__.emplace_back(std::string() + \"w2\" + '.' + #> 1248 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1249 :       } #> 1250 :     } #> 1251 :     for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #> 1252 :       param_names__.emplace_back(std::string() + \"b2\" + '.' + #> 1253 :         std::to_string(sym1__)); #> 1254 :     } #> 1255 :     for (int sym1__ = 1; sym1__ <= w3_2dim__; ++sym1__) { #> 1256 :       for (int sym2__ = 1; sym2__ <= w3_1dim__; ++sym2__) { #> 1257 :         param_names__.emplace_back(std::string() + \"w3\" + '.' + #> 1258 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1259 :       } #> 1260 :     } #> 1261 :     for (int sym1__ = 1; sym1__ <= b3_1dim__; ++sym1__) { #> 1262 :       param_names__.emplace_back(std::string() + \"b3\" + '.' + #> 1263 :         std::to_string(sym1__)); #> 1264 :     } #> 1265 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) { #> 1266 :       for (int sym2__ = 1; sym2__ <= w_out_1dim__; ++sym2__) { #> 1267 :         param_names__.emplace_back(std::string() + \"w_out\" + '.' + #> 1268 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1269 :       } #> 1270 :     } #> 1271 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) { #> 1272 :       param_names__.emplace_back(std::string() + \"b_out\" + '.' + #> 1273 :         std::to_string(sym1__)); #> 1274 :     } #> 1275 :     if (emit_transformed_parameters__) { #> 1276 :       for (int sym1__ = 1; sym1__ <= z1_2dim__; ++sym1__) { #> 1277 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1278 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #> 1279 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1280 :         } #> 1281 :       } #> 1282 :       for (int sym1__ = 1; sym1__ <= a1_2dim__; ++sym1__) { #> 1283 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1284 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #> 1285 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1286 :         } #> 1287 :       } #> 1288 :       for (int sym1__ = 1; sym1__ <= z2_2dim__; ++sym1__) { #> 1289 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1290 :           param_names__.emplace_back(std::string() + \"z2\" + '.' + #> 1291 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1292 :         } #> 1293 :       } #> 1294 :       for (int sym1__ = 1; sym1__ <= a2_2dim__; ++sym1__) { #> 1295 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1296 :           param_names__.emplace_back(std::string() + \"a2\" + '.' + #> 1297 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1298 :         } #> 1299 :       } #> 1300 :       for (int sym1__ = 1; sym1__ <= z3_2dim__; ++sym1__) { #> 1301 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1302 :           param_names__.emplace_back(std::string() + \"z3\" + '.' + #> 1303 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1304 :         } #> 1305 :       } #> 1306 :       for (int sym1__ = 1; sym1__ <= a3_2dim__; ++sym1__) { #> 1307 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1308 :           param_names__.emplace_back(std::string() + \"a3\" + '.' + #> 1309 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1310 :         } #> 1311 :       } #> 1312 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) { #> 1313 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1314 :           param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #> 1315 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1316 :         } #> 1317 :       } #> 1318 :     } #> 1319 :     if (emit_generated_quantities__) {} #> 1320 :   } #> 1321 :   inline void #> 1322 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool #> 1323 :                             emit_transformed_parameters__ = true, bool #> 1324 :                             emit_generated_quantities__ = true) const final { #> 1325 :     for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #> 1326 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #> 1327 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #> 1328 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1329 :       } #> 1330 :     } #> 1331 :     for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #> 1332 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #> 1333 :         std::to_string(sym1__)); #> 1334 :     } #> 1335 :     for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #> 1336 :       for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #> 1337 :         param_names__.emplace_back(std::string() + \"w2\" + '.' + #> 1338 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1339 :       } #> 1340 :     } #> 1341 :     for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #> 1342 :       param_names__.emplace_back(std::string() + \"b2\" + '.' + #> 1343 :         std::to_string(sym1__)); #> 1344 :     } #> 1345 :     for (int sym1__ = 1; sym1__ <= w3_2dim__; ++sym1__) { #> 1346 :       for (int sym2__ = 1; sym2__ <= w3_1dim__; ++sym2__) { #> 1347 :         param_names__.emplace_back(std::string() + \"w3\" + '.' + #> 1348 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1349 :       } #> 1350 :     } #> 1351 :     for (int sym1__ = 1; sym1__ <= b3_1dim__; ++sym1__) { #> 1352 :       param_names__.emplace_back(std::string() + \"b3\" + '.' + #> 1353 :         std::to_string(sym1__)); #> 1354 :     } #> 1355 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) { #> 1356 :       for (int sym2__ = 1; sym2__ <= w_out_1dim__; ++sym2__) { #> 1357 :         param_names__.emplace_back(std::string() + \"w_out\" + '.' + #> 1358 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1359 :       } #> 1360 :     } #> 1361 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) { #> 1362 :       param_names__.emplace_back(std::string() + \"b_out\" + '.' + #> 1363 :         std::to_string(sym1__)); #> 1364 :     } #> 1365 :     if (emit_transformed_parameters__) { #> 1366 :       for (int sym1__ = 1; sym1__ <= z1_2dim__; ++sym1__) { #> 1367 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1368 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #> 1369 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1370 :         } #> 1371 :       } #> 1372 :       for (int sym1__ = 1; sym1__ <= a1_2dim__; ++sym1__) { #> 1373 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1374 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #> 1375 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1376 :         } #> 1377 :       } #> 1378 :       for (int sym1__ = 1; sym1__ <= z2_2dim__; ++sym1__) { #> 1379 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1380 :           param_names__.emplace_back(std::string() + \"z2\" + '.' + #> 1381 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1382 :         } #> 1383 :       } #> 1384 :       for (int sym1__ = 1; sym1__ <= a2_2dim__; ++sym1__) { #> 1385 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1386 :           param_names__.emplace_back(std::string() + \"a2\" + '.' + #> 1387 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1388 :         } #> 1389 :       } #> 1390 :       for (int sym1__ = 1; sym1__ <= z3_2dim__; ++sym1__) { #> 1391 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1392 :           param_names__.emplace_back(std::string() + \"z3\" + '.' + #> 1393 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1394 :         } #> 1395 :       } #> 1396 :       for (int sym1__ = 1; sym1__ <= a3_2dim__; ++sym1__) { #> 1397 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1398 :           param_names__.emplace_back(std::string() + \"a3\" + '.' + #> 1399 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1400 :         } #> 1401 :       } #> 1402 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) { #> 1403 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1404 :           param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #> 1405 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1406 :         } #> 1407 :       } #> 1408 :     } #> 1409 :     if (emit_generated_quantities__) {} #> 1410 :   } #> 1411 :   inline std::string get_constrained_sizedtypes() const { #> 1412 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(w1_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b1_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w2_1dim__) + \",\\\"cols\\\":\" + std::to_string(w2_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b2\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b2_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w3\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w3_1dim__) + \",\\\"cols\\\":\" + std::to_string(w3_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b3\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b3_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w_out_1dim__) + \",\\\"cols\\\":\" + std::to_string(K) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(K) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z3\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z3_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a3\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a3_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(K) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #> 1413 :   } #> 1414 :   inline std::string get_unconstrained_sizedtypes() const { #> 1415 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(w1_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b1_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w2_1dim__) + \",\\\"cols\\\":\" + std::to_string(w2_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b2\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b2_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w3\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w3_1dim__) + \",\\\"cols\\\":\" + std::to_string(w3_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b3\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b3_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w_out_1dim__) + \",\\\"cols\\\":\" + std::to_string(K) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(K) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z3\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z3_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a3\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a3_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(K) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #> 1416 :   } #> 1417 :   // Begin method overload boilerplate #> 1418 :   template <typename RNG> inline void #> 1419 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r, #> 1420 :               Eigen::Matrix<double,-1,1>& vars, const bool #> 1421 :               emit_transformed_parameters = true, const bool #> 1422 :               emit_generated_quantities = true, std::ostream* #> 1423 :               pstream = nullptr) const { #> 1424 :     const size_t num_params__ = ((((((((m * w1_2dim__) + b1_1dim__) + #> 1425 :       (w2_1dim__ * w2_2dim__)) + b2_1dim__) + (w3_1dim__ * w3_2dim__)) + #> 1426 :       b3_1dim__) + (w_out_1dim__ * K)) + K); #> 1427 :     const size_t num_transformed = emit_transformed_parameters * ((((((((n * #> 1428 :       z1_2dim__) + (n * a1_2dim__)) + (n * z2_2dim__)) + (n * a2_2dim__)) + #> 1429 :       (n * z3_2dim__)) + (n * a3_2dim__)) + (n * K))); #> 1430 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #> 1431 :     const size_t num_to_write = num_params__ + num_transformed + #> 1432 :       num_gen_quantities; #> 1433 :     std::vector<int> params_i; #> 1434 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write, #> 1435 :              std::numeric_limits<double>::quiet_NaN()); #> 1436 :     write_array_impl(base_rng, params_r, params_i, vars, #> 1437 :       emit_transformed_parameters, emit_generated_quantities, pstream); #> 1438 :   } #> 1439 :   template <typename RNG> inline void #> 1440 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>& #> 1441 :               params_i, std::vector<double>& vars, bool #> 1442 :               emit_transformed_parameters = true, bool #> 1443 :               emit_generated_quantities = true, std::ostream* #> 1444 :               pstream = nullptr) const { #> 1445 :     const size_t num_params__ = ((((((((m * w1_2dim__) + b1_1dim__) + #> 1446 :       (w2_1dim__ * w2_2dim__)) + b2_1dim__) + (w3_1dim__ * w3_2dim__)) + #> 1447 :       b3_1dim__) + (w_out_1dim__ * K)) + K); #> 1448 :     const size_t num_transformed = emit_transformed_parameters * ((((((((n * #> 1449 :       z1_2dim__) + (n * a1_2dim__)) + (n * z2_2dim__)) + (n * a2_2dim__)) + #> 1450 :       (n * z3_2dim__)) + (n * a3_2dim__)) + (n * K))); #> 1451 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #> 1452 :     const size_t num_to_write = num_params__ + num_transformed + #> 1453 :       num_gen_quantities; #> 1454 :     vars = std::vector<double>(num_to_write, #> 1455 :              std::numeric_limits<double>::quiet_NaN()); #> 1456 :     write_array_impl(base_rng, params_r, params_i, vars, #> 1457 :       emit_transformed_parameters, emit_generated_quantities, pstream); #> 1458 :   } #> 1459 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #> 1460 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const { #> 1461 :     Eigen::Matrix<int,-1,1> params_i; #> 1462 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #> 1463 :   } #> 1464 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #> 1465 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i, #> 1466 :            std::ostream* pstream = nullptr) const { #> 1467 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #> 1468 :   } #> 1469 :   inline void #> 1470 :   transform_inits(const stan::io::var_context& context, #> 1471 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream* #> 1472 :                   pstream = nullptr) const final { #> 1473 :     std::vector<double> params_r_vec(params_r.size()); #> 1474 :     std::vector<int> params_i; #> 1475 :     transform_inits(context, params_i, params_r_vec, pstream); #> 1476 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(), #> 1477 :                  params_r_vec.size()); #> 1478 :   } #> 1479 :   inline void #> 1480 :   transform_inits(const stan::io::var_context& context, std::vector<int>& #> 1481 :                   params_i, std::vector<double>& vars, std::ostream* #> 1482 :                   pstream__ = nullptr) const { #> 1483 :     vars.resize(num_params_r__); #> 1484 :     transform_inits_impl(context, vars, pstream__); #> 1485 :   } #> 1486 :   inline void #> 1487 :   unconstrain_array(const std::vector<double>& params_constrained, #> 1488 :                     std::vector<double>& params_unconstrained, std::ostream* #> 1489 :                     pstream = nullptr) const { #> 1490 :     const std::vector<int> params_i; #> 1491 :     params_unconstrained = std::vector<double>(num_params_r__, #> 1492 :                              std::numeric_limits<double>::quiet_NaN()); #> 1493 :     unconstrain_array_impl(params_constrained, params_i, #> 1494 :       params_unconstrained, pstream); #> 1495 :   } #> 1496 :   inline void #> 1497 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained, #> 1498 :                     Eigen::Matrix<double,-1,1>& params_unconstrained, #> 1499 :                     std::ostream* pstream = nullptr) const { #> 1500 :     const std::vector<int> params_i; #> 1501 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__, #> 1502 :                              std::numeric_limits<double>::quiet_NaN()); #> 1503 :     unconstrain_array_impl(params_constrained, params_i, #> 1504 :       params_unconstrained, pstream); #> 1505 :   } #> 1506 : }; #> 1507 : } #> 1508 : using stan_model = model1d20eab5182__namespace::model1d20eab5182_; #> 1509 : #ifndef USING_R #> 1510 : // Boilerplate #> 1511 : stan::model::model_base& #> 1512 : new_model(stan::io::var_context& data_context, unsigned int seed, #> 1513 :           std::ostream* msg_stream) { #> 1514 :   stan_model* m = new stan_model(data_context, seed, msg_stream); #> 1515 :   return *m; #> 1516 : } #> 1517 : stan::math::profile_map& get_stan_profile_data() { #> 1518 :   return model1d20eab5182__namespace::profiles__; #> 1519 : } #> 1520 : #endif #> 1521 : #endif #> 1522 :  #> 1523 : RCPP_MODULE(stan_fit4model1d20eab5182__mod) { #> 1524 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >( #> 1525 :       \"stan_fit4model1d20eab5182_\") #> 1526 :  #> 1527 :       .constructor<SEXP, SEXP, SEXP>() #> 1528 :  #> 1529 :       .method( #> 1530 :           \"call_sampler\", #> 1531 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler) #> 1532 :       .method( #> 1533 :           \"param_names\", #> 1534 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names) #> 1535 :       .method(\"param_names_oi\", #> 1536 :               &rstan::stan_fit<stan_model, #> 1537 :                                boost::random::ecuyer1988>::param_names_oi) #> 1538 :       .method(\"param_fnames_oi\", #> 1539 :               &rstan::stan_fit<stan_model, #> 1540 :                                boost::random::ecuyer1988>::param_fnames_oi) #> 1541 :       .method( #> 1542 :           \"param_dims\", #> 1543 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims) #> 1544 :       .method(\"param_dims_oi\", #> 1545 :               &rstan::stan_fit<stan_model, #> 1546 :                                boost::random::ecuyer1988>::param_dims_oi) #> 1547 :       .method(\"update_param_oi\", #> 1548 :               &rstan::stan_fit<stan_model, #> 1549 :                                boost::random::ecuyer1988>::update_param_oi) #> 1550 :       .method(\"param_oi_tidx\", #> 1551 :               &rstan::stan_fit<stan_model, #> 1552 :                                boost::random::ecuyer1988>::param_oi_tidx) #> 1553 :       .method(\"grad_log_prob\", #> 1554 :               &rstan::stan_fit<stan_model, #> 1555 :                                boost::random::ecuyer1988>::grad_log_prob) #> 1556 :       .method(\"log_prob\", #> 1557 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob) #> 1558 :       .method(\"unconstrain_pars\", #> 1559 :               &rstan::stan_fit<stan_model, #> 1560 :                                boost::random::ecuyer1988>::unconstrain_pars) #> 1561 :       .method(\"constrain_pars\", #> 1562 :               &rstan::stan_fit<stan_model, #> 1563 :                                boost::random::ecuyer1988>::constrain_pars) #> 1564 :       .method( #> 1565 :           \"num_pars_unconstrained\", #> 1566 :           &rstan::stan_fit<stan_model, #> 1567 :                            boost::random::ecuyer1988>::num_pars_unconstrained) #> 1568 :       .method( #> 1569 :           \"unconstrained_param_names\", #> 1570 :           &rstan::stan_fit< #> 1571 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names) #> 1572 :       .method( #> 1573 :           \"constrained_param_names\", #> 1574 :           &rstan::stan_fit<stan_model, #> 1575 :                            boost::random::ecuyer1988>::constrained_param_names) #> 1576 :       .method(\"standalone_gqs\", #> 1577 :               &rstan::stan_fit<stan_model, #> 1578 :                                boost::random::ecuyer1988>::standalone_gqs); #> 1579 : } #> 1580 :  #> 1581 :  #> 1582 : // declarations #> 1583 : extern \"C\" { #> 1584 : SEXP file1d20237569f3( ) ; #> 1585 : } #> 1586 :  #> 1587 : // definition #> 1588 : SEXP file1d20237569f3() { #> 1589 :  return Rcpp::wrap(\"anon_model\"); #> 1590 : } #>  #> CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW. #>  #> COMPILING MODEL 'anon_model' NOW. #>  #> STARTING SAMPLER FOR MODEL 'anon_model' NOW."},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"summarizing-the-model","dir":"Articles","previous_headings":"","what":"4. Summarizing the Model","title":"Getting Started with the bnns Package","text":"Use summary() function view details fitted model, including network architecture, posterior distributions, predictive performance.","code":"summary(model_reg) #> Call: #> bnns.default(formula = y ~ -1 + x1 + x2, data = df, L = 2, nodes = c(16,  #>     8), act_fn = c(2, 3), out_act_fn = 1, iter = 200, warmup = 100,  #>     chains = 1) #>  #> Data Summary: #> Number of observations: 10  #> Number of features: 2  #>  #> Network Architecture: #> Number of hidden layers: 2  #> Nodes per layer: 16, 8  #> Activation functions: 2, 3  #> Output activation function: 1  #>  #> Posterior Summary (Key Parameters): #>                 mean    se_mean        sd       2.5%        25%          50% #> w_out[1] -0.10198284 0.14234573 1.1509261 -2.3465344 -0.9310721 -0.044826796 #> w_out[2]  0.04577008 0.11614828 1.0015612 -1.9138942 -0.6495277 -0.007745432 #> w_out[3] -0.04075107 0.08738532 0.9189875 -1.8421486 -0.7018924  0.016591141 #> w_out[4] -0.12898385 0.10433181 0.9657694 -1.8705094 -0.8236752 -0.161414637 #> w_out[5]  0.04441101 0.14399470 0.9149602 -1.6450550 -0.5014460  0.074000706 #> w_out[6]  0.09181270 0.09365504 1.0175930 -1.7111797 -0.5749220  0.057005885 #> w_out[7] -0.09465186 0.13233268 1.0584434 -2.1755971 -0.8580435  0.008400356 #> w_out[8]  0.09424769 0.09008563 0.8242622 -1.8145246 -0.4300790  0.120671263 #> b_out     0.22837885 0.09277325 0.9273436 -1.4422208 -0.4423550  0.234050858 #> sigma     0.93627917 0.03072003 0.2678280  0.5408225  0.7386355  0.886663758 #>                75%    97.5%     n_eff      Rhat #> w_out[1] 0.6455087 1.872981  65.37414 1.0294148 #> w_out[2] 0.7022393 2.057543  74.35829 0.9961894 #> w_out[3] 0.5498031 1.697787 110.59672 0.9909493 #> w_out[4] 0.4874982 1.706104  85.68671 1.0311843 #> w_out[5] 0.5386251 1.930949  40.37489 1.0143750 #> w_out[6] 0.7953263 1.971914 118.05542 1.0181717 #> w_out[7] 0.5742348 1.845179  63.97364 0.9900240 #> w_out[8] 0.6472984 1.707112  83.71817 1.0260238 #> b_out    0.8811560 2.089568  99.91618 0.9960687 #> sigma    1.0861037 1.516254  76.00964 1.0077324 #>  #> Model Fit Information: #> Iterations: 200  #> Warmup: 100  #> Thinning: 1  #> Chains: 1  #>  #> Predictive Performance: #> RMSE (training): 0.7223731  #> MAE (training): 0.5778231  #>  #> Notes: #> Check convergence diagnostics for parameters with high R-hat values. summary(model_bin) #> Call: #> bnns.default(formula = y_bin ~ -1 + x1 + x2, data = df, L = 1,  #>     nodes = c(16), act_fn = c(2), out_act_fn = 2, iter = 200,  #>     warmup = 100, chains = 1) #>  #> Data Summary: #> Number of observations: 10  #> Number of features: 2  #>  #> Network Architecture: #> Number of hidden layers: 1  #> Nodes per layer: 16  #> Activation functions: 2  #> Output activation function: 2  #>  #> Posterior Summary (Key Parameters): #>                  mean    se_mean        sd      2.5%        25%          50% #> w_out[1]  -0.04345777 0.07981887 1.1288093 -2.280074 -0.7739249 -0.084563996 #> w_out[2]  -0.10854421 0.06492203 0.9181362 -1.820706 -0.8158379 -0.129244986 #> w_out[3]  -0.04733930 0.08728398 1.1709530 -2.284902 -0.6974198 -0.069762017 #> w_out[4]  -0.07442612 0.08746013 1.0056823 -1.765856 -0.8388857  0.060868077 #> w_out[5]  -0.08251131 0.07005253 0.9739135 -1.941951 -0.6649070 -0.067906255 #> w_out[6]  -0.09651904 0.06661793 0.9421197 -1.831560 -0.6940963 -0.023229666 #> w_out[7]  -0.08778892 0.07564171 0.9924330 -1.866496 -0.8478535 -0.103602978 #> w_out[8]   0.02903283 0.07734812 1.0896562 -2.087356 -0.6706888  0.067145045 #> w_out[9]  -0.13078702 0.06295167 0.7584826 -1.601768 -0.5649343 -0.112141100 #> w_out[10] -0.08238946 0.07941397 0.8960922 -1.871830 -0.8553466  0.008721204 #> w_out[11] -0.10940235 0.05845876 0.8267317 -1.569305 -0.7004692 -0.164975023 #> w_out[12] -0.13958470 0.07291295 0.9105779 -2.086525 -0.6294893 -0.114593361 #> w_out[13] -0.16140507 0.07681523 0.8308345 -1.642827 -0.7390763 -0.265218071 #> w_out[14] -0.10621591 0.07937302 1.1225040 -2.145834 -1.0087129 -0.124112967 #> w_out[15] -0.18700148 0.07406293 1.0021791 -2.049505 -0.8018032 -0.185735154 #> w_out[16] -0.13709871 0.07999005 0.8108405 -1.737055 -0.6493309 -0.061811801 #> b_out     -0.10677161 0.05751580 0.7707151 -1.655863 -0.7079414 -0.003325278 #>                 75%    97.5%    n_eff      Rhat #> w_out[1]  0.6424576 2.323639 200.0000 0.9900273 #> w_out[2]  0.4732469 1.862930 200.0000 1.0000001 #> w_out[3]  0.5712573 1.929134 179.9740 0.9916430 #> w_out[4]  0.5484194 2.061503 132.2213 1.0338821 #> w_out[5]  0.6097928 1.561309 193.2828 0.9924725 #> w_out[6]  0.5037707 1.614188 200.0000 1.0137819 #> w_out[7]  0.6459444 1.745976 172.1392 0.9941446 #> w_out[8]  0.8734678 1.919111 198.4630 0.9904989 #> w_out[9]  0.2781727 1.195860 145.1699 0.9908800 #> w_out[10] 0.5593301 1.452123 127.3244 0.9988283 #> w_out[11] 0.5374080 1.444190 200.0000 0.9928589 #> w_out[12] 0.3257585 1.587033 155.9642 0.9937455 #> w_out[13] 0.4468593 1.392755 116.9861 0.9964299 #> w_out[14] 0.6969567 2.039603 200.0000 0.9926457 #> w_out[15] 0.4123997 1.913980 183.1002 0.9906695 #> w_out[16] 0.4020165 1.462336 102.7541 0.9914435 #> b_out     0.4391922 1.189386 179.5616 0.9916888 #>  #> Model Fit Information: #> Iterations: 200  #> Warmup: 100  #> Thinning: 1  #> Chains: 1  #>  #> Predictive Performance: #> Setting levels: control = 0, case = 1 #> Setting direction: controls < cases #> Confusion matrix (training with 0.5 cutoff): 7 3  #> Accuracy (training with 0.5 cutoff): 0.7  #> 0.7142857  #>  #> Notes: #> Check convergence diagnostics for parameters with high R-hat values. summary(model_cat) #> Call: #> bnns.default(formula = y_cat ~ -1 + x1 + x2, data = df, L = 3,  #>     nodes = c(32, 16, 8), act_fn = c(3, 2, 2), out_act_fn = 3,  #>     iter = 200, warmup = 100, chains = 1) #>  #> Data Summary: #> Number of observations: 10  #> Number of features: 2  #>  #> Network Architecture: #> Number of hidden layers: 3  #> Nodes per layer: 32, 16, 8  #> Activation functions: 3, 2, 2  #> Output activation function: 3  #>  #> Posterior Summary (Key Parameters): #>                   mean    se_mean        sd      2.5%        25%         50% #> w_out[1,1]  0.01394526 0.07036622 0.9951286 -1.842787 -0.7352138  0.03492211 #> w_out[1,2] -0.08280125 0.06549208 0.9261979 -1.725050 -0.5972658 -0.05306723 #> w_out[1,3]  0.01573850 0.06314323 0.8929801 -1.599088 -0.6772641  0.04761421 #> w_out[2,1]  0.07036115 0.06026366 0.8522569 -1.402218 -0.5240907  0.04511580 #> w_out[2,2] -0.12329278 0.07094791 1.0033549 -2.001673 -0.7256266 -0.20538396 #> w_out[2,3]  0.01790976 0.06701062 0.9476732 -1.679826 -0.7097821  0.09160038 #> w_out[3,1]  0.03239133 0.08259533 1.1680744 -2.254300 -0.8092592  0.12058830 #> w_out[3,2] -0.07898128 0.09486460 1.1532263 -2.391624 -0.8628898 -0.25924333 #> w_out[3,3] -0.07272037 0.06814890 0.9637709 -2.103192 -0.8542239  0.03632515 #> w_out[4,1]  0.05156983 0.07059578 0.9983751 -1.840065 -0.5747548 -0.02963318 #> w_out[4,2] -0.09714691 0.05740685 0.8118555 -1.538313 -0.6320181 -0.10185898 #> w_out[4,3]  0.03644411 0.07437223 1.0517822 -1.689593 -0.6589942  0.06534725 #> w_out[5,1]  0.04368120 0.05885995 0.8324054 -1.533618 -0.4949419  0.02237846 #> w_out[5,2] -0.08286049 0.08133546 1.1502570 -2.248796 -0.8874759 -0.11065365 #> w_out[5,3]  0.02237333 0.05802117 0.8205433 -1.794007 -0.4839838  0.01150155 #> w_out[6,1]  0.14088588 0.07903914 1.1177822 -2.089278 -0.4444319  0.12407505 #> w_out[6,2] -0.11847308 0.06254868 0.8845720 -1.704537 -0.7062881 -0.03704612 #> w_out[6,3]  0.05785091 0.06478514 0.9162003 -1.764157 -0.5177482 -0.02077027 #> w_out[7,1]  0.12612793 0.07646742 1.0814126 -2.216329 -0.6519762  0.07510610 #> w_out[7,2] -0.05932307 0.06164795 0.8718337 -1.755824 -0.6138528 -0.06745596 #> w_out[7,3]  0.01842045 0.07330898 0.9390262 -1.690906 -0.6639781 -0.03973415 #> w_out[8,1]  0.12033166 0.05488780 0.7474899 -1.165213 -0.3938527  0.10233644 #> w_out[8,2] -0.10743562 0.08056516 1.1393635 -1.971649 -1.0039259 -0.07132602 #> w_out[8,3]  0.02160029 0.07071598 0.9308556 -1.528458 -0.7194426  0.05584917 #> b_out[1]    0.14097861 0.06239699 0.8824267 -1.895995 -0.4287659  0.11257944 #> b_out[2]   -0.20330320 0.07263399 1.0271997 -2.288989 -0.8910927 -0.23371122 #> b_out[3]   -0.08665864 0.07534820 1.0655845 -1.986733 -0.8796537 -0.21590654 #>                  75%    97.5%    n_eff      Rhat #> w_out[1,1] 0.7880883 1.711400 200.0000 0.9906571 #> w_out[1,2] 0.4556183 1.960764 200.0000 0.9905777 #> w_out[1,3] 0.7699205 1.473742 200.0000 0.9899590 #> w_out[2,1] 0.6176310 1.785358 200.0000 1.0185192 #> w_out[2,2] 0.5950283 1.726812 200.0000 0.9908967 #> w_out[2,3] 0.7451203 1.467679 200.0000 0.9900956 #> w_out[3,1] 0.9091794 2.202241 200.0000 0.9899530 #> w_out[3,2] 0.9128163 1.884212 147.7817 0.9953293 #> w_out[3,3] 0.6750217 1.512576 200.0000 0.9908107 #> w_out[4,1] 0.7711055 1.868197 200.0000 0.9906220 #> w_out[4,2] 0.4448852 1.327239 200.0000 0.9899551 #> w_out[4,3] 0.8367175 1.780680 200.0000 0.9925562 #> w_out[5,1] 0.6464946 1.560538 200.0000 0.9910343 #> w_out[5,2] 0.6141291 2.314026 200.0000 0.9900906 #> w_out[5,3] 0.5216419 1.652119 200.0000 0.9906631 #> w_out[6,1] 0.8638882 2.474803 200.0000 0.9910499 #> w_out[6,2] 0.4958150 1.463965 200.0000 0.9925982 #> w_out[6,3] 0.6543789 1.619203 200.0000 0.9900060 #> w_out[7,1] 0.9462813 1.900933 200.0000 0.9901126 #> w_out[7,2] 0.4982239 1.534793 200.0000 0.9978339 #> w_out[7,3] 0.7258390 1.897475 164.0745 0.9911252 #> w_out[8,1] 0.6205414 1.530701 185.4637 0.9906603 #> w_out[8,2] 0.7456442 2.089929 200.0000 0.9963176 #> w_out[8,3] 0.7708924 1.529909 173.2724 1.0134181 #> b_out[1]   0.7355672 1.824535 200.0000 0.9904573 #> b_out[2]   0.4550961 1.747758 200.0000 0.9974122 #> b_out[3]   0.6986215 1.867415 200.0000 0.9916260 #>  #> Model Fit Information: #> Iterations: 200  #> Warmup: 100  #> Thinning: 1  #> Chains: 1  #>  #> Predictive Performance: #> Log-loss (training): 1.014759  #> AUC (training): 0.8555556  #>  #> Notes: #> Check convergence diagnostics for parameters with high R-hat values."},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"making-predictions","dir":"Articles","previous_headings":"","what":"5. Making Predictions","title":"Getting Started with the bnns Package","text":"predict() function generates predictions new data. format predictions depends output activation function.","code":"# New data test_x <- matrix(runif(10), nrow = 5, ncol = 2) |> data.frame() |>    `colnames<-`(c(\"x1\", \"x2\"))  # Regression predictions pred_reg <- predict(model_reg, test_x)  # Binary classification predictions pred_bin <- predict(model_bin, test_x)  # Multiclass classification predictions pred_cat <- predict(model_cat, test_x)"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"evaluating-the-model","dir":"Articles","previous_headings":"","what":"6. Evaluating the Model","title":"Getting Started with the bnns Package","text":"bnns package includes utility functions like measure_cont, measure_bin, measure_cat evaluating model performance.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"regression-evaluation","dir":"Articles","previous_headings":"6. Evaluating the Model","what":"Regression Evaluation","title":"Getting Started with the bnns Package","text":"","code":"# True responses test_y <- rnorm(5)  # Evaluate predictions metrics_reg <- measure_cont(obs = test_y, pred = pred_reg) print(metrics_reg) #> $rmse #> [1] 0.7465952 #>  #> $mae #> [1] 0.649243"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"binary-classification-evaluation","dir":"Articles","previous_headings":"6. Evaluating the Model","what":"Binary Classification Evaluation","title":"Getting Started with the bnns Package","text":"","code":"# True responses test_y_bin <- sample(c(rep(0, 2), rep(1, 3)), 5)  # Evaluate predictions metrics_bin <- measure_bin(obs = test_y_bin, pred = pred_bin) #> Setting levels: control = 0, case = 1 #> Setting direction: controls < cases print(metrics_bin) #> $conf_mat #>    pred_label #> obs 0 #>   0 2 #>   1 3 #>  #> $accuracy #> [1] 0.4 #>  #> $ROC #>  #> Call: #> roc.default(response = obs, predictor = pred) #>  #> Data: pred in 2 controls (obs 0) < 3 cases (obs 1). #> Area under the curve: 1 #>  #> $AUC #> [1] 1"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"multiclass-classification-evaluation","dir":"Articles","previous_headings":"6. Evaluating the Model","what":"Multiclass Classification Evaluation","title":"Getting Started with the bnns Package","text":"","code":"# True responses test_y_cat <- factor(sample(letters[1:3], 5, replace = TRUE))  # Evaluate predictions metrics_cat <- measure_cat(obs = test_y_cat, pred = pred_cat) print(metrics_cat) #> $log_loss #> [1] 1.083396 #>  #> $ROC #>  #> Call: #> multiclass.roc.default(response = obs, predictor = `colnames<-`(data.frame(pred),     levels(obs))) #>  #> Data: multivariate predictor `colnames<-`(data.frame(pred), levels(obs)) with 3 levels of obs: a, b, c. #> Multi-class area under the curve: 0.625 #>  #> $AUC #> [1] 0.625"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"notes-on-bayesian-neural-networks","dir":"Articles","previous_headings":"","what":"8. Notes on Bayesian Neural Networks","title":"Getting Started with the bnns Package","text":"Bayesian inference allows uncertainty quantification predictions. Always check convergence diagnostics R-hat values. Use informative priors possible stabilize model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Getting Started with the bnns Package","text":"details, consult source code GitHub.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using Bayesian Neural Networks in Clinical Trials","text":"Bayesian Neural Networks (BNNs) offer robust framework prediction clinical trials providing posterior distributions predictions. allows probabilistic reasoning, computing probability treatment achieves certain efficacy threshold proportion success. vignette, : 1. Illustrate data preparation clinical trial setting. 2. Fit BNN simulate clinical trial outcomes. 3. Leverage posterior distributions decision-making, calculating posterior probabilities treatment success.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"data-preparation","dir":"Articles","previous_headings":"","what":"1. Data Preparation","title":"Using Bayesian Neural Networks in Clinical Trials","text":"Consider hypothetical clinical trial comparing efficacy new treatment placebo. response variable binary, representing treatment success (1) failure (0).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"simulating-data","dir":"Articles","previous_headings":"1. Data Preparation","what":"Simulating Data","title":"Using Bayesian Neural Networks in Clinical Trials","text":"","code":"set.seed(123)  # Simulate predictor variables (e.g., patient covariates) n_subjects <- 100 Age <- runif(n_subjects, 18, 50)                  # Age in years Dose <- runif(n_subjects, 10, 100)                # Dose levels Severity <- runif(n_subjects, 1, 10)              # Baseline severity (arbitrary scale)  # Define true probabilities using a nonlinear function beta_0 <- 1 beta_1 <- 0.3 beta_2 <- -0.1 beta_3 <- -0.02 beta_4 <- 0.005  logit_p <- beta_0 + beta_1 * Dose + beta_2 * log(Severity) +            beta_3 * Age^2 + beta_4 * (Age * Dose) p_success <- 1 / (1 + exp(-logit_p))     # Sigmoid transformation  # Simulate binary outcomes Success <- rbinom(n_subjects, size = 1, prob = p_success)  trial_data <- cbind.data.frame(Success, Age, Dose, Severity)  # Split into training and testing train_idx <- sample(seq_len(n_subjects), size = 0.8 * n_subjects) training_data <- trial_data[train_idx, ] test_data <- trial_data[-train_idx, ]"},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"fitting-a-bayesian-neural-network","dir":"Articles","previous_headings":"","what":"2. Fitting a Bayesian Neural Network","title":"Using Bayesian Neural Networks in Clinical Trials","text":"Fit BNN simulated data. use binary classification model logistic sigmoid activation output layer.","code":"# Fit a BNN model <- bnns(   formula = Success ~ -1 + .,   data = training_data,   L = 2,                # Number of hidden layers   nodes = c(16, 8),     # Nodes per layer   act_fn = c(2, 2),     # Activation functions for hidden layers   out_act_fn = 2,       # Output activation: logistic sigmoid   iter = 2e2,    # Bayesian sampling iterations   warmup = 1e2,         # Warmup iterations   chains = 1            # Number of MCMC chains ) #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found #>  #> TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW. #> OS: x86_64, linux-gnu; rstan: 2.32.6; Rcpp: 1.0.13.1; inline: 0.3.20  #>  >> setting environment variables:  #> PKG_LIBS =  '/home/runner/work/_temp/Library/rstan/lib//libStanServices.a' -L'/home/runner/work/_temp/Library/StanHeaders/lib/' -lStanHeaders -L'/home/runner/work/_temp/Library/RcppParallel/lib/' -ltbb  #> PKG_CPPFLAGS =   -I\"/home/runner/work/_temp/Library/Rcpp/include/\"  -I\"/home/runner/work/_temp/Library/RcppEigen/include/\"  -I\"/home/runner/work/_temp/Library/RcppEigen/include/unsupported\"  -I\"/home/runner/work/_temp/Library/BH/include\" -I\"/home/runner/work/_temp/Library/StanHeaders/include/src/\"  -I\"/home/runner/work/_temp/Library/StanHeaders/include/\"  -I\"/home/runner/work/_temp/Library/RcppParallel/include/\"  -I\"/home/runner/work/_temp/Library/rstan/include\" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/runner/work/_temp/Library/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1  #>  >> Program source : #>  #>    1 :  #>    2 : // includes from the plugin #>    3 : // [[Rcpp::plugins(cpp14)]] #>    4 :  #>    5 :  #>    6 : // user includes #>    7 : #include <Rcpp.h> #>    8 : using namespace Rcpp; #>    9 : #ifndef MODELS_HPP #>   10 : #define MODELS_HPP #>   11 : #define STAN__SERVICES__COMMAND_HPP #>   12 : #include <rstan/rstaninc.hpp> #>   13 : #ifndef USE_STANC3 #>   14 : #define USE_STANC3 #>   15 : #endif #>   16 : // Code generated by stanc v2.32.2 #>   17 : #include <stan/model/model_header.hpp> #>   18 : namespace model1ed761d7bcb2__namespace { #>   19 : using stan::model::model_base_crtp; #>   20 : using namespace stan::math; #>   21 : stan::math::profile_map profiles__; #>   22 : static constexpr std::array<const char*, 64> locations_array__ = #>   23 :   {\" (found before start of program)\", #>   24 :   \" (in 'anon_model', line 11, column 2 to column 25)\", #>   25 :   \" (in 'anon_model', line 12, column 2 to column 22)\", #>   26 :   \" (in 'anon_model', line 13, column 2 to column 32)\", #>   27 :   \" (in 'anon_model', line 14, column 2 to column 22)\", #>   28 :   \" (in 'anon_model', line 15, column 2 to column 25)\", #>   29 :   \" (in 'anon_model', line 16, column 2 to column 13)\", #>   30 :   \" (in 'anon_model', line 19, column 2 to column 25)\", #>   31 :   \" (in 'anon_model', line 20, column 2 to column 25)\", #>   32 :   \" (in 'anon_model', line 21, column 2 to column 25)\", #>   33 :   \" (in 'anon_model', line 22, column 2 to column 25)\", #>   34 :   \" (in 'anon_model', line 23, column 2 to column 18)\", #>   35 :   \" (in 'anon_model', line 24, column 2 to column 35)\", #>   36 :   \" (in 'anon_model', line 28, column 7 to column 49)\", #>   37 :   \" (in 'anon_model', line 27, column 27 to column 49)\", #>   38 :   \" (in 'anon_model', line 27, column 7 to line 28, column 49)\", #>   39 :   \" (in 'anon_model', line 26, column 27 to column 46)\", #>   40 :   \" (in 'anon_model', line 26, column 7 to line 28, column 49)\", #>   41 :   \" (in 'anon_model', line 25, column 22 to column 36)\", #>   42 :   \" (in 'anon_model', line 25, column 2 to line 28, column 49)\", #>   43 :   \" (in 'anon_model', line 29, column 2 to column 36)\", #>   44 :   \" (in 'anon_model', line 33, column 7 to column 49)\", #>   45 :   \" (in 'anon_model', line 32, column 27 to column 49)\", #>   46 :   \" (in 'anon_model', line 32, column 7 to line 33, column 49)\", #>   47 :   \" (in 'anon_model', line 31, column 27 to column 46)\", #>   48 :   \" (in 'anon_model', line 31, column 7 to line 33, column 49)\", #>   49 :   \" (in 'anon_model', line 30, column 22 to column 36)\", #>   50 :   \" (in 'anon_model', line 30, column 2 to line 33, column 49)\", #>   51 :   \" (in 'anon_model', line 34, column 2 to column 29)\", #>   52 :   \" (in 'anon_model', line 37, column 2 to column 31)\", #>   53 :   \" (in 'anon_model', line 38, column 2 to column 20)\", #>   54 :   \" (in 'anon_model', line 39, column 2 to column 31)\", #>   55 :   \" (in 'anon_model', line 40, column 2 to column 20)\", #>   56 :   \" (in 'anon_model', line 41, column 2 to column 23)\", #>   57 :   \" (in 'anon_model', line 42, column 2 to column 23)\", #>   58 :   \" (in 'anon_model', line 43, column 2 to column 29)\", #>   59 :   \" (in 'anon_model', line 2, column 2 to column 17)\", #>   60 :   \" (in 'anon_model', line 3, column 2 to column 17)\", #>   61 :   \" (in 'anon_model', line 4, column 2 to column 17)\", #>   62 :   \" (in 'anon_model', line 5, column 21 to column 22)\", #>   63 :   \" (in 'anon_model', line 5, column 2 to column 24)\", #>   64 :   \" (in 'anon_model', line 6, column 9 to column 10)\", #>   65 :   \" (in 'anon_model', line 6, column 12 to column 13)\", #>   66 :   \" (in 'anon_model', line 6, column 2 to column 17)\", #>   67 :   \" (in 'anon_model', line 7, column 8 to column 9)\", #>   68 :   \" (in 'anon_model', line 7, column 2 to column 35)\", #>   69 :   \" (in 'anon_model', line 8, column 22 to column 23)\", #>   70 :   \" (in 'anon_model', line 8, column 2 to column 25)\", #>   71 :   \" (in 'anon_model', line 11, column 9 to column 10)\", #>   72 :   \" (in 'anon_model', line 11, column 12 to column 20)\", #>   73 :   \" (in 'anon_model', line 12, column 9 to column 17)\", #>   74 :   \" (in 'anon_model', line 13, column 9 to column 17)\", #>   75 :   \" (in 'anon_model', line 13, column 19 to column 27)\", #>   76 :   \" (in 'anon_model', line 14, column 9 to column 17)\", #>   77 :   \" (in 'anon_model', line 15, column 9 to column 17)\", #>   78 :   \" (in 'anon_model', line 19, column 9 to column 10)\", #>   79 :   \" (in 'anon_model', line 19, column 12 to column 20)\", #>   80 :   \" (in 'anon_model', line 20, column 9 to column 10)\", #>   81 :   \" (in 'anon_model', line 20, column 12 to column 20)\", #>   82 :   \" (in 'anon_model', line 21, column 9 to column 10)\", #>   83 :   \" (in 'anon_model', line 21, column 12 to column 20)\", #>   84 :   \" (in 'anon_model', line 22, column 9 to column 10)\", #>   85 :   \" (in 'anon_model', line 22, column 12 to column 20)\", #>   86 :   \" (in 'anon_model', line 23, column 9 to column 10)\"}; #>   87 : class model1ed761d7bcb2_ final : public model_base_crtp<model1ed761d7bcb2_> { #>   88 : private: #>   89 :   int n; #>   90 :   int m; #>   91 :   int L; #>   92 :   std::vector<int> nodes; #>   93 :   Eigen::Matrix<double,-1,-1> X_data__; #>   94 :   std::vector<int> y; #>   95 :   std::vector<int> act_fn; #>   96 :   int w1_2dim__; #>   97 :   int b1_1dim__; #>   98 :   int w2_1dim__; #>   99 :   int w2_2dim__; #>  100 :   int b2_1dim__; #>  101 :   int w_out_1dim__; #>  102 :   int z1_2dim__; #>  103 :   int a1_2dim__; #>  104 :   int z2_2dim__; #>  105 :   int a2_2dim__; #>  106 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> X{nullptr, 0, 0}; #>  107 : public: #>  108 :   ~model1ed761d7bcb2_() {} #>  109 :   model1ed761d7bcb2_(stan::io::var_context& context__, unsigned int #>  110 :                      random_seed__ = 0, std::ostream* pstream__ = nullptr) #>  111 :       : model_base_crtp(0) { #>  112 :     int current_statement__ = 0; #>  113 :     using local_scalar_t__ = double; #>  114 :     boost::ecuyer1988 base_rng__ = #>  115 :       stan::services::util::create_rng(random_seed__, 0); #>  116 :     // suppress unused var warning #>  117 :     (void) base_rng__; #>  118 :     static constexpr const char* function__ = #>  119 :       \"model1ed761d7bcb2__namespace::model1ed761d7bcb2_\"; #>  120 :     // suppress unused var warning #>  121 :     (void) function__; #>  122 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  123 :     // suppress unused var warning #>  124 :     (void) DUMMY_VAR__; #>  125 :     try { #>  126 :       int pos__ = std::numeric_limits<int>::min(); #>  127 :       pos__ = 1; #>  128 :       current_statement__ = 36; #>  129 :       context__.validate_dims(\"data initialization\", \"n\", \"int\", #>  130 :         std::vector<size_t>{}); #>  131 :       n = std::numeric_limits<int>::min(); #>  132 :       current_statement__ = 36; #>  133 :       n = context__.vals_i(\"n\")[(1 - 1)]; #>  134 :       current_statement__ = 36; #>  135 :       stan::math::check_greater_or_equal(function__, \"n\", n, 1); #>  136 :       current_statement__ = 37; #>  137 :       context__.validate_dims(\"data initialization\", \"m\", \"int\", #>  138 :         std::vector<size_t>{}); #>  139 :       m = std::numeric_limits<int>::min(); #>  140 :       current_statement__ = 37; #>  141 :       m = context__.vals_i(\"m\")[(1 - 1)]; #>  142 :       current_statement__ = 37; #>  143 :       stan::math::check_greater_or_equal(function__, \"m\", m, 1); #>  144 :       current_statement__ = 38; #>  145 :       context__.validate_dims(\"data initialization\", \"L\", \"int\", #>  146 :         std::vector<size_t>{}); #>  147 :       L = std::numeric_limits<int>::min(); #>  148 :       current_statement__ = 38; #>  149 :       L = context__.vals_i(\"L\")[(1 - 1)]; #>  150 :       current_statement__ = 38; #>  151 :       stan::math::check_greater_or_equal(function__, \"L\", L, 1); #>  152 :       current_statement__ = 39; #>  153 :       stan::math::validate_non_negative_index(\"nodes\", \"L\", L); #>  154 :       current_statement__ = 40; #>  155 :       context__.validate_dims(\"data initialization\", \"nodes\", \"int\", #>  156 :         std::vector<size_t>{static_cast<size_t>(L)}); #>  157 :       nodes = std::vector<int>(L, std::numeric_limits<int>::min()); #>  158 :       current_statement__ = 40; #>  159 :       nodes = context__.vals_i(\"nodes\"); #>  160 :       current_statement__ = 40; #>  161 :       stan::math::check_greater_or_equal(function__, \"nodes\", nodes, 1); #>  162 :       current_statement__ = 41; #>  163 :       stan::math::validate_non_negative_index(\"X\", \"n\", n); #>  164 :       current_statement__ = 42; #>  165 :       stan::math::validate_non_negative_index(\"X\", \"m\", m); #>  166 :       current_statement__ = 43; #>  167 :       context__.validate_dims(\"data initialization\", \"X\", \"double\", #>  168 :         std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m)}); #>  169 :       X_data__ = Eigen::Matrix<double,-1,-1>::Constant(n, m, #>  170 :                    std::numeric_limits<double>::quiet_NaN()); #>  171 :       new (&X) Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_data__.data(), n, m); #>  172 :       { #>  173 :         std::vector<local_scalar_t__> X_flat__; #>  174 :         current_statement__ = 43; #>  175 :         X_flat__ = context__.vals_r(\"X\"); #>  176 :         current_statement__ = 43; #>  177 :         pos__ = 1; #>  178 :         current_statement__ = 43; #>  179 :         for (int sym1__ = 1; sym1__ <= m; ++sym1__) { #>  180 :           current_statement__ = 43; #>  181 :           for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  182 :             current_statement__ = 43; #>  183 :             stan::model::assign(X, X_flat__[(pos__ - 1)], #>  184 :               \"assigning variable X\", stan::model::index_uni(sym2__), #>  185 :               stan::model::index_uni(sym1__)); #>  186 :             current_statement__ = 43; #>  187 :             pos__ = (pos__ + 1); #>  188 :           } #>  189 :         } #>  190 :       } #>  191 :       current_statement__ = 44; #>  192 :       stan::math::validate_non_negative_index(\"y\", \"n\", n); #>  193 :       current_statement__ = 45; #>  194 :       context__.validate_dims(\"data initialization\", \"y\", \"int\", #>  195 :         std::vector<size_t>{static_cast<size_t>(n)}); #>  196 :       y = std::vector<int>(n, std::numeric_limits<int>::min()); #>  197 :       current_statement__ = 45; #>  198 :       y = context__.vals_i(\"y\"); #>  199 :       current_statement__ = 45; #>  200 :       stan::math::check_greater_or_equal(function__, \"y\", y, 0); #>  201 :       current_statement__ = 45; #>  202 :       stan::math::check_less_or_equal(function__, \"y\", y, 1); #>  203 :       current_statement__ = 46; #>  204 :       stan::math::validate_non_negative_index(\"act_fn\", \"L\", L); #>  205 :       current_statement__ = 47; #>  206 :       context__.validate_dims(\"data initialization\", \"act_fn\", \"int\", #>  207 :         std::vector<size_t>{static_cast<size_t>(L)}); #>  208 :       act_fn = std::vector<int>(L, std::numeric_limits<int>::min()); #>  209 :       current_statement__ = 47; #>  210 :       act_fn = context__.vals_i(\"act_fn\"); #>  211 :       current_statement__ = 47; #>  212 :       stan::math::check_greater_or_equal(function__, \"act_fn\", act_fn, 1); #>  213 :       current_statement__ = 48; #>  214 :       stan::math::validate_non_negative_index(\"w1\", \"m\", m); #>  215 :       current_statement__ = 49; #>  216 :       w1_2dim__ = std::numeric_limits<int>::min(); #>  217 :       current_statement__ = 49; #>  218 :       w1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  219 :                     stan::model::index_uni(1)); #>  220 :       current_statement__ = 49; #>  221 :       stan::math::validate_non_negative_index(\"w1\", \"nodes[1]\", w1_2dim__); #>  222 :       current_statement__ = 50; #>  223 :       b1_1dim__ = std::numeric_limits<int>::min(); #>  224 :       current_statement__ = 50; #>  225 :       b1_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  226 :                     stan::model::index_uni(1)); #>  227 :       current_statement__ = 50; #>  228 :       stan::math::validate_non_negative_index(\"b1\", \"nodes[1]\", b1_1dim__); #>  229 :       current_statement__ = 51; #>  230 :       w2_1dim__ = std::numeric_limits<int>::min(); #>  231 :       current_statement__ = 51; #>  232 :       w2_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  233 :                     stan::model::index_uni(1)); #>  234 :       current_statement__ = 51; #>  235 :       stan::math::validate_non_negative_index(\"w2\", \"nodes[1]\", w2_1dim__); #>  236 :       current_statement__ = 52; #>  237 :       w2_2dim__ = std::numeric_limits<int>::min(); #>  238 :       current_statement__ = 52; #>  239 :       w2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  240 :                     stan::model::index_uni(2)); #>  241 :       current_statement__ = 52; #>  242 :       stan::math::validate_non_negative_index(\"w2\", \"nodes[2]\", w2_2dim__); #>  243 :       current_statement__ = 53; #>  244 :       b2_1dim__ = std::numeric_limits<int>::min(); #>  245 :       current_statement__ = 53; #>  246 :       b2_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  247 :                     stan::model::index_uni(2)); #>  248 :       current_statement__ = 53; #>  249 :       stan::math::validate_non_negative_index(\"b2\", \"nodes[2]\", b2_1dim__); #>  250 :       current_statement__ = 54; #>  251 :       w_out_1dim__ = std::numeric_limits<int>::min(); #>  252 :       current_statement__ = 54; #>  253 :       w_out_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  254 :                        stan::model::index_uni(L)); #>  255 :       current_statement__ = 54; #>  256 :       stan::math::validate_non_negative_index(\"w_out\", \"nodes[L]\", #>  257 :         w_out_1dim__); #>  258 :       current_statement__ = 55; #>  259 :       stan::math::validate_non_negative_index(\"z1\", \"n\", n); #>  260 :       current_statement__ = 56; #>  261 :       z1_2dim__ = std::numeric_limits<int>::min(); #>  262 :       current_statement__ = 56; #>  263 :       z1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  264 :                     stan::model::index_uni(1)); #>  265 :       current_statement__ = 56; #>  266 :       stan::math::validate_non_negative_index(\"z1\", \"nodes[1]\", z1_2dim__); #>  267 :       current_statement__ = 57; #>  268 :       stan::math::validate_non_negative_index(\"a1\", \"n\", n); #>  269 :       current_statement__ = 58; #>  270 :       a1_2dim__ = std::numeric_limits<int>::min(); #>  271 :       current_statement__ = 58; #>  272 :       a1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  273 :                     stan::model::index_uni(1)); #>  274 :       current_statement__ = 58; #>  275 :       stan::math::validate_non_negative_index(\"a1\", \"nodes[1]\", a1_2dim__); #>  276 :       current_statement__ = 59; #>  277 :       stan::math::validate_non_negative_index(\"z2\", \"n\", n); #>  278 :       current_statement__ = 60; #>  279 :       z2_2dim__ = std::numeric_limits<int>::min(); #>  280 :       current_statement__ = 60; #>  281 :       z2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  282 :                     stan::model::index_uni(2)); #>  283 :       current_statement__ = 60; #>  284 :       stan::math::validate_non_negative_index(\"z2\", \"nodes[2]\", z2_2dim__); #>  285 :       current_statement__ = 61; #>  286 :       stan::math::validate_non_negative_index(\"a2\", \"n\", n); #>  287 :       current_statement__ = 62; #>  288 :       a2_2dim__ = std::numeric_limits<int>::min(); #>  289 :       current_statement__ = 62; #>  290 :       a2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  291 :                     stan::model::index_uni(2)); #>  292 :       current_statement__ = 62; #>  293 :       stan::math::validate_non_negative_index(\"a2\", \"nodes[2]\", a2_2dim__); #>  294 :       current_statement__ = 63; #>  295 :       stan::math::validate_non_negative_index(\"y_hat\", \"n\", n); #>  296 :     } catch (const std::exception& e) { #>  297 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  298 :     } #>  299 :     num_params_r__ = (m * w1_2dim__) + b1_1dim__ + (w2_1dim__ * w2_2dim__) + #>  300 :       b2_1dim__ + w_out_1dim__ + 1; #>  301 :   } #>  302 :   inline std::string model_name() const final { #>  303 :     return \"model1ed761d7bcb2_\"; #>  304 :   } #>  305 :   inline std::vector<std::string> model_compile_info() const noexcept { #>  306 :     return std::vector<std::string>{\"stanc_version = stanc3 v2.32.2\", #>  307 :              \"stancflags = --\"}; #>  308 :   } #>  309 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI, #>  310 :             stan::require_vector_like_t<VecR>* = nullptr, #>  311 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  312 :   inline stan::scalar_type_t<VecR> #>  313 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream* #>  314 :                 pstream__ = nullptr) const { #>  315 :     using T__ = stan::scalar_type_t<VecR>; #>  316 :     using local_scalar_t__ = T__; #>  317 :     T__ lp__(0.0); #>  318 :     stan::math::accumulator<T__> lp_accum__; #>  319 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  320 :     int current_statement__ = 0; #>  321 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  322 :     // suppress unused var warning #>  323 :     (void) DUMMY_VAR__; #>  324 :     static constexpr const char* function__ = #>  325 :       \"model1ed761d7bcb2__namespace::log_prob\"; #>  326 :     // suppress unused var warning #>  327 :     (void) function__; #>  328 :     try { #>  329 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  330 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  331 :           DUMMY_VAR__); #>  332 :       current_statement__ = 1; #>  333 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  334 :              w1_2dim__); #>  335 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  336 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  337 :           DUMMY_VAR__); #>  338 :       current_statement__ = 2; #>  339 :       b1 = in__.template read< #>  340 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__); #>  341 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  342 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  343 :           DUMMY_VAR__); #>  344 :       current_statement__ = 3; #>  345 :       w2 = in__.template read< #>  346 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, w2_2dim__); #>  347 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  348 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  349 :           DUMMY_VAR__); #>  350 :       current_statement__ = 4; #>  351 :       b2 = in__.template read< #>  352 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__); #>  353 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  354 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  355 :           DUMMY_VAR__); #>  356 :       current_statement__ = 5; #>  357 :       w_out = in__.template read< #>  358 :                 Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__); #>  359 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  360 :       current_statement__ = 6; #>  361 :       b_out = in__.template read<local_scalar_t__>(); #>  362 :       Eigen::Matrix<local_scalar_t__,-1,-1> z1 = #>  363 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z1_2dim__, #>  364 :           DUMMY_VAR__); #>  365 :       Eigen::Matrix<local_scalar_t__,-1,-1> a1 = #>  366 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a1_2dim__, #>  367 :           DUMMY_VAR__); #>  368 :       Eigen::Matrix<local_scalar_t__,-1,-1> z2 = #>  369 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z2_2dim__, #>  370 :           DUMMY_VAR__); #>  371 :       Eigen::Matrix<local_scalar_t__,-1,-1> a2 = #>  372 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a2_2dim__, #>  373 :           DUMMY_VAR__); #>  374 :       Eigen::Matrix<local_scalar_t__,-1,1> y_hat = #>  375 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n, DUMMY_VAR__); #>  376 :       current_statement__ = 12; #>  377 :       stan::model::assign(z1, #>  378 :         stan::math::add(stan::math::multiply(X, w1), #>  379 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  380 :         \"assigning variable z1\"); #>  381 :       current_statement__ = 19; #>  382 :       if (stan::math::logical_eq( #>  383 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  384 :             1)) { #>  385 :         current_statement__ = 18; #>  386 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  387 :       } else { #>  388 :         current_statement__ = 17; #>  389 :         if (stan::math::logical_eq( #>  390 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  391 :               2)) { #>  392 :           current_statement__ = 16; #>  393 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  394 :             \"assigning variable a1\"); #>  395 :         } else { #>  396 :           current_statement__ = 15; #>  397 :           if (stan::math::logical_eq( #>  398 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  399 :                   stan::model::index_uni(1)), 3)) { #>  400 :             current_statement__ = 14; #>  401 :             stan::model::assign(a1, #>  402 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  403 :               \"assigning variable a1\"); #>  404 :           } else { #>  405 :             current_statement__ = 13; #>  406 :             stan::model::assign(a1, #>  407 :               stan::math::fmax( #>  408 :                 stan::math::rep_matrix(0, n, #>  409 :                   stan::model::rvalue(nodes, \"nodes\", #>  410 :                     stan::model::index_uni(1))), z1), \"assigning variable a1\"); #>  411 :           } #>  412 :         } #>  413 :       } #>  414 :       current_statement__ = 20; #>  415 :       stan::model::assign(z2, #>  416 :         stan::math::add(stan::math::multiply(a1, w2), #>  417 :           stan::math::rep_matrix(stan::math::transpose(b2), n)), #>  418 :         \"assigning variable z2\"); #>  419 :       current_statement__ = 27; #>  420 :       if (stan::math::logical_eq( #>  421 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  422 :             1)) { #>  423 :         current_statement__ = 26; #>  424 :         stan::model::assign(a2, stan::math::tanh(z2), \"assigning variable a2\"); #>  425 :       } else { #>  426 :         current_statement__ = 25; #>  427 :         if (stan::math::logical_eq( #>  428 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  429 :               2)) { #>  430 :           current_statement__ = 24; #>  431 :           stan::model::assign(a2, stan::math::inv_logit(z2), #>  432 :             \"assigning variable a2\"); #>  433 :         } else { #>  434 :           current_statement__ = 23; #>  435 :           if (stan::math::logical_eq( #>  436 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  437 :                   stan::model::index_uni(2)), 3)) { #>  438 :             current_statement__ = 22; #>  439 :             stan::model::assign(a2, #>  440 :               stan::math::log(stan::math::add(1, stan::math::exp(z2))), #>  441 :               \"assigning variable a2\"); #>  442 :           } else { #>  443 :             current_statement__ = 21; #>  444 :             stan::model::assign(a2, #>  445 :               stan::math::fmax( #>  446 :                 stan::math::rep_matrix(0, n, #>  447 :                   stan::model::rvalue(nodes, \"nodes\", #>  448 :                     stan::model::index_uni(2))), z2), \"assigning variable a2\"); #>  449 :           } #>  450 :         } #>  451 :       } #>  452 :       current_statement__ = 28; #>  453 :       stan::model::assign(y_hat, #>  454 :         stan::math::add(stan::math::multiply(a2, w_out), b_out), #>  455 :         \"assigning variable y_hat\"); #>  456 :       { #>  457 :         current_statement__ = 29; #>  458 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  459 :                          stan::math::to_vector(w1), 0, 1)); #>  460 :         current_statement__ = 30; #>  461 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b1, 0, 1)); #>  462 :         current_statement__ = 31; #>  463 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  464 :                          stan::math::to_vector(w2), 0, 1)); #>  465 :         current_statement__ = 32; #>  466 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b2, 0, 1)); #>  467 :         current_statement__ = 33; #>  468 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(w_out, 0, 1)); #>  469 :         current_statement__ = 34; #>  470 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b_out, 0, 1)); #>  471 :         current_statement__ = 35; #>  472 :         lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(y, y_hat)); #>  473 :       } #>  474 :     } catch (const std::exception& e) { #>  475 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  476 :     } #>  477 :     lp_accum__.add(lp__); #>  478 :     return lp_accum__.sum(); #>  479 :   } #>  480 :   template <typename RNG, typename VecR, typename VecI, typename VecVar, #>  481 :             stan::require_vector_like_vt<std::is_floating_point, #>  482 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, #>  483 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point, #>  484 :             VecVar>* = nullptr> #>  485 :   inline void #>  486 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__, #>  487 :                    VecVar& vars__, const bool #>  488 :                    emit_transformed_parameters__ = true, const bool #>  489 :                    emit_generated_quantities__ = true, std::ostream* #>  490 :                    pstream__ = nullptr) const { #>  491 :     using local_scalar_t__ = double; #>  492 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  493 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  494 :     static constexpr bool propto__ = true; #>  495 :     // suppress unused var warning #>  496 :     (void) propto__; #>  497 :     double lp__ = 0.0; #>  498 :     // suppress unused var warning #>  499 :     (void) lp__; #>  500 :     int current_statement__ = 0; #>  501 :     stan::math::accumulator<double> lp_accum__; #>  502 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  503 :     // suppress unused var warning #>  504 :     (void) DUMMY_VAR__; #>  505 :     constexpr bool jacobian__ = false; #>  506 :     static constexpr const char* function__ = #>  507 :       \"model1ed761d7bcb2__namespace::write_array\"; #>  508 :     // suppress unused var warning #>  509 :     (void) function__; #>  510 :     try { #>  511 :       Eigen::Matrix<double,-1,-1> w1 = #>  512 :         Eigen::Matrix<double,-1,-1>::Constant(m, w1_2dim__, #>  513 :           std::numeric_limits<double>::quiet_NaN()); #>  514 :       current_statement__ = 1; #>  515 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  516 :              w1_2dim__); #>  517 :       Eigen::Matrix<double,-1,1> b1 = #>  518 :         Eigen::Matrix<double,-1,1>::Constant(b1_1dim__, #>  519 :           std::numeric_limits<double>::quiet_NaN()); #>  520 :       current_statement__ = 2; #>  521 :       b1 = in__.template read< #>  522 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__); #>  523 :       Eigen::Matrix<double,-1,-1> w2 = #>  524 :         Eigen::Matrix<double,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  525 :           std::numeric_limits<double>::quiet_NaN()); #>  526 :       current_statement__ = 3; #>  527 :       w2 = in__.template read< #>  528 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, w2_2dim__); #>  529 :       Eigen::Matrix<double,-1,1> b2 = #>  530 :         Eigen::Matrix<double,-1,1>::Constant(b2_1dim__, #>  531 :           std::numeric_limits<double>::quiet_NaN()); #>  532 :       current_statement__ = 4; #>  533 :       b2 = in__.template read< #>  534 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__); #>  535 :       Eigen::Matrix<double,-1,1> w_out = #>  536 :         Eigen::Matrix<double,-1,1>::Constant(w_out_1dim__, #>  537 :           std::numeric_limits<double>::quiet_NaN()); #>  538 :       current_statement__ = 5; #>  539 :       w_out = in__.template read< #>  540 :                 Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__); #>  541 :       double b_out = std::numeric_limits<double>::quiet_NaN(); #>  542 :       current_statement__ = 6; #>  543 :       b_out = in__.template read<local_scalar_t__>(); #>  544 :       Eigen::Matrix<double,-1,-1> z1 = #>  545 :         Eigen::Matrix<double,-1,-1>::Constant(n, z1_2dim__, #>  546 :           std::numeric_limits<double>::quiet_NaN()); #>  547 :       Eigen::Matrix<double,-1,-1> a1 = #>  548 :         Eigen::Matrix<double,-1,-1>::Constant(n, a1_2dim__, #>  549 :           std::numeric_limits<double>::quiet_NaN()); #>  550 :       Eigen::Matrix<double,-1,-1> z2 = #>  551 :         Eigen::Matrix<double,-1,-1>::Constant(n, z2_2dim__, #>  552 :           std::numeric_limits<double>::quiet_NaN()); #>  553 :       Eigen::Matrix<double,-1,-1> a2 = #>  554 :         Eigen::Matrix<double,-1,-1>::Constant(n, a2_2dim__, #>  555 :           std::numeric_limits<double>::quiet_NaN()); #>  556 :       Eigen::Matrix<double,-1,1> y_hat = #>  557 :         Eigen::Matrix<double,-1,1>::Constant(n, #>  558 :           std::numeric_limits<double>::quiet_NaN()); #>  559 :       out__.write(w1); #>  560 :       out__.write(b1); #>  561 :       out__.write(w2); #>  562 :       out__.write(b2); #>  563 :       out__.write(w_out); #>  564 :       out__.write(b_out); #>  565 :       if (stan::math::logical_negation( #>  566 :             (stan::math::primitive_value(emit_transformed_parameters__) || #>  567 :             stan::math::primitive_value(emit_generated_quantities__)))) { #>  568 :         return ; #>  569 :       } #>  570 :       current_statement__ = 12; #>  571 :       stan::model::assign(z1, #>  572 :         stan::math::add(stan::math::multiply(X, w1), #>  573 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  574 :         \"assigning variable z1\"); #>  575 :       current_statement__ = 19; #>  576 :       if (stan::math::logical_eq( #>  577 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  578 :             1)) { #>  579 :         current_statement__ = 18; #>  580 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  581 :       } else { #>  582 :         current_statement__ = 17; #>  583 :         if (stan::math::logical_eq( #>  584 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  585 :               2)) { #>  586 :           current_statement__ = 16; #>  587 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  588 :             \"assigning variable a1\"); #>  589 :         } else { #>  590 :           current_statement__ = 15; #>  591 :           if (stan::math::logical_eq( #>  592 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  593 :                   stan::model::index_uni(1)), 3)) { #>  594 :             current_statement__ = 14; #>  595 :             stan::model::assign(a1, #>  596 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  597 :               \"assigning variable a1\"); #>  598 :           } else { #>  599 :             current_statement__ = 13; #>  600 :             stan::model::assign(a1, #>  601 :               stan::math::fmax( #>  602 :                 stan::math::rep_matrix(0, n, #>  603 :                   stan::model::rvalue(nodes, \"nodes\", #>  604 :                     stan::model::index_uni(1))), z1), \"assigning variable a1\"); #>  605 :           } #>  606 :         } #>  607 :       } #>  608 :       current_statement__ = 20; #>  609 :       stan::model::assign(z2, #>  610 :         stan::math::add(stan::math::multiply(a1, w2), #>  611 :           stan::math::rep_matrix(stan::math::transpose(b2), n)), #>  612 :         \"assigning variable z2\"); #>  613 :       current_statement__ = 27; #>  614 :       if (stan::math::logical_eq( #>  615 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  616 :             1)) { #>  617 :         current_statement__ = 26; #>  618 :         stan::model::assign(a2, stan::math::tanh(z2), \"assigning variable a2\"); #>  619 :       } else { #>  620 :         current_statement__ = 25; #>  621 :         if (stan::math::logical_eq( #>  622 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  623 :               2)) { #>  624 :           current_statement__ = 24; #>  625 :           stan::model::assign(a2, stan::math::inv_logit(z2), #>  626 :             \"assigning variable a2\"); #>  627 :         } else { #>  628 :           current_statement__ = 23; #>  629 :           if (stan::math::logical_eq( #>  630 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  631 :                   stan::model::index_uni(2)), 3)) { #>  632 :             current_statement__ = 22; #>  633 :             stan::model::assign(a2, #>  634 :               stan::math::log(stan::math::add(1, stan::math::exp(z2))), #>  635 :               \"assigning variable a2\"); #>  636 :           } else { #>  637 :             current_statement__ = 21; #>  638 :             stan::model::assign(a2, #>  639 :               stan::math::fmax( #>  640 :                 stan::math::rep_matrix(0, n, #>  641 :                   stan::model::rvalue(nodes, \"nodes\", #>  642 :                     stan::model::index_uni(2))), z2), \"assigning variable a2\"); #>  643 :           } #>  644 :         } #>  645 :       } #>  646 :       current_statement__ = 28; #>  647 :       stan::model::assign(y_hat, #>  648 :         stan::math::add(stan::math::multiply(a2, w_out), b_out), #>  649 :         \"assigning variable y_hat\"); #>  650 :       if (emit_transformed_parameters__) { #>  651 :         out__.write(z1); #>  652 :         out__.write(a1); #>  653 :         out__.write(z2); #>  654 :         out__.write(a2); #>  655 :         out__.write(y_hat); #>  656 :       } #>  657 :       if (stan::math::logical_negation(emit_generated_quantities__)) { #>  658 :         return ; #>  659 :       } #>  660 :     } catch (const std::exception& e) { #>  661 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  662 :     } #>  663 :   } #>  664 :   template <typename VecVar, typename VecI, #>  665 :             stan::require_vector_t<VecVar>* = nullptr, #>  666 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  667 :   inline void #>  668 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__, #>  669 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const { #>  670 :     using local_scalar_t__ = double; #>  671 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  672 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  673 :     int current_statement__ = 0; #>  674 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  675 :     // suppress unused var warning #>  676 :     (void) DUMMY_VAR__; #>  677 :     try { #>  678 :       int pos__ = std::numeric_limits<int>::min(); #>  679 :       pos__ = 1; #>  680 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  681 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  682 :           DUMMY_VAR__); #>  683 :       current_statement__ = 1; #>  684 :       stan::model::assign(w1, #>  685 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, w1_2dim__), #>  686 :         \"assigning variable w1\"); #>  687 :       out__.write(w1); #>  688 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  689 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  690 :           DUMMY_VAR__); #>  691 :       current_statement__ = 2; #>  692 :       stan::model::assign(b1, #>  693 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__), #>  694 :         \"assigning variable b1\"); #>  695 :       out__.write(b1); #>  696 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  697 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  698 :           DUMMY_VAR__); #>  699 :       current_statement__ = 3; #>  700 :       stan::model::assign(w2, #>  701 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, #>  702 :           w2_2dim__), \"assigning variable w2\"); #>  703 :       out__.write(w2); #>  704 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  705 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  706 :           DUMMY_VAR__); #>  707 :       current_statement__ = 4; #>  708 :       stan::model::assign(b2, #>  709 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__), #>  710 :         \"assigning variable b2\"); #>  711 :       out__.write(b2); #>  712 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  713 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  714 :           DUMMY_VAR__); #>  715 :       current_statement__ = 5; #>  716 :       stan::model::assign(w_out, #>  717 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__), #>  718 :         \"assigning variable w_out\"); #>  719 :       out__.write(w_out); #>  720 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  721 :       current_statement__ = 6; #>  722 :       b_out = in__.read<local_scalar_t__>(); #>  723 :       out__.write(b_out); #>  724 :     } catch (const std::exception& e) { #>  725 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  726 :     } #>  727 :   } #>  728 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr> #>  729 :   inline void #>  730 :   transform_inits_impl(const stan::io::var_context& context__, VecVar& #>  731 :                        vars__, std::ostream* pstream__ = nullptr) const { #>  732 :     using local_scalar_t__ = double; #>  733 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  734 :     int current_statement__ = 0; #>  735 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  736 :     // suppress unused var warning #>  737 :     (void) DUMMY_VAR__; #>  738 :     try { #>  739 :       current_statement__ = 1; #>  740 :       context__.validate_dims(\"parameter initialization\", \"w1\", \"double\", #>  741 :         std::vector<size_t>{static_cast<size_t>(m), #>  742 :           static_cast<size_t>(w1_2dim__)}); #>  743 :       current_statement__ = 2; #>  744 :       context__.validate_dims(\"parameter initialization\", \"b1\", \"double\", #>  745 :         std::vector<size_t>{static_cast<size_t>(b1_1dim__)}); #>  746 :       current_statement__ = 3; #>  747 :       context__.validate_dims(\"parameter initialization\", \"w2\", \"double\", #>  748 :         std::vector<size_t>{static_cast<size_t>(w2_1dim__), #>  749 :           static_cast<size_t>(w2_2dim__)}); #>  750 :       current_statement__ = 4; #>  751 :       context__.validate_dims(\"parameter initialization\", \"b2\", \"double\", #>  752 :         std::vector<size_t>{static_cast<size_t>(b2_1dim__)}); #>  753 :       current_statement__ = 5; #>  754 :       context__.validate_dims(\"parameter initialization\", \"w_out\", \"double\", #>  755 :         std::vector<size_t>{static_cast<size_t>(w_out_1dim__)}); #>  756 :       current_statement__ = 6; #>  757 :       context__.validate_dims(\"parameter initialization\", \"b_out\", \"double\", #>  758 :         std::vector<size_t>{}); #>  759 :       int pos__ = std::numeric_limits<int>::min(); #>  760 :       pos__ = 1; #>  761 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  762 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  763 :           DUMMY_VAR__); #>  764 :       { #>  765 :         std::vector<local_scalar_t__> w1_flat__; #>  766 :         current_statement__ = 1; #>  767 :         w1_flat__ = context__.vals_r(\"w1\"); #>  768 :         current_statement__ = 1; #>  769 :         pos__ = 1; #>  770 :         current_statement__ = 1; #>  771 :         for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #>  772 :           current_statement__ = 1; #>  773 :           for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  774 :             current_statement__ = 1; #>  775 :             stan::model::assign(w1, w1_flat__[(pos__ - 1)], #>  776 :               \"assigning variable w1\", stan::model::index_uni(sym2__), #>  777 :               stan::model::index_uni(sym1__)); #>  778 :             current_statement__ = 1; #>  779 :             pos__ = (pos__ + 1); #>  780 :           } #>  781 :         } #>  782 :       } #>  783 :       out__.write(w1); #>  784 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  785 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  786 :           DUMMY_VAR__); #>  787 :       { #>  788 :         std::vector<local_scalar_t__> b1_flat__; #>  789 :         current_statement__ = 2; #>  790 :         b1_flat__ = context__.vals_r(\"b1\"); #>  791 :         current_statement__ = 2; #>  792 :         pos__ = 1; #>  793 :         current_statement__ = 2; #>  794 :         for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #>  795 :           current_statement__ = 2; #>  796 :           stan::model::assign(b1, b1_flat__[(pos__ - 1)], #>  797 :             \"assigning variable b1\", stan::model::index_uni(sym1__)); #>  798 :           current_statement__ = 2; #>  799 :           pos__ = (pos__ + 1); #>  800 :         } #>  801 :       } #>  802 :       out__.write(b1); #>  803 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  804 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  805 :           DUMMY_VAR__); #>  806 :       { #>  807 :         std::vector<local_scalar_t__> w2_flat__; #>  808 :         current_statement__ = 3; #>  809 :         w2_flat__ = context__.vals_r(\"w2\"); #>  810 :         current_statement__ = 3; #>  811 :         pos__ = 1; #>  812 :         current_statement__ = 3; #>  813 :         for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #>  814 :           current_statement__ = 3; #>  815 :           for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #>  816 :             current_statement__ = 3; #>  817 :             stan::model::assign(w2, w2_flat__[(pos__ - 1)], #>  818 :               \"assigning variable w2\", stan::model::index_uni(sym2__), #>  819 :               stan::model::index_uni(sym1__)); #>  820 :             current_statement__ = 3; #>  821 :             pos__ = (pos__ + 1); #>  822 :           } #>  823 :         } #>  824 :       } #>  825 :       out__.write(w2); #>  826 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  827 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  828 :           DUMMY_VAR__); #>  829 :       { #>  830 :         std::vector<local_scalar_t__> b2_flat__; #>  831 :         current_statement__ = 4; #>  832 :         b2_flat__ = context__.vals_r(\"b2\"); #>  833 :         current_statement__ = 4; #>  834 :         pos__ = 1; #>  835 :         current_statement__ = 4; #>  836 :         for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #>  837 :           current_statement__ = 4; #>  838 :           stan::model::assign(b2, b2_flat__[(pos__ - 1)], #>  839 :             \"assigning variable b2\", stan::model::index_uni(sym1__)); #>  840 :           current_statement__ = 4; #>  841 :           pos__ = (pos__ + 1); #>  842 :         } #>  843 :       } #>  844 :       out__.write(b2); #>  845 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  846 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  847 :           DUMMY_VAR__); #>  848 :       { #>  849 :         std::vector<local_scalar_t__> w_out_flat__; #>  850 :         current_statement__ = 5; #>  851 :         w_out_flat__ = context__.vals_r(\"w_out\"); #>  852 :         current_statement__ = 5; #>  853 :         pos__ = 1; #>  854 :         current_statement__ = 5; #>  855 :         for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #>  856 :           current_statement__ = 5; #>  857 :           stan::model::assign(w_out, w_out_flat__[(pos__ - 1)], #>  858 :             \"assigning variable w_out\", stan::model::index_uni(sym1__)); #>  859 :           current_statement__ = 5; #>  860 :           pos__ = (pos__ + 1); #>  861 :         } #>  862 :       } #>  863 :       out__.write(w_out); #>  864 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  865 :       current_statement__ = 6; #>  866 :       b_out = context__.vals_r(\"b_out\")[(1 - 1)]; #>  867 :       out__.write(b_out); #>  868 :     } catch (const std::exception& e) { #>  869 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  870 :     } #>  871 :   } #>  872 :   inline void #>  873 :   get_param_names(std::vector<std::string>& names__, const bool #>  874 :                   emit_transformed_parameters__ = true, const bool #>  875 :                   emit_generated_quantities__ = true) const { #>  876 :     names__ = std::vector<std::string>{\"w1\", \"b1\", \"w2\", \"b2\", \"w_out\", #>  877 :                 \"b_out\"}; #>  878 :     if (emit_transformed_parameters__) { #>  879 :       std::vector<std::string> temp{\"z1\", \"a1\", \"z2\", \"a2\", \"y_hat\"}; #>  880 :       names__.reserve(names__.size() + temp.size()); #>  881 :       names__.insert(names__.end(), temp.begin(), temp.end()); #>  882 :     } #>  883 :     if (emit_generated_quantities__) {} #>  884 :   } #>  885 :   inline void #>  886 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool #>  887 :            emit_transformed_parameters__ = true, const bool #>  888 :            emit_generated_quantities__ = true) const { #>  889 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast< #>  890 :                                                                     size_t>(m), #>  891 :                                                  static_cast<size_t>( #>  892 :                                                    w1_2dim__)}, #>  893 :                 std::vector<size_t>{static_cast<size_t>(b1_1dim__)}, #>  894 :                 std::vector<size_t>{static_cast<size_t>(w2_1dim__), #>  895 :                   static_cast<size_t>(w2_2dim__)}, #>  896 :                 std::vector<size_t>{static_cast<size_t>(b2_1dim__)}, #>  897 :                 std::vector<size_t>{static_cast<size_t>(w_out_1dim__)}, #>  898 :                 std::vector<size_t>{}}; #>  899 :     if (emit_transformed_parameters__) { #>  900 :       std::vector<std::vector<size_t>> #>  901 :         temp{std::vector<size_t>{static_cast<size_t>(n), #>  902 :                static_cast<size_t>(z1_2dim__)}, #>  903 :              std::vector<size_t>{static_cast<size_t>(n), #>  904 :                static_cast<size_t>(a1_2dim__)}, #>  905 :              std::vector<size_t>{static_cast<size_t>(n), #>  906 :                static_cast<size_t>(z2_2dim__)}, #>  907 :              std::vector<size_t>{static_cast<size_t>(n), #>  908 :                static_cast<size_t>(a2_2dim__)}, #>  909 :              std::vector<size_t>{static_cast<size_t>(n)}}; #>  910 :       dimss__.reserve(dimss__.size() + temp.size()); #>  911 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end()); #>  912 :     } #>  913 :     if (emit_generated_quantities__) {} #>  914 :   } #>  915 :   inline void #>  916 :   constrained_param_names(std::vector<std::string>& param_names__, bool #>  917 :                           emit_transformed_parameters__ = true, bool #>  918 :                           emit_generated_quantities__ = true) const final { #>  919 :     for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #>  920 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  921 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #>  922 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  923 :       } #>  924 :     } #>  925 :     for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #>  926 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #>  927 :         std::to_string(sym1__)); #>  928 :     } #>  929 :     for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #>  930 :       for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #>  931 :         param_names__.emplace_back(std::string() + \"w2\" + '.' + #>  932 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  933 :       } #>  934 :     } #>  935 :     for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #>  936 :       param_names__.emplace_back(std::string() + \"b2\" + '.' + #>  937 :         std::to_string(sym1__)); #>  938 :     } #>  939 :     for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #>  940 :       param_names__.emplace_back(std::string() + \"w_out\" + '.' + #>  941 :         std::to_string(sym1__)); #>  942 :     } #>  943 :     param_names__.emplace_back(std::string() + \"b_out\"); #>  944 :     if (emit_transformed_parameters__) { #>  945 :       for (int sym1__ = 1; sym1__ <= z1_2dim__; ++sym1__) { #>  946 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  947 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #>  948 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  949 :         } #>  950 :       } #>  951 :       for (int sym1__ = 1; sym1__ <= a1_2dim__; ++sym1__) { #>  952 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  953 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #>  954 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  955 :         } #>  956 :       } #>  957 :       for (int sym1__ = 1; sym1__ <= z2_2dim__; ++sym1__) { #>  958 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  959 :           param_names__.emplace_back(std::string() + \"z2\" + '.' + #>  960 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  961 :         } #>  962 :       } #>  963 :       for (int sym1__ = 1; sym1__ <= a2_2dim__; ++sym1__) { #>  964 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  965 :           param_names__.emplace_back(std::string() + \"a2\" + '.' + #>  966 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  967 :         } #>  968 :       } #>  969 :       for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #>  970 :         param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #>  971 :           std::to_string(sym1__)); #>  972 :       } #>  973 :     } #>  974 :     if (emit_generated_quantities__) {} #>  975 :   } #>  976 :   inline void #>  977 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool #>  978 :                             emit_transformed_parameters__ = true, bool #>  979 :                             emit_generated_quantities__ = true) const final { #>  980 :     for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #>  981 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  982 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #>  983 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  984 :       } #>  985 :     } #>  986 :     for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #>  987 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #>  988 :         std::to_string(sym1__)); #>  989 :     } #>  990 :     for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #>  991 :       for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #>  992 :         param_names__.emplace_back(std::string() + \"w2\" + '.' + #>  993 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  994 :       } #>  995 :     } #>  996 :     for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #>  997 :       param_names__.emplace_back(std::string() + \"b2\" + '.' + #>  998 :         std::to_string(sym1__)); #>  999 :     } #> 1000 :     for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #> 1001 :       param_names__.emplace_back(std::string() + \"w_out\" + '.' + #> 1002 :         std::to_string(sym1__)); #> 1003 :     } #> 1004 :     param_names__.emplace_back(std::string() + \"b_out\"); #> 1005 :     if (emit_transformed_parameters__) { #> 1006 :       for (int sym1__ = 1; sym1__ <= z1_2dim__; ++sym1__) { #> 1007 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1008 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #> 1009 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1010 :         } #> 1011 :       } #> 1012 :       for (int sym1__ = 1; sym1__ <= a1_2dim__; ++sym1__) { #> 1013 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1014 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #> 1015 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1016 :         } #> 1017 :       } #> 1018 :       for (int sym1__ = 1; sym1__ <= z2_2dim__; ++sym1__) { #> 1019 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1020 :           param_names__.emplace_back(std::string() + \"z2\" + '.' + #> 1021 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1022 :         } #> 1023 :       } #> 1024 :       for (int sym1__ = 1; sym1__ <= a2_2dim__; ++sym1__) { #> 1025 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1026 :           param_names__.emplace_back(std::string() + \"a2\" + '.' + #> 1027 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1028 :         } #> 1029 :       } #> 1030 :       for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #> 1031 :         param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #> 1032 :           std::to_string(sym1__)); #> 1033 :       } #> 1034 :     } #> 1035 :     if (emit_generated_quantities__) {} #> 1036 :   } #> 1037 :   inline std::string get_constrained_sizedtypes() const { #> 1038 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(w1_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b1_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w2_1dim__) + \",\\\"cols\\\":\" + std::to_string(w2_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b2\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b2_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(w_out_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(n) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #> 1039 :   } #> 1040 :   inline std::string get_unconstrained_sizedtypes() const { #> 1041 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(w1_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b1_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w2_1dim__) + \",\\\"cols\\\":\" + std::to_string(w2_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b2\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b2_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(w_out_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(n) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #> 1042 :   } #> 1043 :   // Begin method overload boilerplate #> 1044 :   template <typename RNG> inline void #> 1045 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r, #> 1046 :               Eigen::Matrix<double,-1,1>& vars, const bool #> 1047 :               emit_transformed_parameters = true, const bool #> 1048 :               emit_generated_quantities = true, std::ostream* #> 1049 :               pstream = nullptr) const { #> 1050 :     const size_t num_params__ = ((((((m * w1_2dim__) + b1_1dim__) + #> 1051 :       (w2_1dim__ * w2_2dim__)) + b2_1dim__) + w_out_1dim__) + 1); #> 1052 :     const size_t num_transformed = emit_transformed_parameters * ((((((n * #> 1053 :       z1_2dim__) + (n * a1_2dim__)) + (n * z2_2dim__)) + (n * a2_2dim__)) + #> 1054 :       n)); #> 1055 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #> 1056 :     const size_t num_to_write = num_params__ + num_transformed + #> 1057 :       num_gen_quantities; #> 1058 :     std::vector<int> params_i; #> 1059 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write, #> 1060 :              std::numeric_limits<double>::quiet_NaN()); #> 1061 :     write_array_impl(base_rng, params_r, params_i, vars, #> 1062 :       emit_transformed_parameters, emit_generated_quantities, pstream); #> 1063 :   } #> 1064 :   template <typename RNG> inline void #> 1065 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>& #> 1066 :               params_i, std::vector<double>& vars, bool #> 1067 :               emit_transformed_parameters = true, bool #> 1068 :               emit_generated_quantities = true, std::ostream* #> 1069 :               pstream = nullptr) const { #> 1070 :     const size_t num_params__ = ((((((m * w1_2dim__) + b1_1dim__) + #> 1071 :       (w2_1dim__ * w2_2dim__)) + b2_1dim__) + w_out_1dim__) + 1); #> 1072 :     const size_t num_transformed = emit_transformed_parameters * ((((((n * #> 1073 :       z1_2dim__) + (n * a1_2dim__)) + (n * z2_2dim__)) + (n * a2_2dim__)) + #> 1074 :       n)); #> 1075 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #> 1076 :     const size_t num_to_write = num_params__ + num_transformed + #> 1077 :       num_gen_quantities; #> 1078 :     vars = std::vector<double>(num_to_write, #> 1079 :              std::numeric_limits<double>::quiet_NaN()); #> 1080 :     write_array_impl(base_rng, params_r, params_i, vars, #> 1081 :       emit_transformed_parameters, emit_generated_quantities, pstream); #> 1082 :   } #> 1083 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #> 1084 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const { #> 1085 :     Eigen::Matrix<int,-1,1> params_i; #> 1086 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #> 1087 :   } #> 1088 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #> 1089 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i, #> 1090 :            std::ostream* pstream = nullptr) const { #> 1091 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #> 1092 :   } #> 1093 :   inline void #> 1094 :   transform_inits(const stan::io::var_context& context, #> 1095 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream* #> 1096 :                   pstream = nullptr) const final { #> 1097 :     std::vector<double> params_r_vec(params_r.size()); #> 1098 :     std::vector<int> params_i; #> 1099 :     transform_inits(context, params_i, params_r_vec, pstream); #> 1100 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(), #> 1101 :                  params_r_vec.size()); #> 1102 :   } #> 1103 :   inline void #> 1104 :   transform_inits(const stan::io::var_context& context, std::vector<int>& #> 1105 :                   params_i, std::vector<double>& vars, std::ostream* #> 1106 :                   pstream__ = nullptr) const { #> 1107 :     vars.resize(num_params_r__); #> 1108 :     transform_inits_impl(context, vars, pstream__); #> 1109 :   } #> 1110 :   inline void #> 1111 :   unconstrain_array(const std::vector<double>& params_constrained, #> 1112 :                     std::vector<double>& params_unconstrained, std::ostream* #> 1113 :                     pstream = nullptr) const { #> 1114 :     const std::vector<int> params_i; #> 1115 :     params_unconstrained = std::vector<double>(num_params_r__, #> 1116 :                              std::numeric_limits<double>::quiet_NaN()); #> 1117 :     unconstrain_array_impl(params_constrained, params_i, #> 1118 :       params_unconstrained, pstream); #> 1119 :   } #> 1120 :   inline void #> 1121 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained, #> 1122 :                     Eigen::Matrix<double,-1,1>& params_unconstrained, #> 1123 :                     std::ostream* pstream = nullptr) const { #> 1124 :     const std::vector<int> params_i; #> 1125 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__, #> 1126 :                              std::numeric_limits<double>::quiet_NaN()); #> 1127 :     unconstrain_array_impl(params_constrained, params_i, #> 1128 :       params_unconstrained, pstream); #> 1129 :   } #> 1130 : }; #> 1131 : } #> 1132 : using stan_model = model1ed761d7bcb2__namespace::model1ed761d7bcb2_; #> 1133 : #ifndef USING_R #> 1134 : // Boilerplate #> 1135 : stan::model::model_base& #> 1136 : new_model(stan::io::var_context& data_context, unsigned int seed, #> 1137 :           std::ostream* msg_stream) { #> 1138 :   stan_model* m = new stan_model(data_context, seed, msg_stream); #> 1139 :   return *m; #> 1140 : } #> 1141 : stan::math::profile_map& get_stan_profile_data() { #> 1142 :   return model1ed761d7bcb2__namespace::profiles__; #> 1143 : } #> 1144 : #endif #> 1145 : #endif #> 1146 :  #> 1147 : RCPP_MODULE(stan_fit4model1ed761d7bcb2__mod) { #> 1148 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >( #> 1149 :       \"stan_fit4model1ed761d7bcb2_\") #> 1150 :  #> 1151 :       .constructor<SEXP, SEXP, SEXP>() #> 1152 :  #> 1153 :       .method( #> 1154 :           \"call_sampler\", #> 1155 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler) #> 1156 :       .method( #> 1157 :           \"param_names\", #> 1158 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names) #> 1159 :       .method(\"param_names_oi\", #> 1160 :               &rstan::stan_fit<stan_model, #> 1161 :                                boost::random::ecuyer1988>::param_names_oi) #> 1162 :       .method(\"param_fnames_oi\", #> 1163 :               &rstan::stan_fit<stan_model, #> 1164 :                                boost::random::ecuyer1988>::param_fnames_oi) #> 1165 :       .method( #> 1166 :           \"param_dims\", #> 1167 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims) #> 1168 :       .method(\"param_dims_oi\", #> 1169 :               &rstan::stan_fit<stan_model, #> 1170 :                                boost::random::ecuyer1988>::param_dims_oi) #> 1171 :       .method(\"update_param_oi\", #> 1172 :               &rstan::stan_fit<stan_model, #> 1173 :                                boost::random::ecuyer1988>::update_param_oi) #> 1174 :       .method(\"param_oi_tidx\", #> 1175 :               &rstan::stan_fit<stan_model, #> 1176 :                                boost::random::ecuyer1988>::param_oi_tidx) #> 1177 :       .method(\"grad_log_prob\", #> 1178 :               &rstan::stan_fit<stan_model, #> 1179 :                                boost::random::ecuyer1988>::grad_log_prob) #> 1180 :       .method(\"log_prob\", #> 1181 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob) #> 1182 :       .method(\"unconstrain_pars\", #> 1183 :               &rstan::stan_fit<stan_model, #> 1184 :                                boost::random::ecuyer1988>::unconstrain_pars) #> 1185 :       .method(\"constrain_pars\", #> 1186 :               &rstan::stan_fit<stan_model, #> 1187 :                                boost::random::ecuyer1988>::constrain_pars) #> 1188 :       .method( #> 1189 :           \"num_pars_unconstrained\", #> 1190 :           &rstan::stan_fit<stan_model, #> 1191 :                            boost::random::ecuyer1988>::num_pars_unconstrained) #> 1192 :       .method( #> 1193 :           \"unconstrained_param_names\", #> 1194 :           &rstan::stan_fit< #> 1195 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names) #> 1196 :       .method( #> 1197 :           \"constrained_param_names\", #> 1198 :           &rstan::stan_fit<stan_model, #> 1199 :                            boost::random::ecuyer1988>::constrained_param_names) #> 1200 :       .method(\"standalone_gqs\", #> 1201 :               &rstan::stan_fit<stan_model, #> 1202 :                                boost::random::ecuyer1988>::standalone_gqs); #> 1203 : } #> 1204 :  #> 1205 :  #> 1206 : // declarations #> 1207 : extern \"C\" { #> 1208 : SEXP file1ed774a7e85c( ) ; #> 1209 : } #> 1210 :  #> 1211 : // definition #> 1212 : SEXP file1ed774a7e85c() { #> 1213 :  return Rcpp::wrap(\"anon_model\"); #> 1214 : } #>  #> CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW. #>  #> COMPILING MODEL 'anon_model' NOW. #>  #> STARTING SAMPLER FOR MODEL 'anon_model' NOW."},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"generating-predictions-with-uncertainty","dir":"Articles","previous_headings":"3. Posterior Predictions","what":"Generating Predictions with Uncertainty","title":"Using Bayesian Neural Networks in Clinical Trials","text":"posterior distribution predictions allows us compute just point estimates also probabilistic metrics. entry posterior_preds represents predicted probability success single posterior sample.","code":"# Generate posterior predictions for the test set posterior_preds <- predict(model, subset(test_data, select = -Success)) head(posterior_preds)  # Each row corresponds to a subject, and columns are MCMC samples #>            [,1]       [,2]      [,3]       [,4]       [,5]       [,6] #> [1,] 0.96540544 0.95044320 0.8639886 0.96879020 0.98577016 0.91495821 #> [2,] 0.09688536 0.06496306 0.1532583 0.07583279 0.14705369 0.07804768 #> [3,] 0.09675958 0.06181107 0.1593923 0.06540429 0.04992526 0.07813405 #> [4,] 0.96193539 0.95000504 0.8940085 0.96884265 0.98240236 0.83258184 #> [5,] 0.68115868 0.75774754 0.5764709 0.73318432 0.27430942 0.21909992 #> [6,] 0.07057784 0.05950760 0.1502669 0.11169427 0.04545387 0.11796825 #>            [,7]      [,8]       [,9]      [,10]      [,11]      [,12] #> [1,] 0.91970037 0.9221397 0.88580751 0.95538568 0.95021834 0.97381018 #> [2,] 0.09188143 0.1029894 0.18901170 0.04338679 0.09741205 0.07900010 #> [3,] 0.09100565 0.1090577 0.07081170 0.05436160 0.11282616 0.04564657 #> [4,] 0.91749136 0.9223156 0.88379427 0.91494129 0.95010117 0.97329536 #> [5,] 0.47061066 0.6083129 0.41133933 0.88552859 0.92940934 0.59757302 #> [6,] 0.07193414 0.1151133 0.07100077 0.02440260 0.09933909 0.03240259 #>           [,13]      [,14]      [,15]      [,16]     [,17]      [,18] #> [1,] 0.96359538 0.95126412 0.95958453 0.98799108 0.9450177 0.88252517 #> [2,] 0.10932841 0.07730268 0.15265533 0.12565185 0.2559873 0.05112108 #> [3,] 0.07485027 0.07896275 0.15455183 0.05483277 0.2212894 0.06512479 #> [4,] 0.96320307 0.95126325 0.95917550 0.99033757 0.9428492 0.90678143 #> [5,] 0.42113683 0.73394715 0.72664563 0.60914730 0.8371144 0.75588868 #> [6,] 0.07236551 0.10405776 0.07834502 0.04424655 0.1853769 0.06173186 #>           [,19]      [,20]     [,21]      [,22]     [,23]     [,24]     [,25] #> [1,] 0.94826062 0.98336299 0.9483871 0.93820027 0.9389601 0.8570123 0.9250233 #> [2,] 0.06410978 0.08864533 0.1461942 0.05711957 0.1273991 0.2108441 0.1825022 #> [3,] 0.09552574 0.10258413 0.1546943 0.05010718 0.1128786 0.2106688 0.1824316 #> [4,] 0.92006090 0.95337677 0.9473623 0.92913291 0.9388833 0.8570123 0.8475761 #> [5,] 0.27954728 0.42333314 0.5446129 0.09064981 0.8259752 0.2227564 0.7611848 #> [6,] 0.11198219 0.10121687 0.1339196 0.04884905 0.1020319 0.2259007 0.1799139 #>           [,26]      [,27]      [,28]     [,29]      [,30]     [,31]      [,32] #> [1,] 0.95188447 0.93614653 0.97915223 0.9538411 0.88670961 0.8164815 0.93448124 #> [2,] 0.01876517 0.05159579 0.06854279 0.1419617 0.07576468 0.2072758 0.05282613 #> [3,] 0.02228304 0.09136696 0.07607244 0.1582908 0.07623292 0.2078918 0.02751751 #> [4,] 0.95186947 0.88334698 0.96920041 0.9211345 0.91911254 0.8163489 0.89772796 #> [5,] 0.33119388 0.82013013 0.91679389 0.8649880 0.55718589 0.4057789 0.47736025 #> [6,] 0.02640083 0.06031167 0.06703606 0.2051299 0.10078710 0.2690523 0.02637232 #>           [,33]      [,34]      [,35]      [,36]     [,37]      [,38]     [,39] #> [1,] 0.83093886 0.95971761 0.93211563 0.88909075 0.8603917 0.76933197 0.9691211 #> [2,] 0.09073357 0.06147170 0.39366445 0.02375625 0.1003205 0.02742836 0.1592738 #> [3,] 0.09145168 0.07648255 0.17540935 0.09414987 0.1008062 0.03542751 0.2768682 #> [4,] 0.83087890 0.95971782 0.91909721 0.88012789 0.8584144 0.76907414 0.9541437 #> [5,] 0.60638296 0.66572018 0.27103498 0.55118557 0.3606970 0.76177210 0.7496194 #> [6,] 0.09142162 0.06127533 0.06807762 0.04178248 0.1006602 0.02757636 0.2818228 #>          [,40]      [,41]      [,42]      [,43]      [,44]      [,45]     [,46] #> [1,] 0.9547982 0.95037079 0.92166620 0.96033781 0.93690596 0.90981579 0.9541870 #> [2,] 0.1616560 0.02956163 0.16796344 0.09085240 0.06798811 0.18927290 0.1528603 #> [3,] 0.3765773 0.21686511 0.07366499 0.11647928 0.22042299 0.13124826 0.0427016 #> [4,] 0.9222772 0.91899709 0.91848922 0.95256125 0.93586722 0.88273197 0.9541605 #> [5,] 0.5919946 0.65550849 0.28096960 0.44855007 0.84793377 0.74355243 0.6887550 #> [6,] 0.3604606 0.10205964 0.11808435 0.04244795 0.07758123 0.08522386 0.1028810 #>          [,47]     [,48]      [,49]      [,50]     [,51]      [,52]      [,53] #> [1,] 0.9576554 0.9101893 0.94068344 0.90658425 0.9822602 0.93841203 0.97492818 #> [2,] 0.1544121 0.1149193 0.40425935 0.03521565 0.1213527 0.11673252 0.12358277 #> [3,] 0.1565894 0.1129824 0.10429327 0.07006517 0.2124452 0.08649589 0.07277895 #> [4,] 0.8989994 0.8882882 0.94057337 0.90351073 0.9694353 0.94627329 0.97499294 #> [5,] 0.7790926 0.6578412 0.80367070 0.72008646 0.7476535 0.89526535 0.83792639 #> [6,] 0.1693040 0.1175729 0.07729776 0.03138329 0.1384847 0.06878357 0.03527414 #>           [,54]      [,55]      [,56]     [,57]     [,58]     [,59]     [,60] #> [1,] 0.98383313 0.95113976 0.95197720 0.9527216 0.9059660 0.9190505 0.9461210 #> [2,] 0.05476457 0.08204913 0.04073058 0.1387682 0.1427125 0.1526169 0.1422422 #> [3,] 0.13782449 0.08187902 0.17493907 0.1493934 0.1116551 0.1781386 0.1419542 #> [4,] 0.95459042 0.85641502 0.94918490 0.9527074 0.7854650 0.9188180 0.9556160 #> [5,] 0.91215866 0.51332833 0.60336654 0.6710783 0.4423166 0.5072204 0.3642702 #> [6,] 0.05787978 0.05142583 0.12551438 0.1256664 0.1999366 0.1013064 0.1411693 #>           [,61]      [,62]     [,63]     [,64]      [,65]     [,66]     [,67] #> [1,] 0.97297608 0.92761103 0.9340773 0.8931508 0.91332400 0.9330873 0.9652784 #> [2,] 0.11865216 0.06609694 0.1838781 0.1982891 0.07492102 0.1077329 0.1316126 #> [3,] 0.11776046 0.05661459 0.1868778 0.2053042 0.11121704 0.1145630 0.1776378 #> [4,] 0.97273670 0.92761047 0.9340964 0.8926439 0.89378463 0.9330872 0.9648835 #> [5,] 0.88924304 0.65641849 0.8038999 0.4518240 0.77241344 0.4235814 0.6865889 #> [6,] 0.02654554 0.12930304 0.2296690 0.2872912 0.05346084 0.0677504 0.3568487 #>           [,68]      [,69]      [,70]     [,71]     [,72]     [,73]     [,74] #> [1,] 0.92044419 0.95360552 0.91742259 0.9603671 0.9011607 0.9293669 0.9518035 #> [2,] 0.10997617 0.06315939 0.04969016 0.2055474 0.1296130 0.1954525 0.3168879 #> [3,] 0.07243965 0.14972664 0.06168066 0.2059193 0.1120620 0.2394636 0.1213549 #> [4,] 0.91935129 0.94598885 0.91739252 0.9360937 0.8715837 0.9274860 0.9252328 #> [5,] 0.48406376 0.77604624 0.64267045 0.5155509 0.4245891 0.6373298 0.5717879 #> [6,] 0.05254762 0.05192679 0.04272127 0.1951705 0.1065209 0.1921952 0.1211906 #>           [,75]     [,76]      [,77]      [,78]      [,79]      [,80] #> [1,] 0.87635713 0.8568571 0.96650912 0.91656721 0.94490384 0.91249512 #> [2,] 0.07195412 0.1425923 0.06183125 0.22982447 0.10470599 0.09691140 #> [3,] 0.02586769 0.2166740 0.07803220 0.05468524 0.08515729 0.05646500 #> [4,] 0.87695772 0.7810638 0.96175475 0.94324038 0.93478241 0.91013212 #> [5,] 0.34412490 0.2976378 0.82180155 0.49798637 0.73349326 0.67166452 #> [6,] 0.01486669 0.2196317 0.07460268 0.04211082 0.04942317 0.07528487 #>           [,81]      [,82]      [,83]      [,84]      [,85]     [,86]     [,87] #> [1,] 0.91512323 0.96491291 0.93471399 0.98202096 0.94580631 0.9730071 0.9337858 #> [2,] 0.05075558 0.12075168 0.03546805 0.02021273 0.09364063 0.1727534 0.3168863 #> [3,] 0.08794212 0.09777358 0.06782028 0.01877231 0.07849459 0.1057670 0.1270849 #> [4,] 0.91473128 0.91455824 0.93214157 0.93430726 0.94321209 0.9653030 0.9337718 #> [5,] 0.55106586 0.37803663 0.73598917 0.41895573 0.37841744 0.5783605 0.5043067 #> [6,] 0.06142090 0.10363458 0.18268001 0.01559951 0.05331637 0.1052707 0.1353831 #>          [,88]      [,89]      [,90]      [,91]      [,92]      [,93]     [,94] #> [1,] 0.9547971 0.93396078 0.98278828 0.95599724 0.90337300 0.95117991 0.9728767 #> [2,] 0.1052705 0.05474521 0.05936686 0.06852273 0.05322308 0.14456716 0.1623113 #> [3,] 0.1055129 0.04890935 0.06172718 0.30145168 0.02806611 0.09862832 0.1634386 #> [4,] 0.9534533 0.93393227 0.93171386 0.85411298 0.88155150 0.95036190 0.9663756 #> [5,] 0.8558363 0.67508992 0.29369107 0.63225527 0.44654522 0.45478921 0.6767925 #> [6,] 0.1049393 0.05188726 0.04856018 0.40247117 0.01370030 0.11224624 0.1886304 #>           [,95]      [,96]     [,97]     [,98]      [,99]     [,100] #> [1,] 0.90519402 0.97847860 0.8667449 0.9292480 0.93847974 0.97328000 #> [2,] 0.13622565 0.02675568 0.1620797 0.1151109 0.19191475 0.30049688 #> [3,] 0.13893618 0.01671995 0.1633061 0.1315142 0.11594363 0.17654239 #> [4,] 0.88949203 0.93622344 0.8611769 0.9285513 0.93843010 0.95527090 #> [5,] 0.54586348 0.84606755 0.7877992 0.2889200 0.70493744 0.47552655 #> [6,] 0.09729015 0.01130216 0.1614773 0.1149471 0.05747413 0.08714658"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"threshold-based-decision-making","dir":"Articles","previous_headings":"4. Posterior Probability of Treatment Success","what":"Threshold-Based Decision-Making","title":"Using Bayesian Neural Networks in Clinical Trials","text":"Suppose define treatment success predicted probability ≥ 0.6. can compute posterior probability threshold met subject.","code":"# Compute posterior probabilities of success (p_hat ≥ 0.6) success_threshold <- 0.6 posterior_probs_success <- rowMeans(posterior_preds >= success_threshold) head(posterior_probs_success) #> [1] 1.00 0.00 0.00 1.00 0.53 0.00"},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"proportion-of-subjects-likely-to-achieve-success","dir":"Articles","previous_headings":"4. Posterior Probability of Treatment Success","what":"Proportion of Subjects Likely to Achieve Success","title":"Using Bayesian Neural Networks in Clinical Trials","text":"Next, calculate posterior probability certain proportion subjects treatment group achieve success.","code":"# Define success proportion threshold prop_success_threshold <- 0.7  # Simulate posterior proportion of success posterior_success_proportion <- colMeans(posterior_preds >= success_threshold)  # Posterior probability that ≥ 70% of subjects achieve success posterior_prob_high_success <- mean(posterior_success_proportion >= prop_success_threshold) posterior_prob_high_success #> [1] 0"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"posterior-predictive-distribution","dir":"Articles","previous_headings":"5. Visualizing Posterior Insights","what":"Posterior Predictive Distribution","title":"Using Bayesian Neural Networks in Clinical Trials","text":"","code":"library(ggplot2)  # Plot posterior probabilities of success for individual subjects ggplot(data.frame(Subject = 1:nrow(test_data), Prob = posterior_probs_success), aes(x = Subject, y = Prob)) +   geom_bar(stat = \"identity\", fill = \"blue\") +   geom_hline(yintercept = success_threshold, color = \"red\", linetype = \"dashed\") +   labs(     title = \"Posterior Probability of Treatment Success\",     x = \"Subject\",     y = \"Posterior Probability\"   )"},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"distribution-of-success-proportion","dir":"Articles","previous_headings":"5. Visualizing Posterior Insights","what":"Distribution of Success Proportion","title":"Using Bayesian Neural Networks in Clinical Trials","text":"","code":"# Histogram of posterior success proportions ggplot(data.frame(SuccessProp = posterior_success_proportion), aes(x = SuccessProp)) +   geom_histogram(fill = \"green\", bins = 20) +   geom_vline(xintercept = prop_success_threshold, color = \"red\", linetype = \"dashed\") +   labs(     title = \"Posterior Distribution of Success Proportion\",     x = \"Proportion of Subjects Achieving Success\",     y = \"Frequency\"   )"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"bayesian-probability-threshold","dir":"Articles","previous_headings":"6. Clinical Trial Decision-Making","what":"Bayesian Probability Threshold","title":"Using Bayesian Neural Networks in Clinical Trials","text":"posterior probability can guide decision-making. example: - posterior_prob_high_success > 0.9, consider treatment effective. - posterior_prob_high_success < 0.1, consider treatment ineffective. - Otherwise, collect data refine model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"7. Conclusion","title":"Using Bayesian Neural Networks in Clinical Trials","text":"bnns package empowers clinical trial analysts leverage Bayesian Neural Networks predictive modeling decision-making. utilizing posterior distributions, can: - Quantify uncertainty predictions. - Make informed decisions treatment efficacy. - Evaluate trial outcomes based predefined success criteria. probabilistic framework particularly valuable scenarios uncertainty plays critical role decision-making, early-phase clinical trials. ```","code":""},{"path":"https://swarnendu-stat.github.io/bnns/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Swarnendu Chatterjee. Author, maintainer, copyright holder.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chatterjee S (2024). bnns: Bayesian Neural Network Stan. R package version 0.0.0.9000, https://swarnendu-stat.github.io/bnns/, https://github.com/swarnendu-stat/bnns.","code":"@Manual{,   title = {bnns: Bayesian Neural Network with Stan},   author = {Swarnendu Chatterjee},   year = {2024},   note = {R package version 0.0.0.9000, https://swarnendu-stat.github.io/bnns/},   url = {https://github.com/swarnendu-stat/bnns}, }"},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"bnns-bayesian-neural-networks-for-regression-and-classification","dir":"","previous_headings":"","what":"Bayesian Neural Network with Stan","title":"Bayesian Neural Network with Stan","text":"bnns package provides tools fit Bayesian Neural Networks (BNNs) regression classification problems. designed flexible, supporting various network architectures, activation functions, output types, making suitable simple complex data analysis tasks.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Bayesian Neural Network with Stan","text":"Support multi-layer neural networks customizable architecture. Choice activation functions (e.g., sigmoid, ReLU, tanh). Outputs regression (continuous response) classification (binary multiclass). Bayesian inference, providing posterior distributions predictions parameters. Applications domains clinical trials, predictive modeling, .","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian Neural Network with Stan","text":"install bnns package GitHub, use following:","code":"# Install devtools if not already installed if (!requireNamespace(\"devtools\", quietly = TRUE)) {   install.packages(\"devtools\") }  # Install bnns devtools::install_github(\"swarnendu-stat/bnns\") #> Downloading GitHub repo swarnendu-stat/bnns@HEAD #> matrixStats (1.2.0 -> 1.4.1) [CRAN] #> checkmate   (2.3.1 -> 2.3.2) [CRAN] #> loo         (2.6.0 -> 2.8.0) [CRAN] #> Installing 3 packages: matrixStats, checkmate, loo #> Installing packages into '/tmp/Rtmp6kUU8o/temp_libpathad97227605b' #> (as 'lib' is unspecified) #> ── R CMD build ───────────────────────────────────────────────────────────────── #> * checking for file ‘/tmp/RtmpQ1aUFs/remotes3cfa50eb74b7/swarnendu-stat-bnns-39142b1/DESCRIPTION’ ... OK #> * preparing ‘bnns’: #> * checking DESCRIPTION meta-information ... OK #> * checking for LF line-endings in source and make files and shell scripts #> * checking for empty or unneeded directories #> * building ‘bnns_0.0.0.9000.tar.gz’ #> Installing package into '/tmp/Rtmp6kUU8o/temp_libpathad97227605b' #> (as 'lib' is unspecified)"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"id_1-simulate-data","dir":"","previous_headings":"Getting Started","what":"1. Simulate Data","title":"Bayesian Neural Network with Stan","text":"example simulate data regression:","code":"set.seed(123) df <- data.frame(x1 = runif(10), x2 = runif(10), y = rnorm(10))"},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"id_2-fit-a-bnn-model","dir":"","previous_headings":"Getting Started","what":"2. Fit a BNN Model","title":"Bayesian Neural Network with Stan","text":"fit Bayesian Neural Network:","code":"library(bnns) #>  #> Attaching package: 'bnns' #> The following object is masked from 'package:base': #>  #>     tanh  model <- bnns(y ~ -1 + x1 + x2, data = df, L = 2, nodes = c(10, 8), act_fn = c(2, 3), out_act_fn = 1,               iter = 2e2, warmup = 1e2, chains = 1, seed = 123) #>  #> TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW. #> OS: x86_64, linux-gnu; rstan: 2.32.6; Rcpp: 1.0.13.1; inline: 0.3.20  #>  >> setting environment variables:  #> PKG_LIBS =  '/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/rstan/lib//libStanServices.a' -L'/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/lib/' -lStanHeaders -L'/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/RcppParallel/lib/' -ltbb  #> PKG_CPPFLAGS =   -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/Rcpp/include/\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/unsupported\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/BH/include\" -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/src/\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/RcppParallel/include/\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/rstan/include\" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1  #>  >> Program source : #>  #>    1 :  #>    2 : // includes from the plugin #>    3 : // [[Rcpp::plugins(cpp14)]] #>    4 :  #>    5 :  #>    6 : // user includes #>    7 : #include <Rcpp.h> #>    8 : using namespace Rcpp; #>    9 : #ifndef MODELS_HPP #>   10 : #define MODELS_HPP #>   11 : #define STAN__SERVICES__COMMAND_HPP #>   12 : #include <rstan/rstaninc.hpp> #>   13 : #ifndef USE_STANC3 #>   14 : #define USE_STANC3 #>   15 : #endif #>   16 : // Code generated by stanc v2.32.2 #>   17 : #include <stan/model/model_header.hpp> #>   18 : namespace model3cfa7929f5b1__namespace { #>   19 : using stan::model::model_base_crtp; #>   20 : using namespace stan::math; #>   21 : stan::math::profile_map profiles__; #>   22 : static constexpr std::array<const char*, 66> locations_array__ = #>   23 :   {\" (found before start of program)\", #>   24 :   \" (in 'anon_model', line 11, column 2 to column 25)\", #>   25 :   \" (in 'anon_model', line 12, column 2 to column 22)\", #>   26 :   \" (in 'anon_model', line 13, column 2 to column 32)\", #>   27 :   \" (in 'anon_model', line 14, column 2 to column 22)\", #>   28 :   \" (in 'anon_model', line 15, column 2 to column 25)\", #>   29 :   \" (in 'anon_model', line 16, column 2 to column 13)\", #>   30 :   \" (in 'anon_model', line 17, column 2 to column 22)\", #>   31 :   \" (in 'anon_model', line 20, column 2 to column 25)\", #>   32 :   \" (in 'anon_model', line 21, column 2 to column 25)\", #>   33 :   \" (in 'anon_model', line 22, column 2 to column 25)\", #>   34 :   \" (in 'anon_model', line 23, column 2 to column 25)\", #>   35 :   \" (in 'anon_model', line 24, column 2 to column 18)\", #>   36 :   \" (in 'anon_model', line 25, column 2 to column 35)\", #>   37 :   \" (in 'anon_model', line 29, column 7 to column 49)\", #>   38 :   \" (in 'anon_model', line 28, column 27 to column 49)\", #>   39 :   \" (in 'anon_model', line 28, column 7 to line 29, column 49)\", #>   40 :   \" (in 'anon_model', line 27, column 27 to column 46)\", #>   41 :   \" (in 'anon_model', line 27, column 7 to line 29, column 49)\", #>   42 :   \" (in 'anon_model', line 26, column 22 to column 36)\", #>   43 :   \" (in 'anon_model', line 26, column 2 to line 29, column 49)\", #>   44 :   \" (in 'anon_model', line 30, column 2 to column 36)\", #>   45 :   \" (in 'anon_model', line 34, column 7 to column 49)\", #>   46 :   \" (in 'anon_model', line 33, column 27 to column 49)\", #>   47 :   \" (in 'anon_model', line 33, column 7 to line 34, column 49)\", #>   48 :   \" (in 'anon_model', line 32, column 27 to column 46)\", #>   49 :   \" (in 'anon_model', line 32, column 7 to line 34, column 49)\", #>   50 :   \" (in 'anon_model', line 31, column 22 to column 36)\", #>   51 :   \" (in 'anon_model', line 31, column 2 to line 34, column 49)\", #>   52 :   \" (in 'anon_model', line 35, column 2 to column 29)\", #>   53 :   \" (in 'anon_model', line 38, column 2 to column 31)\", #>   54 :   \" (in 'anon_model', line 39, column 2 to column 20)\", #>   55 :   \" (in 'anon_model', line 40, column 2 to column 31)\", #>   56 :   \" (in 'anon_model', line 41, column 2 to column 20)\", #>   57 :   \" (in 'anon_model', line 42, column 2 to column 23)\", #>   58 :   \" (in 'anon_model', line 43, column 2 to column 23)\", #>   59 :   \" (in 'anon_model', line 44, column 2 to column 23)\", #>   60 :   \" (in 'anon_model', line 45, column 2 to column 27)\", #>   61 :   \" (in 'anon_model', line 2, column 2 to column 17)\", #>   62 :   \" (in 'anon_model', line 3, column 2 to column 17)\", #>   63 :   \" (in 'anon_model', line 4, column 2 to column 17)\", #>   64 :   \" (in 'anon_model', line 5, column 21 to column 22)\", #>   65 :   \" (in 'anon_model', line 5, column 2 to column 24)\", #>   66 :   \" (in 'anon_model', line 6, column 9 to column 10)\", #>   67 :   \" (in 'anon_model', line 6, column 12 to column 13)\", #>   68 :   \" (in 'anon_model', line 6, column 2 to column 17)\", #>   69 :   \" (in 'anon_model', line 7, column 9 to column 10)\", #>   70 :   \" (in 'anon_model', line 7, column 2 to column 14)\", #>   71 :   \" (in 'anon_model', line 8, column 22 to column 23)\", #>   72 :   \" (in 'anon_model', line 8, column 2 to column 25)\", #>   73 :   \" (in 'anon_model', line 11, column 9 to column 10)\", #>   74 :   \" (in 'anon_model', line 11, column 12 to column 20)\", #>   75 :   \" (in 'anon_model', line 12, column 9 to column 17)\", #>   76 :   \" (in 'anon_model', line 13, column 9 to column 17)\", #>   77 :   \" (in 'anon_model', line 13, column 19 to column 27)\", #>   78 :   \" (in 'anon_model', line 14, column 9 to column 17)\", #>   79 :   \" (in 'anon_model', line 15, column 9 to column 17)\", #>   80 :   \" (in 'anon_model', line 20, column 9 to column 10)\", #>   81 :   \" (in 'anon_model', line 20, column 12 to column 20)\", #>   82 :   \" (in 'anon_model', line 21, column 9 to column 10)\", #>   83 :   \" (in 'anon_model', line 21, column 12 to column 20)\", #>   84 :   \" (in 'anon_model', line 22, column 9 to column 10)\", #>   85 :   \" (in 'anon_model', line 22, column 12 to column 20)\", #>   86 :   \" (in 'anon_model', line 23, column 9 to column 10)\", #>   87 :   \" (in 'anon_model', line 23, column 12 to column 20)\", #>   88 :   \" (in 'anon_model', line 24, column 9 to column 10)\"}; #>   89 : class model3cfa7929f5b1_ final : public model_base_crtp<model3cfa7929f5b1_> { #>   90 : private: #>   91 :   int n; #>   92 :   int m; #>   93 :   int L; #>   94 :   std::vector<int> nodes; #>   95 :   Eigen::Matrix<double,-1,-1> X_data__; #>   96 :   Eigen::Matrix<double,-1,1> y_data__; #>   97 :   std::vector<int> act_fn; #>   98 :   int w1_2dim__; #>   99 :   int b1_1dim__; #>  100 :   int w2_1dim__; #>  101 :   int w2_2dim__; #>  102 :   int b2_1dim__; #>  103 :   int w_out_1dim__; #>  104 :   int z1_2dim__; #>  105 :   int a1_2dim__; #>  106 :   int z2_2dim__; #>  107 :   int a2_2dim__; #>  108 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> X{nullptr, 0, 0}; #>  109 :   Eigen::Map<Eigen::Matrix<double,-1,1>> y{nullptr, 0}; #>  110 : public: #>  111 :   ~model3cfa7929f5b1_() {} #>  112 :   model3cfa7929f5b1_(stan::io::var_context& context__, unsigned int #>  113 :                      random_seed__ = 0, std::ostream* pstream__ = nullptr) #>  114 :       : model_base_crtp(0) { #>  115 :     int current_statement__ = 0; #>  116 :     using local_scalar_t__ = double; #>  117 :     boost::ecuyer1988 base_rng__ = #>  118 :       stan::services::util::create_rng(random_seed__, 0); #>  119 :     // suppress unused var warning #>  120 :     (void) base_rng__; #>  121 :     static constexpr const char* function__ = #>  122 :       \"model3cfa7929f5b1__namespace::model3cfa7929f5b1_\"; #>  123 :     // suppress unused var warning #>  124 :     (void) function__; #>  125 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  126 :     // suppress unused var warning #>  127 :     (void) DUMMY_VAR__; #>  128 :     try { #>  129 :       int pos__ = std::numeric_limits<int>::min(); #>  130 :       pos__ = 1; #>  131 :       current_statement__ = 38; #>  132 :       context__.validate_dims(\"data initialization\", \"n\", \"int\", #>  133 :         std::vector<size_t>{}); #>  134 :       n = std::numeric_limits<int>::min(); #>  135 :       current_statement__ = 38; #>  136 :       n = context__.vals_i(\"n\")[(1 - 1)]; #>  137 :       current_statement__ = 38; #>  138 :       stan::math::check_greater_or_equal(function__, \"n\", n, 1); #>  139 :       current_statement__ = 39; #>  140 :       context__.validate_dims(\"data initialization\", \"m\", \"int\", #>  141 :         std::vector<size_t>{}); #>  142 :       m = std::numeric_limits<int>::min(); #>  143 :       current_statement__ = 39; #>  144 :       m = context__.vals_i(\"m\")[(1 - 1)]; #>  145 :       current_statement__ = 39; #>  146 :       stan::math::check_greater_or_equal(function__, \"m\", m, 1); #>  147 :       current_statement__ = 40; #>  148 :       context__.validate_dims(\"data initialization\", \"L\", \"int\", #>  149 :         std::vector<size_t>{}); #>  150 :       L = std::numeric_limits<int>::min(); #>  151 :       current_statement__ = 40; #>  152 :       L = context__.vals_i(\"L\")[(1 - 1)]; #>  153 :       current_statement__ = 40; #>  154 :       stan::math::check_greater_or_equal(function__, \"L\", L, 1); #>  155 :       current_statement__ = 41; #>  156 :       stan::math::validate_non_negative_index(\"nodes\", \"L\", L); #>  157 :       current_statement__ = 42; #>  158 :       context__.validate_dims(\"data initialization\", \"nodes\", \"int\", #>  159 :         std::vector<size_t>{static_cast<size_t>(L)}); #>  160 :       nodes = std::vector<int>(L, std::numeric_limits<int>::min()); #>  161 :       current_statement__ = 42; #>  162 :       nodes = context__.vals_i(\"nodes\"); #>  163 :       current_statement__ = 42; #>  164 :       stan::math::check_greater_or_equal(function__, \"nodes\", nodes, 1); #>  165 :       current_statement__ = 43; #>  166 :       stan::math::validate_non_negative_index(\"X\", \"n\", n); #>  167 :       current_statement__ = 44; #>  168 :       stan::math::validate_non_negative_index(\"X\", \"m\", m); #>  169 :       current_statement__ = 45; #>  170 :       context__.validate_dims(\"data initialization\", \"X\", \"double\", #>  171 :         std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m)}); #>  172 :       X_data__ = Eigen::Matrix<double,-1,-1>::Constant(n, m, #>  173 :                    std::numeric_limits<double>::quiet_NaN()); #>  174 :       new (&X) Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_data__.data(), n, m); #>  175 :       { #>  176 :         std::vector<local_scalar_t__> X_flat__; #>  177 :         current_statement__ = 45; #>  178 :         X_flat__ = context__.vals_r(\"X\"); #>  179 :         current_statement__ = 45; #>  180 :         pos__ = 1; #>  181 :         current_statement__ = 45; #>  182 :         for (int sym1__ = 1; sym1__ <= m; ++sym1__) { #>  183 :           current_statement__ = 45; #>  184 :           for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  185 :             current_statement__ = 45; #>  186 :             stan::model::assign(X, X_flat__[(pos__ - 1)], #>  187 :               \"assigning variable X\", stan::model::index_uni(sym2__), #>  188 :               stan::model::index_uni(sym1__)); #>  189 :             current_statement__ = 45; #>  190 :             pos__ = (pos__ + 1); #>  191 :           } #>  192 :         } #>  193 :       } #>  194 :       current_statement__ = 46; #>  195 :       stan::math::validate_non_negative_index(\"y\", \"n\", n); #>  196 :       current_statement__ = 47; #>  197 :       context__.validate_dims(\"data initialization\", \"y\", \"double\", #>  198 :         std::vector<size_t>{static_cast<size_t>(n)}); #>  199 :       y_data__ = Eigen::Matrix<double,-1,1>::Constant(n, #>  200 :                    std::numeric_limits<double>::quiet_NaN()); #>  201 :       new (&y) Eigen::Map<Eigen::Matrix<double,-1,1>>(y_data__.data(), n); #>  202 :       { #>  203 :         std::vector<local_scalar_t__> y_flat__; #>  204 :         current_statement__ = 47; #>  205 :         y_flat__ = context__.vals_r(\"y\"); #>  206 :         current_statement__ = 47; #>  207 :         pos__ = 1; #>  208 :         current_statement__ = 47; #>  209 :         for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #>  210 :           current_statement__ = 47; #>  211 :           stan::model::assign(y, y_flat__[(pos__ - 1)], #>  212 :             \"assigning variable y\", stan::model::index_uni(sym1__)); #>  213 :           current_statement__ = 47; #>  214 :           pos__ = (pos__ + 1); #>  215 :         } #>  216 :       } #>  217 :       current_statement__ = 48; #>  218 :       stan::math::validate_non_negative_index(\"act_fn\", \"L\", L); #>  219 :       current_statement__ = 49; #>  220 :       context__.validate_dims(\"data initialization\", \"act_fn\", \"int\", #>  221 :         std::vector<size_t>{static_cast<size_t>(L)}); #>  222 :       act_fn = std::vector<int>(L, std::numeric_limits<int>::min()); #>  223 :       current_statement__ = 49; #>  224 :       act_fn = context__.vals_i(\"act_fn\"); #>  225 :       current_statement__ = 49; #>  226 :       stan::math::check_greater_or_equal(function__, \"act_fn\", act_fn, 1); #>  227 :       current_statement__ = 50; #>  228 :       stan::math::validate_non_negative_index(\"w1\", \"m\", m); #>  229 :       current_statement__ = 51; #>  230 :       w1_2dim__ = std::numeric_limits<int>::min(); #>  231 :       current_statement__ = 51; #>  232 :       w1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  233 :                     stan::model::index_uni(1)); #>  234 :       current_statement__ = 51; #>  235 :       stan::math::validate_non_negative_index(\"w1\", \"nodes[1]\", w1_2dim__); #>  236 :       current_statement__ = 52; #>  237 :       b1_1dim__ = std::numeric_limits<int>::min(); #>  238 :       current_statement__ = 52; #>  239 :       b1_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  240 :                     stan::model::index_uni(1)); #>  241 :       current_statement__ = 52; #>  242 :       stan::math::validate_non_negative_index(\"b1\", \"nodes[1]\", b1_1dim__); #>  243 :       current_statement__ = 53; #>  244 :       w2_1dim__ = std::numeric_limits<int>::min(); #>  245 :       current_statement__ = 53; #>  246 :       w2_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  247 :                     stan::model::index_uni(1)); #>  248 :       current_statement__ = 53; #>  249 :       stan::math::validate_non_negative_index(\"w2\", \"nodes[1]\", w2_1dim__); #>  250 :       current_statement__ = 54; #>  251 :       w2_2dim__ = std::numeric_limits<int>::min(); #>  252 :       current_statement__ = 54; #>  253 :       w2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  254 :                     stan::model::index_uni(2)); #>  255 :       current_statement__ = 54; #>  256 :       stan::math::validate_non_negative_index(\"w2\", \"nodes[2]\", w2_2dim__); #>  257 :       current_statement__ = 55; #>  258 :       b2_1dim__ = std::numeric_limits<int>::min(); #>  259 :       current_statement__ = 55; #>  260 :       b2_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  261 :                     stan::model::index_uni(2)); #>  262 :       current_statement__ = 55; #>  263 :       stan::math::validate_non_negative_index(\"b2\", \"nodes[2]\", b2_1dim__); #>  264 :       current_statement__ = 56; #>  265 :       w_out_1dim__ = std::numeric_limits<int>::min(); #>  266 :       current_statement__ = 56; #>  267 :       w_out_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  268 :                        stan::model::index_uni(L)); #>  269 :       current_statement__ = 56; #>  270 :       stan::math::validate_non_negative_index(\"w_out\", \"nodes[L]\", #>  271 :         w_out_1dim__); #>  272 :       current_statement__ = 57; #>  273 :       stan::math::validate_non_negative_index(\"z1\", \"n\", n); #>  274 :       current_statement__ = 58; #>  275 :       z1_2dim__ = std::numeric_limits<int>::min(); #>  276 :       current_statement__ = 58; #>  277 :       z1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  278 :                     stan::model::index_uni(1)); #>  279 :       current_statement__ = 58; #>  280 :       stan::math::validate_non_negative_index(\"z1\", \"nodes[1]\", z1_2dim__); #>  281 :       current_statement__ = 59; #>  282 :       stan::math::validate_non_negative_index(\"a1\", \"n\", n); #>  283 :       current_statement__ = 60; #>  284 :       a1_2dim__ = std::numeric_limits<int>::min(); #>  285 :       current_statement__ = 60; #>  286 :       a1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  287 :                     stan::model::index_uni(1)); #>  288 :       current_statement__ = 60; #>  289 :       stan::math::validate_non_negative_index(\"a1\", \"nodes[1]\", a1_2dim__); #>  290 :       current_statement__ = 61; #>  291 :       stan::math::validate_non_negative_index(\"z2\", \"n\", n); #>  292 :       current_statement__ = 62; #>  293 :       z2_2dim__ = std::numeric_limits<int>::min(); #>  294 :       current_statement__ = 62; #>  295 :       z2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  296 :                     stan::model::index_uni(2)); #>  297 :       current_statement__ = 62; #>  298 :       stan::math::validate_non_negative_index(\"z2\", \"nodes[2]\", z2_2dim__); #>  299 :       current_statement__ = 63; #>  300 :       stan::math::validate_non_negative_index(\"a2\", \"n\", n); #>  301 :       current_statement__ = 64; #>  302 :       a2_2dim__ = std::numeric_limits<int>::min(); #>  303 :       current_statement__ = 64; #>  304 :       a2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  305 :                     stan::model::index_uni(2)); #>  306 :       current_statement__ = 64; #>  307 :       stan::math::validate_non_negative_index(\"a2\", \"nodes[2]\", a2_2dim__); #>  308 :       current_statement__ = 65; #>  309 :       stan::math::validate_non_negative_index(\"y_hat\", \"n\", n); #>  310 :     } catch (const std::exception& e) { #>  311 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  312 :     } #>  313 :     num_params_r__ = (m * w1_2dim__) + b1_1dim__ + (w2_1dim__ * w2_2dim__) + #>  314 :       b2_1dim__ + w_out_1dim__ + 1 + 1; #>  315 :   } #>  316 :   inline std::string model_name() const final { #>  317 :     return \"model3cfa7929f5b1_\"; #>  318 :   } #>  319 :   inline std::vector<std::string> model_compile_info() const noexcept { #>  320 :     return std::vector<std::string>{\"stanc_version = stanc3 v2.32.2\", #>  321 :              \"stancflags = --\"}; #>  322 :   } #>  323 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI, #>  324 :             stan::require_vector_like_t<VecR>* = nullptr, #>  325 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  326 :   inline stan::scalar_type_t<VecR> #>  327 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream* #>  328 :                 pstream__ = nullptr) const { #>  329 :     using T__ = stan::scalar_type_t<VecR>; #>  330 :     using local_scalar_t__ = T__; #>  331 :     T__ lp__(0.0); #>  332 :     stan::math::accumulator<T__> lp_accum__; #>  333 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  334 :     int current_statement__ = 0; #>  335 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  336 :     // suppress unused var warning #>  337 :     (void) DUMMY_VAR__; #>  338 :     static constexpr const char* function__ = #>  339 :       \"model3cfa7929f5b1__namespace::log_prob\"; #>  340 :     // suppress unused var warning #>  341 :     (void) function__; #>  342 :     try { #>  343 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  344 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  345 :           DUMMY_VAR__); #>  346 :       current_statement__ = 1; #>  347 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  348 :              w1_2dim__); #>  349 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  350 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  351 :           DUMMY_VAR__); #>  352 :       current_statement__ = 2; #>  353 :       b1 = in__.template read< #>  354 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__); #>  355 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  356 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  357 :           DUMMY_VAR__); #>  358 :       current_statement__ = 3; #>  359 :       w2 = in__.template read< #>  360 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, w2_2dim__); #>  361 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  362 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  363 :           DUMMY_VAR__); #>  364 :       current_statement__ = 4; #>  365 :       b2 = in__.template read< #>  366 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__); #>  367 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  368 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  369 :           DUMMY_VAR__); #>  370 :       current_statement__ = 5; #>  371 :       w_out = in__.template read< #>  372 :                 Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__); #>  373 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  374 :       current_statement__ = 6; #>  375 :       b_out = in__.template read<local_scalar_t__>(); #>  376 :       local_scalar_t__ sigma = DUMMY_VAR__; #>  377 :       current_statement__ = 7; #>  378 :       sigma = in__.template read_constrain_lb<local_scalar_t__, #>  379 :                 jacobian__>(0, lp__); #>  380 :       Eigen::Matrix<local_scalar_t__,-1,-1> z1 = #>  381 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z1_2dim__, #>  382 :           DUMMY_VAR__); #>  383 :       Eigen::Matrix<local_scalar_t__,-1,-1> a1 = #>  384 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a1_2dim__, #>  385 :           DUMMY_VAR__); #>  386 :       Eigen::Matrix<local_scalar_t__,-1,-1> z2 = #>  387 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z2_2dim__, #>  388 :           DUMMY_VAR__); #>  389 :       Eigen::Matrix<local_scalar_t__,-1,-1> a2 = #>  390 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a2_2dim__, #>  391 :           DUMMY_VAR__); #>  392 :       Eigen::Matrix<local_scalar_t__,-1,1> y_hat = #>  393 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n, DUMMY_VAR__); #>  394 :       current_statement__ = 13; #>  395 :       stan::model::assign(z1, #>  396 :         stan::math::add(stan::math::multiply(X, w1), #>  397 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  398 :         \"assigning variable z1\"); #>  399 :       current_statement__ = 20; #>  400 :       if (stan::math::logical_eq( #>  401 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  402 :             1)) { #>  403 :         current_statement__ = 19; #>  404 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  405 :       } else { #>  406 :         current_statement__ = 18; #>  407 :         if (stan::math::logical_eq( #>  408 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  409 :               2)) { #>  410 :           current_statement__ = 17; #>  411 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  412 :             \"assigning variable a1\"); #>  413 :         } else { #>  414 :           current_statement__ = 16; #>  415 :           if (stan::math::logical_eq( #>  416 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  417 :                   stan::model::index_uni(1)), 3)) { #>  418 :             current_statement__ = 15; #>  419 :             stan::model::assign(a1, #>  420 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  421 :               \"assigning variable a1\"); #>  422 :           } else { #>  423 :             current_statement__ = 14; #>  424 :             stan::model::assign(a1, #>  425 :               stan::math::fmax( #>  426 :                 stan::math::rep_matrix(0, n, #>  427 :                   stan::model::rvalue(nodes, \"nodes\", #>  428 :                     stan::model::index_uni(1))), z1), \"assigning variable a1\"); #>  429 :           } #>  430 :         } #>  431 :       } #>  432 :       current_statement__ = 21; #>  433 :       stan::model::assign(z2, #>  434 :         stan::math::add(stan::math::multiply(a1, w2), #>  435 :           stan::math::rep_matrix(stan::math::transpose(b2), n)), #>  436 :         \"assigning variable z2\"); #>  437 :       current_statement__ = 28; #>  438 :       if (stan::math::logical_eq( #>  439 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  440 :             1)) { #>  441 :         current_statement__ = 27; #>  442 :         stan::model::assign(a2, stan::math::tanh(z2), \"assigning variable a2\"); #>  443 :       } else { #>  444 :         current_statement__ = 26; #>  445 :         if (stan::math::logical_eq( #>  446 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  447 :               2)) { #>  448 :           current_statement__ = 25; #>  449 :           stan::model::assign(a2, stan::math::inv_logit(z2), #>  450 :             \"assigning variable a2\"); #>  451 :         } else { #>  452 :           current_statement__ = 24; #>  453 :           if (stan::math::logical_eq( #>  454 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  455 :                   stan::model::index_uni(2)), 3)) { #>  456 :             current_statement__ = 23; #>  457 :             stan::model::assign(a2, #>  458 :               stan::math::log(stan::math::add(1, stan::math::exp(z2))), #>  459 :               \"assigning variable a2\"); #>  460 :           } else { #>  461 :             current_statement__ = 22; #>  462 :             stan::model::assign(a2, #>  463 :               stan::math::fmax( #>  464 :                 stan::math::rep_matrix(0, n, #>  465 :                   stan::model::rvalue(nodes, \"nodes\", #>  466 :                     stan::model::index_uni(2))), z2), \"assigning variable a2\"); #>  467 :           } #>  468 :         } #>  469 :       } #>  470 :       current_statement__ = 29; #>  471 :       stan::model::assign(y_hat, #>  472 :         stan::math::add(stan::math::multiply(a2, w_out), b_out), #>  473 :         \"assigning variable y_hat\"); #>  474 :       { #>  475 :         current_statement__ = 30; #>  476 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  477 :                          stan::math::to_vector(w1), 0, 1)); #>  478 :         current_statement__ = 31; #>  479 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b1, 0, 1)); #>  480 :         current_statement__ = 32; #>  481 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  482 :                          stan::math::to_vector(w2), 0, 1)); #>  483 :         current_statement__ = 33; #>  484 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b2, 0, 1)); #>  485 :         current_statement__ = 34; #>  486 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(w_out, 0, 1)); #>  487 :         current_statement__ = 35; #>  488 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b_out, 0, 1)); #>  489 :         current_statement__ = 36; #>  490 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(sigma, 0, 1)); #>  491 :         current_statement__ = 37; #>  492 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(y, y_hat, sigma)); #>  493 :       } #>  494 :     } catch (const std::exception& e) { #>  495 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  496 :     } #>  497 :     lp_accum__.add(lp__); #>  498 :     return lp_accum__.sum(); #>  499 :   } #>  500 :   template <typename RNG, typename VecR, typename VecI, typename VecVar, #>  501 :             stan::require_vector_like_vt<std::is_floating_point, #>  502 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, #>  503 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point, #>  504 :             VecVar>* = nullptr> #>  505 :   inline void #>  506 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__, #>  507 :                    VecVar& vars__, const bool #>  508 :                    emit_transformed_parameters__ = true, const bool #>  509 :                    emit_generated_quantities__ = true, std::ostream* #>  510 :                    pstream__ = nullptr) const { #>  511 :     using local_scalar_t__ = double; #>  512 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  513 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  514 :     static constexpr bool propto__ = true; #>  515 :     // suppress unused var warning #>  516 :     (void) propto__; #>  517 :     double lp__ = 0.0; #>  518 :     // suppress unused var warning #>  519 :     (void) lp__; #>  520 :     int current_statement__ = 0; #>  521 :     stan::math::accumulator<double> lp_accum__; #>  522 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  523 :     // suppress unused var warning #>  524 :     (void) DUMMY_VAR__; #>  525 :     constexpr bool jacobian__ = false; #>  526 :     static constexpr const char* function__ = #>  527 :       \"model3cfa7929f5b1__namespace::write_array\"; #>  528 :     // suppress unused var warning #>  529 :     (void) function__; #>  530 :     try { #>  531 :       Eigen::Matrix<double,-1,-1> w1 = #>  532 :         Eigen::Matrix<double,-1,-1>::Constant(m, w1_2dim__, #>  533 :           std::numeric_limits<double>::quiet_NaN()); #>  534 :       current_statement__ = 1; #>  535 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  536 :              w1_2dim__); #>  537 :       Eigen::Matrix<double,-1,1> b1 = #>  538 :         Eigen::Matrix<double,-1,1>::Constant(b1_1dim__, #>  539 :           std::numeric_limits<double>::quiet_NaN()); #>  540 :       current_statement__ = 2; #>  541 :       b1 = in__.template read< #>  542 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__); #>  543 :       Eigen::Matrix<double,-1,-1> w2 = #>  544 :         Eigen::Matrix<double,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  545 :           std::numeric_limits<double>::quiet_NaN()); #>  546 :       current_statement__ = 3; #>  547 :       w2 = in__.template read< #>  548 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, w2_2dim__); #>  549 :       Eigen::Matrix<double,-1,1> b2 = #>  550 :         Eigen::Matrix<double,-1,1>::Constant(b2_1dim__, #>  551 :           std::numeric_limits<double>::quiet_NaN()); #>  552 :       current_statement__ = 4; #>  553 :       b2 = in__.template read< #>  554 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__); #>  555 :       Eigen::Matrix<double,-1,1> w_out = #>  556 :         Eigen::Matrix<double,-1,1>::Constant(w_out_1dim__, #>  557 :           std::numeric_limits<double>::quiet_NaN()); #>  558 :       current_statement__ = 5; #>  559 :       w_out = in__.template read< #>  560 :                 Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__); #>  561 :       double b_out = std::numeric_limits<double>::quiet_NaN(); #>  562 :       current_statement__ = 6; #>  563 :       b_out = in__.template read<local_scalar_t__>(); #>  564 :       double sigma = std::numeric_limits<double>::quiet_NaN(); #>  565 :       current_statement__ = 7; #>  566 :       sigma = in__.template read_constrain_lb<local_scalar_t__, #>  567 :                 jacobian__>(0, lp__); #>  568 :       Eigen::Matrix<double,-1,-1> z1 = #>  569 :         Eigen::Matrix<double,-1,-1>::Constant(n, z1_2dim__, #>  570 :           std::numeric_limits<double>::quiet_NaN()); #>  571 :       Eigen::Matrix<double,-1,-1> a1 = #>  572 :         Eigen::Matrix<double,-1,-1>::Constant(n, a1_2dim__, #>  573 :           std::numeric_limits<double>::quiet_NaN()); #>  574 :       Eigen::Matrix<double,-1,-1> z2 = #>  575 :         Eigen::Matrix<double,-1,-1>::Constant(n, z2_2dim__, #>  576 :           std::numeric_limits<double>::quiet_NaN()); #>  577 :       Eigen::Matrix<double,-1,-1> a2 = #>  578 :         Eigen::Matrix<double,-1,-1>::Constant(n, a2_2dim__, #>  579 :           std::numeric_limits<double>::quiet_NaN()); #>  580 :       Eigen::Matrix<double,-1,1> y_hat = #>  581 :         Eigen::Matrix<double,-1,1>::Constant(n, #>  582 :           std::numeric_limits<double>::quiet_NaN()); #>  583 :       out__.write(w1); #>  584 :       out__.write(b1); #>  585 :       out__.write(w2); #>  586 :       out__.write(b2); #>  587 :       out__.write(w_out); #>  588 :       out__.write(b_out); #>  589 :       out__.write(sigma); #>  590 :       if (stan::math::logical_negation( #>  591 :             (stan::math::primitive_value(emit_transformed_parameters__) || #>  592 :             stan::math::primitive_value(emit_generated_quantities__)))) { #>  593 :         return ; #>  594 :       } #>  595 :       current_statement__ = 13; #>  596 :       stan::model::assign(z1, #>  597 :         stan::math::add(stan::math::multiply(X, w1), #>  598 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  599 :         \"assigning variable z1\"); #>  600 :       current_statement__ = 20; #>  601 :       if (stan::math::logical_eq( #>  602 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  603 :             1)) { #>  604 :         current_statement__ = 19; #>  605 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  606 :       } else { #>  607 :         current_statement__ = 18; #>  608 :         if (stan::math::logical_eq( #>  609 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  610 :               2)) { #>  611 :           current_statement__ = 17; #>  612 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  613 :             \"assigning variable a1\"); #>  614 :         } else { #>  615 :           current_statement__ = 16; #>  616 :           if (stan::math::logical_eq( #>  617 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  618 :                   stan::model::index_uni(1)), 3)) { #>  619 :             current_statement__ = 15; #>  620 :             stan::model::assign(a1, #>  621 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  622 :               \"assigning variable a1\"); #>  623 :           } else { #>  624 :             current_statement__ = 14; #>  625 :             stan::model::assign(a1, #>  626 :               stan::math::fmax( #>  627 :                 stan::math::rep_matrix(0, n, #>  628 :                   stan::model::rvalue(nodes, \"nodes\", #>  629 :                     stan::model::index_uni(1))), z1), \"assigning variable a1\"); #>  630 :           } #>  631 :         } #>  632 :       } #>  633 :       current_statement__ = 21; #>  634 :       stan::model::assign(z2, #>  635 :         stan::math::add(stan::math::multiply(a1, w2), #>  636 :           stan::math::rep_matrix(stan::math::transpose(b2), n)), #>  637 :         \"assigning variable z2\"); #>  638 :       current_statement__ = 28; #>  639 :       if (stan::math::logical_eq( #>  640 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  641 :             1)) { #>  642 :         current_statement__ = 27; #>  643 :         stan::model::assign(a2, stan::math::tanh(z2), \"assigning variable a2\"); #>  644 :       } else { #>  645 :         current_statement__ = 26; #>  646 :         if (stan::math::logical_eq( #>  647 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  648 :               2)) { #>  649 :           current_statement__ = 25; #>  650 :           stan::model::assign(a2, stan::math::inv_logit(z2), #>  651 :             \"assigning variable a2\"); #>  652 :         } else { #>  653 :           current_statement__ = 24; #>  654 :           if (stan::math::logical_eq( #>  655 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  656 :                   stan::model::index_uni(2)), 3)) { #>  657 :             current_statement__ = 23; #>  658 :             stan::model::assign(a2, #>  659 :               stan::math::log(stan::math::add(1, stan::math::exp(z2))), #>  660 :               \"assigning variable a2\"); #>  661 :           } else { #>  662 :             current_statement__ = 22; #>  663 :             stan::model::assign(a2, #>  664 :               stan::math::fmax( #>  665 :                 stan::math::rep_matrix(0, n, #>  666 :                   stan::model::rvalue(nodes, \"nodes\", #>  667 :                     stan::model::index_uni(2))), z2), \"assigning variable a2\"); #>  668 :           } #>  669 :         } #>  670 :       } #>  671 :       current_statement__ = 29; #>  672 :       stan::model::assign(y_hat, #>  673 :         stan::math::add(stan::math::multiply(a2, w_out), b_out), #>  674 :         \"assigning variable y_hat\"); #>  675 :       if (emit_transformed_parameters__) { #>  676 :         out__.write(z1); #>  677 :         out__.write(a1); #>  678 :         out__.write(z2); #>  679 :         out__.write(a2); #>  680 :         out__.write(y_hat); #>  681 :       } #>  682 :       if (stan::math::logical_negation(emit_generated_quantities__)) { #>  683 :         return ; #>  684 :       } #>  685 :     } catch (const std::exception& e) { #>  686 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  687 :     } #>  688 :   } #>  689 :   template <typename VecVar, typename VecI, #>  690 :             stan::require_vector_t<VecVar>* = nullptr, #>  691 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  692 :   inline void #>  693 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__, #>  694 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const { #>  695 :     using local_scalar_t__ = double; #>  696 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  697 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  698 :     int current_statement__ = 0; #>  699 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  700 :     // suppress unused var warning #>  701 :     (void) DUMMY_VAR__; #>  702 :     try { #>  703 :       int pos__ = std::numeric_limits<int>::min(); #>  704 :       pos__ = 1; #>  705 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  706 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  707 :           DUMMY_VAR__); #>  708 :       current_statement__ = 1; #>  709 :       stan::model::assign(w1, #>  710 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, w1_2dim__), #>  711 :         \"assigning variable w1\"); #>  712 :       out__.write(w1); #>  713 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  714 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  715 :           DUMMY_VAR__); #>  716 :       current_statement__ = 2; #>  717 :       stan::model::assign(b1, #>  718 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__), #>  719 :         \"assigning variable b1\"); #>  720 :       out__.write(b1); #>  721 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  722 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  723 :           DUMMY_VAR__); #>  724 :       current_statement__ = 3; #>  725 :       stan::model::assign(w2, #>  726 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, #>  727 :           w2_2dim__), \"assigning variable w2\"); #>  728 :       out__.write(w2); #>  729 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  730 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  731 :           DUMMY_VAR__); #>  732 :       current_statement__ = 4; #>  733 :       stan::model::assign(b2, #>  734 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__), #>  735 :         \"assigning variable b2\"); #>  736 :       out__.write(b2); #>  737 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  738 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  739 :           DUMMY_VAR__); #>  740 :       current_statement__ = 5; #>  741 :       stan::model::assign(w_out, #>  742 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__), #>  743 :         \"assigning variable w_out\"); #>  744 :       out__.write(w_out); #>  745 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  746 :       current_statement__ = 6; #>  747 :       b_out = in__.read<local_scalar_t__>(); #>  748 :       out__.write(b_out); #>  749 :       local_scalar_t__ sigma = DUMMY_VAR__; #>  750 :       current_statement__ = 7; #>  751 :       sigma = in__.read<local_scalar_t__>(); #>  752 :       out__.write_free_lb(0, sigma); #>  753 :     } catch (const std::exception& e) { #>  754 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  755 :     } #>  756 :   } #>  757 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr> #>  758 :   inline void #>  759 :   transform_inits_impl(const stan::io::var_context& context__, VecVar& #>  760 :                        vars__, std::ostream* pstream__ = nullptr) const { #>  761 :     using local_scalar_t__ = double; #>  762 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  763 :     int current_statement__ = 0; #>  764 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  765 :     // suppress unused var warning #>  766 :     (void) DUMMY_VAR__; #>  767 :     try { #>  768 :       current_statement__ = 1; #>  769 :       context__.validate_dims(\"parameter initialization\", \"w1\", \"double\", #>  770 :         std::vector<size_t>{static_cast<size_t>(m), #>  771 :           static_cast<size_t>(w1_2dim__)}); #>  772 :       current_statement__ = 2; #>  773 :       context__.validate_dims(\"parameter initialization\", \"b1\", \"double\", #>  774 :         std::vector<size_t>{static_cast<size_t>(b1_1dim__)}); #>  775 :       current_statement__ = 3; #>  776 :       context__.validate_dims(\"parameter initialization\", \"w2\", \"double\", #>  777 :         std::vector<size_t>{static_cast<size_t>(w2_1dim__), #>  778 :           static_cast<size_t>(w2_2dim__)}); #>  779 :       current_statement__ = 4; #>  780 :       context__.validate_dims(\"parameter initialization\", \"b2\", \"double\", #>  781 :         std::vector<size_t>{static_cast<size_t>(b2_1dim__)}); #>  782 :       current_statement__ = 5; #>  783 :       context__.validate_dims(\"parameter initialization\", \"w_out\", \"double\", #>  784 :         std::vector<size_t>{static_cast<size_t>(w_out_1dim__)}); #>  785 :       current_statement__ = 6; #>  786 :       context__.validate_dims(\"parameter initialization\", \"b_out\", \"double\", #>  787 :         std::vector<size_t>{}); #>  788 :       current_statement__ = 7; #>  789 :       context__.validate_dims(\"parameter initialization\", \"sigma\", \"double\", #>  790 :         std::vector<size_t>{}); #>  791 :       int pos__ = std::numeric_limits<int>::min(); #>  792 :       pos__ = 1; #>  793 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  794 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  795 :           DUMMY_VAR__); #>  796 :       { #>  797 :         std::vector<local_scalar_t__> w1_flat__; #>  798 :         current_statement__ = 1; #>  799 :         w1_flat__ = context__.vals_r(\"w1\"); #>  800 :         current_statement__ = 1; #>  801 :         pos__ = 1; #>  802 :         current_statement__ = 1; #>  803 :         for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #>  804 :           current_statement__ = 1; #>  805 :           for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  806 :             current_statement__ = 1; #>  807 :             stan::model::assign(w1, w1_flat__[(pos__ - 1)], #>  808 :               \"assigning variable w1\", stan::model::index_uni(sym2__), #>  809 :               stan::model::index_uni(sym1__)); #>  810 :             current_statement__ = 1; #>  811 :             pos__ = (pos__ + 1); #>  812 :           } #>  813 :         } #>  814 :       } #>  815 :       out__.write(w1); #>  816 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  817 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  818 :           DUMMY_VAR__); #>  819 :       { #>  820 :         std::vector<local_scalar_t__> b1_flat__; #>  821 :         current_statement__ = 2; #>  822 :         b1_flat__ = context__.vals_r(\"b1\"); #>  823 :         current_statement__ = 2; #>  824 :         pos__ = 1; #>  825 :         current_statement__ = 2; #>  826 :         for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #>  827 :           current_statement__ = 2; #>  828 :           stan::model::assign(b1, b1_flat__[(pos__ - 1)], #>  829 :             \"assigning variable b1\", stan::model::index_uni(sym1__)); #>  830 :           current_statement__ = 2; #>  831 :           pos__ = (pos__ + 1); #>  832 :         } #>  833 :       } #>  834 :       out__.write(b1); #>  835 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  836 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  837 :           DUMMY_VAR__); #>  838 :       { #>  839 :         std::vector<local_scalar_t__> w2_flat__; #>  840 :         current_statement__ = 3; #>  841 :         w2_flat__ = context__.vals_r(\"w2\"); #>  842 :         current_statement__ = 3; #>  843 :         pos__ = 1; #>  844 :         current_statement__ = 3; #>  845 :         for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #>  846 :           current_statement__ = 3; #>  847 :           for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #>  848 :             current_statement__ = 3; #>  849 :             stan::model::assign(w2, w2_flat__[(pos__ - 1)], #>  850 :               \"assigning variable w2\", stan::model::index_uni(sym2__), #>  851 :               stan::model::index_uni(sym1__)); #>  852 :             current_statement__ = 3; #>  853 :             pos__ = (pos__ + 1); #>  854 :           } #>  855 :         } #>  856 :       } #>  857 :       out__.write(w2); #>  858 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  859 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  860 :           DUMMY_VAR__); #>  861 :       { #>  862 :         std::vector<local_scalar_t__> b2_flat__; #>  863 :         current_statement__ = 4; #>  864 :         b2_flat__ = context__.vals_r(\"b2\"); #>  865 :         current_statement__ = 4; #>  866 :         pos__ = 1; #>  867 :         current_statement__ = 4; #>  868 :         for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #>  869 :           current_statement__ = 4; #>  870 :           stan::model::assign(b2, b2_flat__[(pos__ - 1)], #>  871 :             \"assigning variable b2\", stan::model::index_uni(sym1__)); #>  872 :           current_statement__ = 4; #>  873 :           pos__ = (pos__ + 1); #>  874 :         } #>  875 :       } #>  876 :       out__.write(b2); #>  877 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  878 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  879 :           DUMMY_VAR__); #>  880 :       { #>  881 :         std::vector<local_scalar_t__> w_out_flat__; #>  882 :         current_statement__ = 5; #>  883 :         w_out_flat__ = context__.vals_r(\"w_out\"); #>  884 :         current_statement__ = 5; #>  885 :         pos__ = 1; #>  886 :         current_statement__ = 5; #>  887 :         for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #>  888 :           current_statement__ = 5; #>  889 :           stan::model::assign(w_out, w_out_flat__[(pos__ - 1)], #>  890 :             \"assigning variable w_out\", stan::model::index_uni(sym1__)); #>  891 :           current_statement__ = 5; #>  892 :           pos__ = (pos__ + 1); #>  893 :         } #>  894 :       } #>  895 :       out__.write(w_out); #>  896 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  897 :       current_statement__ = 6; #>  898 :       b_out = context__.vals_r(\"b_out\")[(1 - 1)]; #>  899 :       out__.write(b_out); #>  900 :       local_scalar_t__ sigma = DUMMY_VAR__; #>  901 :       current_statement__ = 7; #>  902 :       sigma = context__.vals_r(\"sigma\")[(1 - 1)]; #>  903 :       out__.write_free_lb(0, sigma); #>  904 :     } catch (const std::exception& e) { #>  905 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  906 :     } #>  907 :   } #>  908 :   inline void #>  909 :   get_param_names(std::vector<std::string>& names__, const bool #>  910 :                   emit_transformed_parameters__ = true, const bool #>  911 :                   emit_generated_quantities__ = true) const { #>  912 :     names__ = std::vector<std::string>{\"w1\", \"b1\", \"w2\", \"b2\", \"w_out\", #>  913 :                 \"b_out\", \"sigma\"}; #>  914 :     if (emit_transformed_parameters__) { #>  915 :       std::vector<std::string> temp{\"z1\", \"a1\", \"z2\", \"a2\", \"y_hat\"}; #>  916 :       names__.reserve(names__.size() + temp.size()); #>  917 :       names__.insert(names__.end(), temp.begin(), temp.end()); #>  918 :     } #>  919 :     if (emit_generated_quantities__) {} #>  920 :   } #>  921 :   inline void #>  922 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool #>  923 :            emit_transformed_parameters__ = true, const bool #>  924 :            emit_generated_quantities__ = true) const { #>  925 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast< #>  926 :                                                                     size_t>(m), #>  927 :                                                  static_cast<size_t>( #>  928 :                                                    w1_2dim__)}, #>  929 :                 std::vector<size_t>{static_cast<size_t>(b1_1dim__)}, #>  930 :                 std::vector<size_t>{static_cast<size_t>(w2_1dim__), #>  931 :                   static_cast<size_t>(w2_2dim__)}, #>  932 :                 std::vector<size_t>{static_cast<size_t>(b2_1dim__)}, #>  933 :                 std::vector<size_t>{static_cast<size_t>(w_out_1dim__)}, #>  934 :                 std::vector<size_t>{}, std::vector<size_t>{}}; #>  935 :     if (emit_transformed_parameters__) { #>  936 :       std::vector<std::vector<size_t>> #>  937 :         temp{std::vector<size_t>{static_cast<size_t>(n), #>  938 :                static_cast<size_t>(z1_2dim__)}, #>  939 :              std::vector<size_t>{static_cast<size_t>(n), #>  940 :                static_cast<size_t>(a1_2dim__)}, #>  941 :              std::vector<size_t>{static_cast<size_t>(n), #>  942 :                static_cast<size_t>(z2_2dim__)}, #>  943 :              std::vector<size_t>{static_cast<size_t>(n), #>  944 :                static_cast<size_t>(a2_2dim__)}, #>  945 :              std::vector<size_t>{static_cast<size_t>(n)}}; #>  946 :       dimss__.reserve(dimss__.size() + temp.size()); #>  947 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end()); #>  948 :     } #>  949 :     if (emit_generated_quantities__) {} #>  950 :   } #>  951 :   inline void #>  952 :   constrained_param_names(std::vector<std::string>& param_names__, bool #>  953 :                           emit_transformed_parameters__ = true, bool #>  954 :                           emit_generated_quantities__ = true) const final { #>  955 :     for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #>  956 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  957 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #>  958 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  959 :       } #>  960 :     } #>  961 :     for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #>  962 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #>  963 :         std::to_string(sym1__)); #>  964 :     } #>  965 :     for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #>  966 :       for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #>  967 :         param_names__.emplace_back(std::string() + \"w2\" + '.' + #>  968 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  969 :       } #>  970 :     } #>  971 :     for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #>  972 :       param_names__.emplace_back(std::string() + \"b2\" + '.' + #>  973 :         std::to_string(sym1__)); #>  974 :     } #>  975 :     for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #>  976 :       param_names__.emplace_back(std::string() + \"w_out\" + '.' + #>  977 :         std::to_string(sym1__)); #>  978 :     } #>  979 :     param_names__.emplace_back(std::string() + \"b_out\"); #>  980 :     param_names__.emplace_back(std::string() + \"sigma\"); #>  981 :     if (emit_transformed_parameters__) { #>  982 :       for (int sym1__ = 1; sym1__ <= z1_2dim__; ++sym1__) { #>  983 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  984 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #>  985 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  986 :         } #>  987 :       } #>  988 :       for (int sym1__ = 1; sym1__ <= a1_2dim__; ++sym1__) { #>  989 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  990 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #>  991 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  992 :         } #>  993 :       } #>  994 :       for (int sym1__ = 1; sym1__ <= z2_2dim__; ++sym1__) { #>  995 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  996 :           param_names__.emplace_back(std::string() + \"z2\" + '.' + #>  997 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  998 :         } #>  999 :       } #> 1000 :       for (int sym1__ = 1; sym1__ <= a2_2dim__; ++sym1__) { #> 1001 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1002 :           param_names__.emplace_back(std::string() + \"a2\" + '.' + #> 1003 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1004 :         } #> 1005 :       } #> 1006 :       for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #> 1007 :         param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #> 1008 :           std::to_string(sym1__)); #> 1009 :       } #> 1010 :     } #> 1011 :     if (emit_generated_quantities__) {} #> 1012 :   } #> 1013 :   inline void #> 1014 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool #> 1015 :                             emit_transformed_parameters__ = true, bool #> 1016 :                             emit_generated_quantities__ = true) const final { #> 1017 :     for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #> 1018 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #> 1019 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #> 1020 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1021 :       } #> 1022 :     } #> 1023 :     for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #> 1024 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #> 1025 :         std::to_string(sym1__)); #> 1026 :     } #> 1027 :     for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #> 1028 :       for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #> 1029 :         param_names__.emplace_back(std::string() + \"w2\" + '.' + #> 1030 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1031 :       } #> 1032 :     } #> 1033 :     for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #> 1034 :       param_names__.emplace_back(std::string() + \"b2\" + '.' + #> 1035 :         std::to_string(sym1__)); #> 1036 :     } #> 1037 :     for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #> 1038 :       param_names__.emplace_back(std::string() + \"w_out\" + '.' + #> 1039 :         std::to_string(sym1__)); #> 1040 :     } #> 1041 :     param_names__.emplace_back(std::string() + \"b_out\"); #> 1042 :     param_names__.emplace_back(std::string() + \"sigma\"); #> 1043 :     if (emit_transformed_parameters__) { #> 1044 :       for (int sym1__ = 1; sym1__ <= z1_2dim__; ++sym1__) { #> 1045 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1046 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #> 1047 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1048 :         } #> 1049 :       } #> 1050 :       for (int sym1__ = 1; sym1__ <= a1_2dim__; ++sym1__) { #> 1051 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1052 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #> 1053 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1054 :         } #> 1055 :       } #> 1056 :       for (int sym1__ = 1; sym1__ <= z2_2dim__; ++sym1__) { #> 1057 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1058 :           param_names__.emplace_back(std::string() + \"z2\" + '.' + #> 1059 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1060 :         } #> 1061 :       } #> 1062 :       for (int sym1__ = 1; sym1__ <= a2_2dim__; ++sym1__) { #> 1063 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1064 :           param_names__.emplace_back(std::string() + \"a2\" + '.' + #> 1065 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1066 :         } #> 1067 :       } #> 1068 :       for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #> 1069 :         param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #> 1070 :           std::to_string(sym1__)); #> 1071 :       } #> 1072 :     } #> 1073 :     if (emit_generated_quantities__) {} #> 1074 :   } #> 1075 :   inline std::string get_constrained_sizedtypes() const { #> 1076 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(w1_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b1_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w2_1dim__) + \",\\\"cols\\\":\" + std::to_string(w2_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b2\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b2_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(w_out_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"sigma\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(n) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #> 1077 :   } #> 1078 :   inline std::string get_unconstrained_sizedtypes() const { #> 1079 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(w1_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b1_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w2_1dim__) + \",\\\"cols\\\":\" + std::to_string(w2_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b2\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b2_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(w_out_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"sigma\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(n) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #> 1080 :   } #> 1081 :   // Begin method overload boilerplate #> 1082 :   template <typename RNG> inline void #> 1083 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r, #> 1084 :               Eigen::Matrix<double,-1,1>& vars, const bool #> 1085 :               emit_transformed_parameters = true, const bool #> 1086 :               emit_generated_quantities = true, std::ostream* #> 1087 :               pstream = nullptr) const { #> 1088 :     const size_t num_params__ = (((((((m * w1_2dim__) + b1_1dim__) + #> 1089 :       (w2_1dim__ * w2_2dim__)) + b2_1dim__) + w_out_1dim__) + 1) + 1); #> 1090 :     const size_t num_transformed = emit_transformed_parameters * ((((((n * #> 1091 :       z1_2dim__) + (n * a1_2dim__)) + (n * z2_2dim__)) + (n * a2_2dim__)) + #> 1092 :       n)); #> 1093 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #> 1094 :     const size_t num_to_write = num_params__ + num_transformed + #> 1095 :       num_gen_quantities; #> 1096 :     std::vector<int> params_i; #> 1097 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write, #> 1098 :              std::numeric_limits<double>::quiet_NaN()); #> 1099 :     write_array_impl(base_rng, params_r, params_i, vars, #> 1100 :       emit_transformed_parameters, emit_generated_quantities, pstream); #> 1101 :   } #> 1102 :   template <typename RNG> inline void #> 1103 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>& #> 1104 :               params_i, std::vector<double>& vars, bool #> 1105 :               emit_transformed_parameters = true, bool #> 1106 :               emit_generated_quantities = true, std::ostream* #> 1107 :               pstream = nullptr) const { #> 1108 :     const size_t num_params__ = (((((((m * w1_2dim__) + b1_1dim__) + #> 1109 :       (w2_1dim__ * w2_2dim__)) + b2_1dim__) + w_out_1dim__) + 1) + 1); #> 1110 :     const size_t num_transformed = emit_transformed_parameters * ((((((n * #> 1111 :       z1_2dim__) + (n * a1_2dim__)) + (n * z2_2dim__)) + (n * a2_2dim__)) + #> 1112 :       n)); #> 1113 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #> 1114 :     const size_t num_to_write = num_params__ + num_transformed + #> 1115 :       num_gen_quantities; #> 1116 :     vars = std::vector<double>(num_to_write, #> 1117 :              std::numeric_limits<double>::quiet_NaN()); #> 1118 :     write_array_impl(base_rng, params_r, params_i, vars, #> 1119 :       emit_transformed_parameters, emit_generated_quantities, pstream); #> 1120 :   } #> 1121 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #> 1122 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const { #> 1123 :     Eigen::Matrix<int,-1,1> params_i; #> 1124 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #> 1125 :   } #> 1126 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #> 1127 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i, #> 1128 :            std::ostream* pstream = nullptr) const { #> 1129 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #> 1130 :   } #> 1131 :   inline void #> 1132 :   transform_inits(const stan::io::var_context& context, #> 1133 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream* #> 1134 :                   pstream = nullptr) const final { #> 1135 :     std::vector<double> params_r_vec(params_r.size()); #> 1136 :     std::vector<int> params_i; #> 1137 :     transform_inits(context, params_i, params_r_vec, pstream); #> 1138 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(), #> 1139 :                  params_r_vec.size()); #> 1140 :   } #> 1141 :   inline void #> 1142 :   transform_inits(const stan::io::var_context& context, std::vector<int>& #> 1143 :                   params_i, std::vector<double>& vars, std::ostream* #> 1144 :                   pstream__ = nullptr) const { #> 1145 :     vars.resize(num_params_r__); #> 1146 :     transform_inits_impl(context, vars, pstream__); #> 1147 :   } #> 1148 :   inline void #> 1149 :   unconstrain_array(const std::vector<double>& params_constrained, #> 1150 :                     std::vector<double>& params_unconstrained, std::ostream* #> 1151 :                     pstream = nullptr) const { #> 1152 :     const std::vector<int> params_i; #> 1153 :     params_unconstrained = std::vector<double>(num_params_r__, #> 1154 :                              std::numeric_limits<double>::quiet_NaN()); #> 1155 :     unconstrain_array_impl(params_constrained, params_i, #> 1156 :       params_unconstrained, pstream); #> 1157 :   } #> 1158 :   inline void #> 1159 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained, #> 1160 :                     Eigen::Matrix<double,-1,1>& params_unconstrained, #> 1161 :                     std::ostream* pstream = nullptr) const { #> 1162 :     const std::vector<int> params_i; #> 1163 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__, #> 1164 :                              std::numeric_limits<double>::quiet_NaN()); #> 1165 :     unconstrain_array_impl(params_constrained, params_i, #> 1166 :       params_unconstrained, pstream); #> 1167 :   } #> 1168 : }; #> 1169 : } #> 1170 : using stan_model = model3cfa7929f5b1__namespace::model3cfa7929f5b1_; #> 1171 : #ifndef USING_R #> 1172 : // Boilerplate #> 1173 : stan::model::model_base& #> 1174 : new_model(stan::io::var_context& data_context, unsigned int seed, #> 1175 :           std::ostream* msg_stream) { #> 1176 :   stan_model* m = new stan_model(data_context, seed, msg_stream); #> 1177 :   return *m; #> 1178 : } #> 1179 : stan::math::profile_map& get_stan_profile_data() { #> 1180 :   return model3cfa7929f5b1__namespace::profiles__; #> 1181 : } #> 1182 : #endif #> 1183 : #endif #> 1184 :  #> 1185 : RCPP_MODULE(stan_fit4model3cfa7929f5b1__mod) { #> 1186 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >( #> 1187 :       \"stan_fit4model3cfa7929f5b1_\") #> 1188 :  #> 1189 :       .constructor<SEXP, SEXP, SEXP>() #> 1190 :  #> 1191 :       .method( #> 1192 :           \"call_sampler\", #> 1193 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler) #> 1194 :       .method( #> 1195 :           \"param_names\", #> 1196 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names) #> 1197 :       .method(\"param_names_oi\", #> 1198 :               &rstan::stan_fit<stan_model, #> 1199 :                                boost::random::ecuyer1988>::param_names_oi) #> 1200 :       .method(\"param_fnames_oi\", #> 1201 :               &rstan::stan_fit<stan_model, #> 1202 :                                boost::random::ecuyer1988>::param_fnames_oi) #> 1203 :       .method( #> 1204 :           \"param_dims\", #> 1205 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims) #> 1206 :       .method(\"param_dims_oi\", #> 1207 :               &rstan::stan_fit<stan_model, #> 1208 :                                boost::random::ecuyer1988>::param_dims_oi) #> 1209 :       .method(\"update_param_oi\", #> 1210 :               &rstan::stan_fit<stan_model, #> 1211 :                                boost::random::ecuyer1988>::update_param_oi) #> 1212 :       .method(\"param_oi_tidx\", #> 1213 :               &rstan::stan_fit<stan_model, #> 1214 :                                boost::random::ecuyer1988>::param_oi_tidx) #> 1215 :       .method(\"grad_log_prob\", #> 1216 :               &rstan::stan_fit<stan_model, #> 1217 :                                boost::random::ecuyer1988>::grad_log_prob) #> 1218 :       .method(\"log_prob\", #> 1219 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob) #> 1220 :       .method(\"unconstrain_pars\", #> 1221 :               &rstan::stan_fit<stan_model, #> 1222 :                                boost::random::ecuyer1988>::unconstrain_pars) #> 1223 :       .method(\"constrain_pars\", #> 1224 :               &rstan::stan_fit<stan_model, #> 1225 :                                boost::random::ecuyer1988>::constrain_pars) #> 1226 :       .method( #> 1227 :           \"num_pars_unconstrained\", #> 1228 :           &rstan::stan_fit<stan_model, #> 1229 :                            boost::random::ecuyer1988>::num_pars_unconstrained) #> 1230 :       .method( #> 1231 :           \"unconstrained_param_names\", #> 1232 :           &rstan::stan_fit< #> 1233 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names) #> 1234 :       .method( #> 1235 :           \"constrained_param_names\", #> 1236 :           &rstan::stan_fit<stan_model, #> 1237 :                            boost::random::ecuyer1988>::constrained_param_names) #> 1238 :       .method(\"standalone_gqs\", #> 1239 :               &rstan::stan_fit<stan_model, #> 1240 :                                boost::random::ecuyer1988>::standalone_gqs); #> 1241 : } #> 1242 :  #> 1243 :  #> 1244 : // declarations #> 1245 : extern \"C\" { #> 1246 : SEXP file3cfa14970865( ) ; #> 1247 : } #> 1248 :  #> 1249 : // definition #> 1250 : SEXP file3cfa14970865() { #> 1251 :  return Rcpp::wrap(\"anon_model\"); #> 1252 : } #>  #> CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW. #>  #> COMPILING MODEL 'anon_model' NOW. #>  #> STARTING SAMPLER FOR MODEL 'anon_model' NOW."},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"id_3-model-summary","dir":"","previous_headings":"Getting Started","what":"3. Model Summary","title":"Bayesian Neural Network with Stan","text":"Summarize fitted model:","code":"summary(model) #> Call: #> bnns.formula(formula = y ~ -1 + x1 + x2, data = df, L = 2, nodes = c(10,  #>     8), act_fn = c(2, 3), out_act_fn = 1, iter = 200, warmup = 100,  #>     chains = 1, seed = 123) #>  #> Data Summary: #> Number of observations: 10  #> Number of features: 2  #>  #> Network Architecture: #> Number of hidden layers: 2  #> Nodes per layer: 10, 8  #> Activation functions: 2, 3  #> Output activation function: 1  #>  #> Posterior Summary (Key Parameters): #>                  mean    se_mean        sd       2.5%        25%         50% #> w_out[1] -0.162133579 0.07772327 1.0991730 -2.1116312 -0.9390165 -0.03503437 #> w_out[2]  0.021418667 0.07437495 0.9896028 -2.1611520 -0.6301115  0.06866878 #> w_out[3] -0.002041538 0.09523759 1.1020433 -2.0465230 -0.8329012  0.04072538 #> w_out[4] -0.091509264 0.10415390 0.9905132 -2.2855084 -0.7830352  0.03058487 #> w_out[5] -0.126991909 0.12060092 1.0728276 -1.9425644 -0.8530244 -0.35810172 #> w_out[6]  0.183296279 0.10112087 0.9626945 -1.5855053 -0.5166333  0.12032066 #> w_out[7]  0.122926494 0.10005766 0.9263347 -1.5887060 -0.4925761  0.18989083 #> w_out[8]  0.026961513 0.10391497 1.0235879 -2.1473055 -0.6427260  0.09473320 #> b_out    -0.004724008 0.08919397 0.9390003 -1.7917247 -0.6540982  0.03236448 #> sigma     0.931829325 0.03158302 0.2479854  0.5805703  0.7514319  0.86695836 #>                75%    97.5%     n_eff      Rhat #> w_out[1] 0.5794187 2.234899 200.00000 0.9929056 #> w_out[2] 0.5889855 1.849656 177.03880 0.9965019 #> w_out[3] 0.8200063 1.954492 133.89998 0.9980318 #> w_out[4] 0.6982179 1.375559  90.44186 0.9938695 #> w_out[5] 0.6756810 2.170041  79.13319 0.9901413 #> w_out[6] 0.9867396 1.857302  90.63490 1.0221722 #> w_out[7] 0.7441406 1.637340  85.71073 1.0042971 #> w_out[8] 0.7741426 1.921367  97.02732 0.9911107 #> b_out    0.5800429 1.731874 110.83081 0.9937312 #> sigma    1.0919060 1.500315  61.65167 1.0428953 #>  #> Model Fit Information: #> Iterations: 200  #> Warmup: 100  #> Thinning: 1  #> Chains: 1  #>  #> Predictive Performance: #> RMSE (training): 0.730921  #> MAE (training): 0.5753889  #>  #> Notes: #> Check convergence diagnostics for parameters with high R-hat values."},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"id_4-predictions","dir":"","previous_headings":"Getting Started","what":"4. Predictions","title":"Bayesian Neural Network with Stan","text":"Make predictions using trained model:","code":"pred <- predict(model)"},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"id_5-visualization","dir":"","previous_headings":"Getting Started","what":"5. Visualization","title":"Bayesian Neural Network with Stan","text":"Visualize true vs predicted values regression:","code":"plot(df$y, rowMeans(pred), main = \"True vs Predicted\", xlab = \"True Values\", ylab = \"Predicted Values\") abline(0, 1, col = \"red\")"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"regression-example","dir":"","previous_headings":"Applications","what":"Regression Example","title":"Bayesian Neural Network with Stan","text":"Use bnns regression analysis model continuous outcomes, predicting patient biomarkers clinical trials.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"classification-example","dir":"","previous_headings":"Applications","what":"Classification Example","title":"Bayesian Neural Network with Stan","text":"binary multiclass classification, set out_act_fn 2 (binary) 3 (multiclass). example:","code":"# Simulate binary classification data df <- data.frame(x1 = runif(10), x2 = runif(10), y = sample(0:1, 10, replace = TRUE))  # Fit a binary classification BNN model <- bnns(y ~ -1 + x1 + x2, data = df, L = 2, nodes = c(16, 8), act_fn = c(3, 2), out_act_fn = 2, iter = 2e2, warmup = 1e2, chains = 1) #>  #> TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW. #> OS: x86_64, linux-gnu; rstan: 2.32.6; Rcpp: 1.0.13.1; inline: 0.3.20  #>  >> setting environment variables:  #> PKG_LIBS =  '/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/rstan/lib//libStanServices.a' -L'/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/lib/' -lStanHeaders -L'/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/RcppParallel/lib/' -ltbb  #> PKG_CPPFLAGS =   -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/Rcpp/include/\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/unsupported\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/BH/include\" -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/src/\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/RcppParallel/include/\"  -I\"/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/rstan/include\" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/antpc/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1  #>  >> Program source : #>  #>    1 :  #>    2 : // includes from the plugin #>    3 : // [[Rcpp::plugins(cpp14)]] #>    4 :  #>    5 :  #>    6 : // user includes #>    7 : #include <Rcpp.h> #>    8 : using namespace Rcpp; #>    9 : #ifndef MODELS_HPP #>   10 : #define MODELS_HPP #>   11 : #define STAN__SERVICES__COMMAND_HPP #>   12 : #include <rstan/rstaninc.hpp> #>   13 : #ifndef USE_STANC3 #>   14 : #define USE_STANC3 #>   15 : #endif #>   16 : // Code generated by stanc v2.32.2 #>   17 : #include <stan/model/model_header.hpp> #>   18 : namespace model3cfa60feea29__namespace { #>   19 : using stan::model::model_base_crtp; #>   20 : using namespace stan::math; #>   21 : stan::math::profile_map profiles__; #>   22 : static constexpr std::array<const char*, 64> locations_array__ = #>   23 :   {\" (found before start of program)\", #>   24 :   \" (in 'anon_model', line 11, column 2 to column 25)\", #>   25 :   \" (in 'anon_model', line 12, column 2 to column 22)\", #>   26 :   \" (in 'anon_model', line 13, column 2 to column 32)\", #>   27 :   \" (in 'anon_model', line 14, column 2 to column 22)\", #>   28 :   \" (in 'anon_model', line 15, column 2 to column 25)\", #>   29 :   \" (in 'anon_model', line 16, column 2 to column 13)\", #>   30 :   \" (in 'anon_model', line 19, column 2 to column 25)\", #>   31 :   \" (in 'anon_model', line 20, column 2 to column 25)\", #>   32 :   \" (in 'anon_model', line 21, column 2 to column 25)\", #>   33 :   \" (in 'anon_model', line 22, column 2 to column 25)\", #>   34 :   \" (in 'anon_model', line 23, column 2 to column 18)\", #>   35 :   \" (in 'anon_model', line 24, column 2 to column 35)\", #>   36 :   \" (in 'anon_model', line 28, column 7 to column 49)\", #>   37 :   \" (in 'anon_model', line 27, column 27 to column 49)\", #>   38 :   \" (in 'anon_model', line 27, column 7 to line 28, column 49)\", #>   39 :   \" (in 'anon_model', line 26, column 27 to column 46)\", #>   40 :   \" (in 'anon_model', line 26, column 7 to line 28, column 49)\", #>   41 :   \" (in 'anon_model', line 25, column 22 to column 36)\", #>   42 :   \" (in 'anon_model', line 25, column 2 to line 28, column 49)\", #>   43 :   \" (in 'anon_model', line 29, column 2 to column 36)\", #>   44 :   \" (in 'anon_model', line 33, column 7 to column 49)\", #>   45 :   \" (in 'anon_model', line 32, column 27 to column 49)\", #>   46 :   \" (in 'anon_model', line 32, column 7 to line 33, column 49)\", #>   47 :   \" (in 'anon_model', line 31, column 27 to column 46)\", #>   48 :   \" (in 'anon_model', line 31, column 7 to line 33, column 49)\", #>   49 :   \" (in 'anon_model', line 30, column 22 to column 36)\", #>   50 :   \" (in 'anon_model', line 30, column 2 to line 33, column 49)\", #>   51 :   \" (in 'anon_model', line 34, column 2 to column 29)\", #>   52 :   \" (in 'anon_model', line 37, column 2 to column 31)\", #>   53 :   \" (in 'anon_model', line 38, column 2 to column 20)\", #>   54 :   \" (in 'anon_model', line 39, column 2 to column 31)\", #>   55 :   \" (in 'anon_model', line 40, column 2 to column 20)\", #>   56 :   \" (in 'anon_model', line 41, column 2 to column 23)\", #>   57 :   \" (in 'anon_model', line 42, column 2 to column 23)\", #>   58 :   \" (in 'anon_model', line 43, column 2 to column 29)\", #>   59 :   \" (in 'anon_model', line 2, column 2 to column 17)\", #>   60 :   \" (in 'anon_model', line 3, column 2 to column 17)\", #>   61 :   \" (in 'anon_model', line 4, column 2 to column 17)\", #>   62 :   \" (in 'anon_model', line 5, column 21 to column 22)\", #>   63 :   \" (in 'anon_model', line 5, column 2 to column 24)\", #>   64 :   \" (in 'anon_model', line 6, column 9 to column 10)\", #>   65 :   \" (in 'anon_model', line 6, column 12 to column 13)\", #>   66 :   \" (in 'anon_model', line 6, column 2 to column 17)\", #>   67 :   \" (in 'anon_model', line 7, column 8 to column 9)\", #>   68 :   \" (in 'anon_model', line 7, column 2 to column 35)\", #>   69 :   \" (in 'anon_model', line 8, column 22 to column 23)\", #>   70 :   \" (in 'anon_model', line 8, column 2 to column 25)\", #>   71 :   \" (in 'anon_model', line 11, column 9 to column 10)\", #>   72 :   \" (in 'anon_model', line 11, column 12 to column 20)\", #>   73 :   \" (in 'anon_model', line 12, column 9 to column 17)\", #>   74 :   \" (in 'anon_model', line 13, column 9 to column 17)\", #>   75 :   \" (in 'anon_model', line 13, column 19 to column 27)\", #>   76 :   \" (in 'anon_model', line 14, column 9 to column 17)\", #>   77 :   \" (in 'anon_model', line 15, column 9 to column 17)\", #>   78 :   \" (in 'anon_model', line 19, column 9 to column 10)\", #>   79 :   \" (in 'anon_model', line 19, column 12 to column 20)\", #>   80 :   \" (in 'anon_model', line 20, column 9 to column 10)\", #>   81 :   \" (in 'anon_model', line 20, column 12 to column 20)\", #>   82 :   \" (in 'anon_model', line 21, column 9 to column 10)\", #>   83 :   \" (in 'anon_model', line 21, column 12 to column 20)\", #>   84 :   \" (in 'anon_model', line 22, column 9 to column 10)\", #>   85 :   \" (in 'anon_model', line 22, column 12 to column 20)\", #>   86 :   \" (in 'anon_model', line 23, column 9 to column 10)\"}; #>   87 : class model3cfa60feea29_ final : public model_base_crtp<model3cfa60feea29_> { #>   88 : private: #>   89 :   int n; #>   90 :   int m; #>   91 :   int L; #>   92 :   std::vector<int> nodes; #>   93 :   Eigen::Matrix<double,-1,-1> X_data__; #>   94 :   std::vector<int> y; #>   95 :   std::vector<int> act_fn; #>   96 :   int w1_2dim__; #>   97 :   int b1_1dim__; #>   98 :   int w2_1dim__; #>   99 :   int w2_2dim__; #>  100 :   int b2_1dim__; #>  101 :   int w_out_1dim__; #>  102 :   int z1_2dim__; #>  103 :   int a1_2dim__; #>  104 :   int z2_2dim__; #>  105 :   int a2_2dim__; #>  106 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> X{nullptr, 0, 0}; #>  107 : public: #>  108 :   ~model3cfa60feea29_() {} #>  109 :   model3cfa60feea29_(stan::io::var_context& context__, unsigned int #>  110 :                      random_seed__ = 0, std::ostream* pstream__ = nullptr) #>  111 :       : model_base_crtp(0) { #>  112 :     int current_statement__ = 0; #>  113 :     using local_scalar_t__ = double; #>  114 :     boost::ecuyer1988 base_rng__ = #>  115 :       stan::services::util::create_rng(random_seed__, 0); #>  116 :     // suppress unused var warning #>  117 :     (void) base_rng__; #>  118 :     static constexpr const char* function__ = #>  119 :       \"model3cfa60feea29__namespace::model3cfa60feea29_\"; #>  120 :     // suppress unused var warning #>  121 :     (void) function__; #>  122 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  123 :     // suppress unused var warning #>  124 :     (void) DUMMY_VAR__; #>  125 :     try { #>  126 :       int pos__ = std::numeric_limits<int>::min(); #>  127 :       pos__ = 1; #>  128 :       current_statement__ = 36; #>  129 :       context__.validate_dims(\"data initialization\", \"n\", \"int\", #>  130 :         std::vector<size_t>{}); #>  131 :       n = std::numeric_limits<int>::min(); #>  132 :       current_statement__ = 36; #>  133 :       n = context__.vals_i(\"n\")[(1 - 1)]; #>  134 :       current_statement__ = 36; #>  135 :       stan::math::check_greater_or_equal(function__, \"n\", n, 1); #>  136 :       current_statement__ = 37; #>  137 :       context__.validate_dims(\"data initialization\", \"m\", \"int\", #>  138 :         std::vector<size_t>{}); #>  139 :       m = std::numeric_limits<int>::min(); #>  140 :       current_statement__ = 37; #>  141 :       m = context__.vals_i(\"m\")[(1 - 1)]; #>  142 :       current_statement__ = 37; #>  143 :       stan::math::check_greater_or_equal(function__, \"m\", m, 1); #>  144 :       current_statement__ = 38; #>  145 :       context__.validate_dims(\"data initialization\", \"L\", \"int\", #>  146 :         std::vector<size_t>{}); #>  147 :       L = std::numeric_limits<int>::min(); #>  148 :       current_statement__ = 38; #>  149 :       L = context__.vals_i(\"L\")[(1 - 1)]; #>  150 :       current_statement__ = 38; #>  151 :       stan::math::check_greater_or_equal(function__, \"L\", L, 1); #>  152 :       current_statement__ = 39; #>  153 :       stan::math::validate_non_negative_index(\"nodes\", \"L\", L); #>  154 :       current_statement__ = 40; #>  155 :       context__.validate_dims(\"data initialization\", \"nodes\", \"int\", #>  156 :         std::vector<size_t>{static_cast<size_t>(L)}); #>  157 :       nodes = std::vector<int>(L, std::numeric_limits<int>::min()); #>  158 :       current_statement__ = 40; #>  159 :       nodes = context__.vals_i(\"nodes\"); #>  160 :       current_statement__ = 40; #>  161 :       stan::math::check_greater_or_equal(function__, \"nodes\", nodes, 1); #>  162 :       current_statement__ = 41; #>  163 :       stan::math::validate_non_negative_index(\"X\", \"n\", n); #>  164 :       current_statement__ = 42; #>  165 :       stan::math::validate_non_negative_index(\"X\", \"m\", m); #>  166 :       current_statement__ = 43; #>  167 :       context__.validate_dims(\"data initialization\", \"X\", \"double\", #>  168 :         std::vector<size_t>{static_cast<size_t>(n), static_cast<size_t>(m)}); #>  169 :       X_data__ = Eigen::Matrix<double,-1,-1>::Constant(n, m, #>  170 :                    std::numeric_limits<double>::quiet_NaN()); #>  171 :       new (&X) Eigen::Map<Eigen::Matrix<double,-1,-1>>(X_data__.data(), n, m); #>  172 :       { #>  173 :         std::vector<local_scalar_t__> X_flat__; #>  174 :         current_statement__ = 43; #>  175 :         X_flat__ = context__.vals_r(\"X\"); #>  176 :         current_statement__ = 43; #>  177 :         pos__ = 1; #>  178 :         current_statement__ = 43; #>  179 :         for (int sym1__ = 1; sym1__ <= m; ++sym1__) { #>  180 :           current_statement__ = 43; #>  181 :           for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  182 :             current_statement__ = 43; #>  183 :             stan::model::assign(X, X_flat__[(pos__ - 1)], #>  184 :               \"assigning variable X\", stan::model::index_uni(sym2__), #>  185 :               stan::model::index_uni(sym1__)); #>  186 :             current_statement__ = 43; #>  187 :             pos__ = (pos__ + 1); #>  188 :           } #>  189 :         } #>  190 :       } #>  191 :       current_statement__ = 44; #>  192 :       stan::math::validate_non_negative_index(\"y\", \"n\", n); #>  193 :       current_statement__ = 45; #>  194 :       context__.validate_dims(\"data initialization\", \"y\", \"int\", #>  195 :         std::vector<size_t>{static_cast<size_t>(n)}); #>  196 :       y = std::vector<int>(n, std::numeric_limits<int>::min()); #>  197 :       current_statement__ = 45; #>  198 :       y = context__.vals_i(\"y\"); #>  199 :       current_statement__ = 45; #>  200 :       stan::math::check_greater_or_equal(function__, \"y\", y, 0); #>  201 :       current_statement__ = 45; #>  202 :       stan::math::check_less_or_equal(function__, \"y\", y, 1); #>  203 :       current_statement__ = 46; #>  204 :       stan::math::validate_non_negative_index(\"act_fn\", \"L\", L); #>  205 :       current_statement__ = 47; #>  206 :       context__.validate_dims(\"data initialization\", \"act_fn\", \"int\", #>  207 :         std::vector<size_t>{static_cast<size_t>(L)}); #>  208 :       act_fn = std::vector<int>(L, std::numeric_limits<int>::min()); #>  209 :       current_statement__ = 47; #>  210 :       act_fn = context__.vals_i(\"act_fn\"); #>  211 :       current_statement__ = 47; #>  212 :       stan::math::check_greater_or_equal(function__, \"act_fn\", act_fn, 1); #>  213 :       current_statement__ = 48; #>  214 :       stan::math::validate_non_negative_index(\"w1\", \"m\", m); #>  215 :       current_statement__ = 49; #>  216 :       w1_2dim__ = std::numeric_limits<int>::min(); #>  217 :       current_statement__ = 49; #>  218 :       w1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  219 :                     stan::model::index_uni(1)); #>  220 :       current_statement__ = 49; #>  221 :       stan::math::validate_non_negative_index(\"w1\", \"nodes[1]\", w1_2dim__); #>  222 :       current_statement__ = 50; #>  223 :       b1_1dim__ = std::numeric_limits<int>::min(); #>  224 :       current_statement__ = 50; #>  225 :       b1_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  226 :                     stan::model::index_uni(1)); #>  227 :       current_statement__ = 50; #>  228 :       stan::math::validate_non_negative_index(\"b1\", \"nodes[1]\", b1_1dim__); #>  229 :       current_statement__ = 51; #>  230 :       w2_1dim__ = std::numeric_limits<int>::min(); #>  231 :       current_statement__ = 51; #>  232 :       w2_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  233 :                     stan::model::index_uni(1)); #>  234 :       current_statement__ = 51; #>  235 :       stan::math::validate_non_negative_index(\"w2\", \"nodes[1]\", w2_1dim__); #>  236 :       current_statement__ = 52; #>  237 :       w2_2dim__ = std::numeric_limits<int>::min(); #>  238 :       current_statement__ = 52; #>  239 :       w2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  240 :                     stan::model::index_uni(2)); #>  241 :       current_statement__ = 52; #>  242 :       stan::math::validate_non_negative_index(\"w2\", \"nodes[2]\", w2_2dim__); #>  243 :       current_statement__ = 53; #>  244 :       b2_1dim__ = std::numeric_limits<int>::min(); #>  245 :       current_statement__ = 53; #>  246 :       b2_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  247 :                     stan::model::index_uni(2)); #>  248 :       current_statement__ = 53; #>  249 :       stan::math::validate_non_negative_index(\"b2\", \"nodes[2]\", b2_1dim__); #>  250 :       current_statement__ = 54; #>  251 :       w_out_1dim__ = std::numeric_limits<int>::min(); #>  252 :       current_statement__ = 54; #>  253 :       w_out_1dim__ = stan::model::rvalue(nodes, \"nodes\", #>  254 :                        stan::model::index_uni(L)); #>  255 :       current_statement__ = 54; #>  256 :       stan::math::validate_non_negative_index(\"w_out\", \"nodes[L]\", #>  257 :         w_out_1dim__); #>  258 :       current_statement__ = 55; #>  259 :       stan::math::validate_non_negative_index(\"z1\", \"n\", n); #>  260 :       current_statement__ = 56; #>  261 :       z1_2dim__ = std::numeric_limits<int>::min(); #>  262 :       current_statement__ = 56; #>  263 :       z1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  264 :                     stan::model::index_uni(1)); #>  265 :       current_statement__ = 56; #>  266 :       stan::math::validate_non_negative_index(\"z1\", \"nodes[1]\", z1_2dim__); #>  267 :       current_statement__ = 57; #>  268 :       stan::math::validate_non_negative_index(\"a1\", \"n\", n); #>  269 :       current_statement__ = 58; #>  270 :       a1_2dim__ = std::numeric_limits<int>::min(); #>  271 :       current_statement__ = 58; #>  272 :       a1_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  273 :                     stan::model::index_uni(1)); #>  274 :       current_statement__ = 58; #>  275 :       stan::math::validate_non_negative_index(\"a1\", \"nodes[1]\", a1_2dim__); #>  276 :       current_statement__ = 59; #>  277 :       stan::math::validate_non_negative_index(\"z2\", \"n\", n); #>  278 :       current_statement__ = 60; #>  279 :       z2_2dim__ = std::numeric_limits<int>::min(); #>  280 :       current_statement__ = 60; #>  281 :       z2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  282 :                     stan::model::index_uni(2)); #>  283 :       current_statement__ = 60; #>  284 :       stan::math::validate_non_negative_index(\"z2\", \"nodes[2]\", z2_2dim__); #>  285 :       current_statement__ = 61; #>  286 :       stan::math::validate_non_negative_index(\"a2\", \"n\", n); #>  287 :       current_statement__ = 62; #>  288 :       a2_2dim__ = std::numeric_limits<int>::min(); #>  289 :       current_statement__ = 62; #>  290 :       a2_2dim__ = stan::model::rvalue(nodes, \"nodes\", #>  291 :                     stan::model::index_uni(2)); #>  292 :       current_statement__ = 62; #>  293 :       stan::math::validate_non_negative_index(\"a2\", \"nodes[2]\", a2_2dim__); #>  294 :       current_statement__ = 63; #>  295 :       stan::math::validate_non_negative_index(\"y_hat\", \"n\", n); #>  296 :     } catch (const std::exception& e) { #>  297 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  298 :     } #>  299 :     num_params_r__ = (m * w1_2dim__) + b1_1dim__ + (w2_1dim__ * w2_2dim__) + #>  300 :       b2_1dim__ + w_out_1dim__ + 1; #>  301 :   } #>  302 :   inline std::string model_name() const final { #>  303 :     return \"model3cfa60feea29_\"; #>  304 :   } #>  305 :   inline std::vector<std::string> model_compile_info() const noexcept { #>  306 :     return std::vector<std::string>{\"stanc_version = stanc3 v2.32.2\", #>  307 :              \"stancflags = --\"}; #>  308 :   } #>  309 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI, #>  310 :             stan::require_vector_like_t<VecR>* = nullptr, #>  311 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  312 :   inline stan::scalar_type_t<VecR> #>  313 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream* #>  314 :                 pstream__ = nullptr) const { #>  315 :     using T__ = stan::scalar_type_t<VecR>; #>  316 :     using local_scalar_t__ = T__; #>  317 :     T__ lp__(0.0); #>  318 :     stan::math::accumulator<T__> lp_accum__; #>  319 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  320 :     int current_statement__ = 0; #>  321 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  322 :     // suppress unused var warning #>  323 :     (void) DUMMY_VAR__; #>  324 :     static constexpr const char* function__ = #>  325 :       \"model3cfa60feea29__namespace::log_prob\"; #>  326 :     // suppress unused var warning #>  327 :     (void) function__; #>  328 :     try { #>  329 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  330 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  331 :           DUMMY_VAR__); #>  332 :       current_statement__ = 1; #>  333 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  334 :              w1_2dim__); #>  335 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  336 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  337 :           DUMMY_VAR__); #>  338 :       current_statement__ = 2; #>  339 :       b1 = in__.template read< #>  340 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__); #>  341 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  342 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  343 :           DUMMY_VAR__); #>  344 :       current_statement__ = 3; #>  345 :       w2 = in__.template read< #>  346 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, w2_2dim__); #>  347 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  348 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  349 :           DUMMY_VAR__); #>  350 :       current_statement__ = 4; #>  351 :       b2 = in__.template read< #>  352 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__); #>  353 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  354 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  355 :           DUMMY_VAR__); #>  356 :       current_statement__ = 5; #>  357 :       w_out = in__.template read< #>  358 :                 Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__); #>  359 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  360 :       current_statement__ = 6; #>  361 :       b_out = in__.template read<local_scalar_t__>(); #>  362 :       Eigen::Matrix<local_scalar_t__,-1,-1> z1 = #>  363 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z1_2dim__, #>  364 :           DUMMY_VAR__); #>  365 :       Eigen::Matrix<local_scalar_t__,-1,-1> a1 = #>  366 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a1_2dim__, #>  367 :           DUMMY_VAR__); #>  368 :       Eigen::Matrix<local_scalar_t__,-1,-1> z2 = #>  369 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, z2_2dim__, #>  370 :           DUMMY_VAR__); #>  371 :       Eigen::Matrix<local_scalar_t__,-1,-1> a2 = #>  372 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n, a2_2dim__, #>  373 :           DUMMY_VAR__); #>  374 :       Eigen::Matrix<local_scalar_t__,-1,1> y_hat = #>  375 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(n, DUMMY_VAR__); #>  376 :       current_statement__ = 12; #>  377 :       stan::model::assign(z1, #>  378 :         stan::math::add(stan::math::multiply(X, w1), #>  379 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  380 :         \"assigning variable z1\"); #>  381 :       current_statement__ = 19; #>  382 :       if (stan::math::logical_eq( #>  383 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  384 :             1)) { #>  385 :         current_statement__ = 18; #>  386 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  387 :       } else { #>  388 :         current_statement__ = 17; #>  389 :         if (stan::math::logical_eq( #>  390 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  391 :               2)) { #>  392 :           current_statement__ = 16; #>  393 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  394 :             \"assigning variable a1\"); #>  395 :         } else { #>  396 :           current_statement__ = 15; #>  397 :           if (stan::math::logical_eq( #>  398 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  399 :                   stan::model::index_uni(1)), 3)) { #>  400 :             current_statement__ = 14; #>  401 :             stan::model::assign(a1, #>  402 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  403 :               \"assigning variable a1\"); #>  404 :           } else { #>  405 :             current_statement__ = 13; #>  406 :             stan::model::assign(a1, #>  407 :               stan::math::fmax( #>  408 :                 stan::math::rep_matrix(0, n, #>  409 :                   stan::model::rvalue(nodes, \"nodes\", #>  410 :                     stan::model::index_uni(1))), z1), \"assigning variable a1\"); #>  411 :           } #>  412 :         } #>  413 :       } #>  414 :       current_statement__ = 20; #>  415 :       stan::model::assign(z2, #>  416 :         stan::math::add(stan::math::multiply(a1, w2), #>  417 :           stan::math::rep_matrix(stan::math::transpose(b2), n)), #>  418 :         \"assigning variable z2\"); #>  419 :       current_statement__ = 27; #>  420 :       if (stan::math::logical_eq( #>  421 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  422 :             1)) { #>  423 :         current_statement__ = 26; #>  424 :         stan::model::assign(a2, stan::math::tanh(z2), \"assigning variable a2\"); #>  425 :       } else { #>  426 :         current_statement__ = 25; #>  427 :         if (stan::math::logical_eq( #>  428 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  429 :               2)) { #>  430 :           current_statement__ = 24; #>  431 :           stan::model::assign(a2, stan::math::inv_logit(z2), #>  432 :             \"assigning variable a2\"); #>  433 :         } else { #>  434 :           current_statement__ = 23; #>  435 :           if (stan::math::logical_eq( #>  436 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  437 :                   stan::model::index_uni(2)), 3)) { #>  438 :             current_statement__ = 22; #>  439 :             stan::model::assign(a2, #>  440 :               stan::math::log(stan::math::add(1, stan::math::exp(z2))), #>  441 :               \"assigning variable a2\"); #>  442 :           } else { #>  443 :             current_statement__ = 21; #>  444 :             stan::model::assign(a2, #>  445 :               stan::math::fmax( #>  446 :                 stan::math::rep_matrix(0, n, #>  447 :                   stan::model::rvalue(nodes, \"nodes\", #>  448 :                     stan::model::index_uni(2))), z2), \"assigning variable a2\"); #>  449 :           } #>  450 :         } #>  451 :       } #>  452 :       current_statement__ = 28; #>  453 :       stan::model::assign(y_hat, #>  454 :         stan::math::add(stan::math::multiply(a2, w_out), b_out), #>  455 :         \"assigning variable y_hat\"); #>  456 :       { #>  457 :         current_statement__ = 29; #>  458 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  459 :                          stan::math::to_vector(w1), 0, 1)); #>  460 :         current_statement__ = 30; #>  461 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b1, 0, 1)); #>  462 :         current_statement__ = 31; #>  463 :         lp_accum__.add(stan::math::normal_lpdf<propto__>( #>  464 :                          stan::math::to_vector(w2), 0, 1)); #>  465 :         current_statement__ = 32; #>  466 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b2, 0, 1)); #>  467 :         current_statement__ = 33; #>  468 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(w_out, 0, 1)); #>  469 :         current_statement__ = 34; #>  470 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(b_out, 0, 1)); #>  471 :         current_statement__ = 35; #>  472 :         lp_accum__.add(stan::math::bernoulli_logit_lpmf<propto__>(y, y_hat)); #>  473 :       } #>  474 :     } catch (const std::exception& e) { #>  475 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  476 :     } #>  477 :     lp_accum__.add(lp__); #>  478 :     return lp_accum__.sum(); #>  479 :   } #>  480 :   template <typename RNG, typename VecR, typename VecI, typename VecVar, #>  481 :             stan::require_vector_like_vt<std::is_floating_point, #>  482 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, #>  483 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point, #>  484 :             VecVar>* = nullptr> #>  485 :   inline void #>  486 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__, #>  487 :                    VecVar& vars__, const bool #>  488 :                    emit_transformed_parameters__ = true, const bool #>  489 :                    emit_generated_quantities__ = true, std::ostream* #>  490 :                    pstream__ = nullptr) const { #>  491 :     using local_scalar_t__ = double; #>  492 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  493 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  494 :     static constexpr bool propto__ = true; #>  495 :     // suppress unused var warning #>  496 :     (void) propto__; #>  497 :     double lp__ = 0.0; #>  498 :     // suppress unused var warning #>  499 :     (void) lp__; #>  500 :     int current_statement__ = 0; #>  501 :     stan::math::accumulator<double> lp_accum__; #>  502 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  503 :     // suppress unused var warning #>  504 :     (void) DUMMY_VAR__; #>  505 :     constexpr bool jacobian__ = false; #>  506 :     static constexpr const char* function__ = #>  507 :       \"model3cfa60feea29__namespace::write_array\"; #>  508 :     // suppress unused var warning #>  509 :     (void) function__; #>  510 :     try { #>  511 :       Eigen::Matrix<double,-1,-1> w1 = #>  512 :         Eigen::Matrix<double,-1,-1>::Constant(m, w1_2dim__, #>  513 :           std::numeric_limits<double>::quiet_NaN()); #>  514 :       current_statement__ = 1; #>  515 :       w1 = in__.template read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, #>  516 :              w1_2dim__); #>  517 :       Eigen::Matrix<double,-1,1> b1 = #>  518 :         Eigen::Matrix<double,-1,1>::Constant(b1_1dim__, #>  519 :           std::numeric_limits<double>::quiet_NaN()); #>  520 :       current_statement__ = 2; #>  521 :       b1 = in__.template read< #>  522 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__); #>  523 :       Eigen::Matrix<double,-1,-1> w2 = #>  524 :         Eigen::Matrix<double,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  525 :           std::numeric_limits<double>::quiet_NaN()); #>  526 :       current_statement__ = 3; #>  527 :       w2 = in__.template read< #>  528 :              Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, w2_2dim__); #>  529 :       Eigen::Matrix<double,-1,1> b2 = #>  530 :         Eigen::Matrix<double,-1,1>::Constant(b2_1dim__, #>  531 :           std::numeric_limits<double>::quiet_NaN()); #>  532 :       current_statement__ = 4; #>  533 :       b2 = in__.template read< #>  534 :              Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__); #>  535 :       Eigen::Matrix<double,-1,1> w_out = #>  536 :         Eigen::Matrix<double,-1,1>::Constant(w_out_1dim__, #>  537 :           std::numeric_limits<double>::quiet_NaN()); #>  538 :       current_statement__ = 5; #>  539 :       w_out = in__.template read< #>  540 :                 Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__); #>  541 :       double b_out = std::numeric_limits<double>::quiet_NaN(); #>  542 :       current_statement__ = 6; #>  543 :       b_out = in__.template read<local_scalar_t__>(); #>  544 :       Eigen::Matrix<double,-1,-1> z1 = #>  545 :         Eigen::Matrix<double,-1,-1>::Constant(n, z1_2dim__, #>  546 :           std::numeric_limits<double>::quiet_NaN()); #>  547 :       Eigen::Matrix<double,-1,-1> a1 = #>  548 :         Eigen::Matrix<double,-1,-1>::Constant(n, a1_2dim__, #>  549 :           std::numeric_limits<double>::quiet_NaN()); #>  550 :       Eigen::Matrix<double,-1,-1> z2 = #>  551 :         Eigen::Matrix<double,-1,-1>::Constant(n, z2_2dim__, #>  552 :           std::numeric_limits<double>::quiet_NaN()); #>  553 :       Eigen::Matrix<double,-1,-1> a2 = #>  554 :         Eigen::Matrix<double,-1,-1>::Constant(n, a2_2dim__, #>  555 :           std::numeric_limits<double>::quiet_NaN()); #>  556 :       Eigen::Matrix<double,-1,1> y_hat = #>  557 :         Eigen::Matrix<double,-1,1>::Constant(n, #>  558 :           std::numeric_limits<double>::quiet_NaN()); #>  559 :       out__.write(w1); #>  560 :       out__.write(b1); #>  561 :       out__.write(w2); #>  562 :       out__.write(b2); #>  563 :       out__.write(w_out); #>  564 :       out__.write(b_out); #>  565 :       if (stan::math::logical_negation( #>  566 :             (stan::math::primitive_value(emit_transformed_parameters__) || #>  567 :             stan::math::primitive_value(emit_generated_quantities__)))) { #>  568 :         return ; #>  569 :       } #>  570 :       current_statement__ = 12; #>  571 :       stan::model::assign(z1, #>  572 :         stan::math::add(stan::math::multiply(X, w1), #>  573 :           stan::math::rep_matrix(stan::math::transpose(b1), n)), #>  574 :         \"assigning variable z1\"); #>  575 :       current_statement__ = 19; #>  576 :       if (stan::math::logical_eq( #>  577 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  578 :             1)) { #>  579 :         current_statement__ = 18; #>  580 :         stan::model::assign(a1, stan::math::tanh(z1), \"assigning variable a1\"); #>  581 :       } else { #>  582 :         current_statement__ = 17; #>  583 :         if (stan::math::logical_eq( #>  584 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(1)), #>  585 :               2)) { #>  586 :           current_statement__ = 16; #>  587 :           stan::model::assign(a1, stan::math::inv_logit(z1), #>  588 :             \"assigning variable a1\"); #>  589 :         } else { #>  590 :           current_statement__ = 15; #>  591 :           if (stan::math::logical_eq( #>  592 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  593 :                   stan::model::index_uni(1)), 3)) { #>  594 :             current_statement__ = 14; #>  595 :             stan::model::assign(a1, #>  596 :               stan::math::log(stan::math::add(1, stan::math::exp(z1))), #>  597 :               \"assigning variable a1\"); #>  598 :           } else { #>  599 :             current_statement__ = 13; #>  600 :             stan::model::assign(a1, #>  601 :               stan::math::fmax( #>  602 :                 stan::math::rep_matrix(0, n, #>  603 :                   stan::model::rvalue(nodes, \"nodes\", #>  604 :                     stan::model::index_uni(1))), z1), \"assigning variable a1\"); #>  605 :           } #>  606 :         } #>  607 :       } #>  608 :       current_statement__ = 20; #>  609 :       stan::model::assign(z2, #>  610 :         stan::math::add(stan::math::multiply(a1, w2), #>  611 :           stan::math::rep_matrix(stan::math::transpose(b2), n)), #>  612 :         \"assigning variable z2\"); #>  613 :       current_statement__ = 27; #>  614 :       if (stan::math::logical_eq( #>  615 :             stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  616 :             1)) { #>  617 :         current_statement__ = 26; #>  618 :         stan::model::assign(a2, stan::math::tanh(z2), \"assigning variable a2\"); #>  619 :       } else { #>  620 :         current_statement__ = 25; #>  621 :         if (stan::math::logical_eq( #>  622 :               stan::model::rvalue(act_fn, \"act_fn\", stan::model::index_uni(2)), #>  623 :               2)) { #>  624 :           current_statement__ = 24; #>  625 :           stan::model::assign(a2, stan::math::inv_logit(z2), #>  626 :             \"assigning variable a2\"); #>  627 :         } else { #>  628 :           current_statement__ = 23; #>  629 :           if (stan::math::logical_eq( #>  630 :                 stan::model::rvalue(act_fn, \"act_fn\", #>  631 :                   stan::model::index_uni(2)), 3)) { #>  632 :             current_statement__ = 22; #>  633 :             stan::model::assign(a2, #>  634 :               stan::math::log(stan::math::add(1, stan::math::exp(z2))), #>  635 :               \"assigning variable a2\"); #>  636 :           } else { #>  637 :             current_statement__ = 21; #>  638 :             stan::model::assign(a2, #>  639 :               stan::math::fmax( #>  640 :                 stan::math::rep_matrix(0, n, #>  641 :                   stan::model::rvalue(nodes, \"nodes\", #>  642 :                     stan::model::index_uni(2))), z2), \"assigning variable a2\"); #>  643 :           } #>  644 :         } #>  645 :       } #>  646 :       current_statement__ = 28; #>  647 :       stan::model::assign(y_hat, #>  648 :         stan::math::add(stan::math::multiply(a2, w_out), b_out), #>  649 :         \"assigning variable y_hat\"); #>  650 :       if (emit_transformed_parameters__) { #>  651 :         out__.write(z1); #>  652 :         out__.write(a1); #>  653 :         out__.write(z2); #>  654 :         out__.write(a2); #>  655 :         out__.write(y_hat); #>  656 :       } #>  657 :       if (stan::math::logical_negation(emit_generated_quantities__)) { #>  658 :         return ; #>  659 :       } #>  660 :     } catch (const std::exception& e) { #>  661 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  662 :     } #>  663 :   } #>  664 :   template <typename VecVar, typename VecI, #>  665 :             stan::require_vector_t<VecVar>* = nullptr, #>  666 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> #>  667 :   inline void #>  668 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__, #>  669 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const { #>  670 :     using local_scalar_t__ = double; #>  671 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__); #>  672 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  673 :     int current_statement__ = 0; #>  674 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  675 :     // suppress unused var warning #>  676 :     (void) DUMMY_VAR__; #>  677 :     try { #>  678 :       int pos__ = std::numeric_limits<int>::min(); #>  679 :       pos__ = 1; #>  680 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  681 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  682 :           DUMMY_VAR__); #>  683 :       current_statement__ = 1; #>  684 :       stan::model::assign(w1, #>  685 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(m, w1_2dim__), #>  686 :         \"assigning variable w1\"); #>  687 :       out__.write(w1); #>  688 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  689 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  690 :           DUMMY_VAR__); #>  691 :       current_statement__ = 2; #>  692 :       stan::model::assign(b1, #>  693 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b1_1dim__), #>  694 :         \"assigning variable b1\"); #>  695 :       out__.write(b1); #>  696 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  697 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  698 :           DUMMY_VAR__); #>  699 :       current_statement__ = 3; #>  700 :       stan::model::assign(w2, #>  701 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,-1>>(w2_1dim__, #>  702 :           w2_2dim__), \"assigning variable w2\"); #>  703 :       out__.write(w2); #>  704 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  705 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  706 :           DUMMY_VAR__); #>  707 :       current_statement__ = 4; #>  708 :       stan::model::assign(b2, #>  709 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(b2_1dim__), #>  710 :         \"assigning variable b2\"); #>  711 :       out__.write(b2); #>  712 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  713 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  714 :           DUMMY_VAR__); #>  715 :       current_statement__ = 5; #>  716 :       stan::model::assign(w_out, #>  717 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(w_out_1dim__), #>  718 :         \"assigning variable w_out\"); #>  719 :       out__.write(w_out); #>  720 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  721 :       current_statement__ = 6; #>  722 :       b_out = in__.read<local_scalar_t__>(); #>  723 :       out__.write(b_out); #>  724 :     } catch (const std::exception& e) { #>  725 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  726 :     } #>  727 :   } #>  728 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr> #>  729 :   inline void #>  730 :   transform_inits_impl(const stan::io::var_context& context__, VecVar& #>  731 :                        vars__, std::ostream* pstream__ = nullptr) const { #>  732 :     using local_scalar_t__ = double; #>  733 :     stan::io::serializer<local_scalar_t__> out__(vars__); #>  734 :     int current_statement__ = 0; #>  735 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN()); #>  736 :     // suppress unused var warning #>  737 :     (void) DUMMY_VAR__; #>  738 :     try { #>  739 :       current_statement__ = 1; #>  740 :       context__.validate_dims(\"parameter initialization\", \"w1\", \"double\", #>  741 :         std::vector<size_t>{static_cast<size_t>(m), #>  742 :           static_cast<size_t>(w1_2dim__)}); #>  743 :       current_statement__ = 2; #>  744 :       context__.validate_dims(\"parameter initialization\", \"b1\", \"double\", #>  745 :         std::vector<size_t>{static_cast<size_t>(b1_1dim__)}); #>  746 :       current_statement__ = 3; #>  747 :       context__.validate_dims(\"parameter initialization\", \"w2\", \"double\", #>  748 :         std::vector<size_t>{static_cast<size_t>(w2_1dim__), #>  749 :           static_cast<size_t>(w2_2dim__)}); #>  750 :       current_statement__ = 4; #>  751 :       context__.validate_dims(\"parameter initialization\", \"b2\", \"double\", #>  752 :         std::vector<size_t>{static_cast<size_t>(b2_1dim__)}); #>  753 :       current_statement__ = 5; #>  754 :       context__.validate_dims(\"parameter initialization\", \"w_out\", \"double\", #>  755 :         std::vector<size_t>{static_cast<size_t>(w_out_1dim__)}); #>  756 :       current_statement__ = 6; #>  757 :       context__.validate_dims(\"parameter initialization\", \"b_out\", \"double\", #>  758 :         std::vector<size_t>{}); #>  759 :       int pos__ = std::numeric_limits<int>::min(); #>  760 :       pos__ = 1; #>  761 :       Eigen::Matrix<local_scalar_t__,-1,-1> w1 = #>  762 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(m, w1_2dim__, #>  763 :           DUMMY_VAR__); #>  764 :       { #>  765 :         std::vector<local_scalar_t__> w1_flat__; #>  766 :         current_statement__ = 1; #>  767 :         w1_flat__ = context__.vals_r(\"w1\"); #>  768 :         current_statement__ = 1; #>  769 :         pos__ = 1; #>  770 :         current_statement__ = 1; #>  771 :         for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #>  772 :           current_statement__ = 1; #>  773 :           for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  774 :             current_statement__ = 1; #>  775 :             stan::model::assign(w1, w1_flat__[(pos__ - 1)], #>  776 :               \"assigning variable w1\", stan::model::index_uni(sym2__), #>  777 :               stan::model::index_uni(sym1__)); #>  778 :             current_statement__ = 1; #>  779 :             pos__ = (pos__ + 1); #>  780 :           } #>  781 :         } #>  782 :       } #>  783 :       out__.write(w1); #>  784 :       Eigen::Matrix<local_scalar_t__,-1,1> b1 = #>  785 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b1_1dim__, #>  786 :           DUMMY_VAR__); #>  787 :       { #>  788 :         std::vector<local_scalar_t__> b1_flat__; #>  789 :         current_statement__ = 2; #>  790 :         b1_flat__ = context__.vals_r(\"b1\"); #>  791 :         current_statement__ = 2; #>  792 :         pos__ = 1; #>  793 :         current_statement__ = 2; #>  794 :         for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #>  795 :           current_statement__ = 2; #>  796 :           stan::model::assign(b1, b1_flat__[(pos__ - 1)], #>  797 :             \"assigning variable b1\", stan::model::index_uni(sym1__)); #>  798 :           current_statement__ = 2; #>  799 :           pos__ = (pos__ + 1); #>  800 :         } #>  801 :       } #>  802 :       out__.write(b1); #>  803 :       Eigen::Matrix<local_scalar_t__,-1,-1> w2 = #>  804 :         Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(w2_1dim__, w2_2dim__, #>  805 :           DUMMY_VAR__); #>  806 :       { #>  807 :         std::vector<local_scalar_t__> w2_flat__; #>  808 :         current_statement__ = 3; #>  809 :         w2_flat__ = context__.vals_r(\"w2\"); #>  810 :         current_statement__ = 3; #>  811 :         pos__ = 1; #>  812 :         current_statement__ = 3; #>  813 :         for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #>  814 :           current_statement__ = 3; #>  815 :           for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #>  816 :             current_statement__ = 3; #>  817 :             stan::model::assign(w2, w2_flat__[(pos__ - 1)], #>  818 :               \"assigning variable w2\", stan::model::index_uni(sym2__), #>  819 :               stan::model::index_uni(sym1__)); #>  820 :             current_statement__ = 3; #>  821 :             pos__ = (pos__ + 1); #>  822 :           } #>  823 :         } #>  824 :       } #>  825 :       out__.write(w2); #>  826 :       Eigen::Matrix<local_scalar_t__,-1,1> b2 = #>  827 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(b2_1dim__, #>  828 :           DUMMY_VAR__); #>  829 :       { #>  830 :         std::vector<local_scalar_t__> b2_flat__; #>  831 :         current_statement__ = 4; #>  832 :         b2_flat__ = context__.vals_r(\"b2\"); #>  833 :         current_statement__ = 4; #>  834 :         pos__ = 1; #>  835 :         current_statement__ = 4; #>  836 :         for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #>  837 :           current_statement__ = 4; #>  838 :           stan::model::assign(b2, b2_flat__[(pos__ - 1)], #>  839 :             \"assigning variable b2\", stan::model::index_uni(sym1__)); #>  840 :           current_statement__ = 4; #>  841 :           pos__ = (pos__ + 1); #>  842 :         } #>  843 :       } #>  844 :       out__.write(b2); #>  845 :       Eigen::Matrix<local_scalar_t__,-1,1> w_out = #>  846 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(w_out_1dim__, #>  847 :           DUMMY_VAR__); #>  848 :       { #>  849 :         std::vector<local_scalar_t__> w_out_flat__; #>  850 :         current_statement__ = 5; #>  851 :         w_out_flat__ = context__.vals_r(\"w_out\"); #>  852 :         current_statement__ = 5; #>  853 :         pos__ = 1; #>  854 :         current_statement__ = 5; #>  855 :         for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #>  856 :           current_statement__ = 5; #>  857 :           stan::model::assign(w_out, w_out_flat__[(pos__ - 1)], #>  858 :             \"assigning variable w_out\", stan::model::index_uni(sym1__)); #>  859 :           current_statement__ = 5; #>  860 :           pos__ = (pos__ + 1); #>  861 :         } #>  862 :       } #>  863 :       out__.write(w_out); #>  864 :       local_scalar_t__ b_out = DUMMY_VAR__; #>  865 :       current_statement__ = 6; #>  866 :       b_out = context__.vals_r(\"b_out\")[(1 - 1)]; #>  867 :       out__.write(b_out); #>  868 :     } catch (const std::exception& e) { #>  869 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]); #>  870 :     } #>  871 :   } #>  872 :   inline void #>  873 :   get_param_names(std::vector<std::string>& names__, const bool #>  874 :                   emit_transformed_parameters__ = true, const bool #>  875 :                   emit_generated_quantities__ = true) const { #>  876 :     names__ = std::vector<std::string>{\"w1\", \"b1\", \"w2\", \"b2\", \"w_out\", #>  877 :                 \"b_out\"}; #>  878 :     if (emit_transformed_parameters__) { #>  879 :       std::vector<std::string> temp{\"z1\", \"a1\", \"z2\", \"a2\", \"y_hat\"}; #>  880 :       names__.reserve(names__.size() + temp.size()); #>  881 :       names__.insert(names__.end(), temp.begin(), temp.end()); #>  882 :     } #>  883 :     if (emit_generated_quantities__) {} #>  884 :   } #>  885 :   inline void #>  886 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool #>  887 :            emit_transformed_parameters__ = true, const bool #>  888 :            emit_generated_quantities__ = true) const { #>  889 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast< #>  890 :                                                                     size_t>(m), #>  891 :                                                  static_cast<size_t>( #>  892 :                                                    w1_2dim__)}, #>  893 :                 std::vector<size_t>{static_cast<size_t>(b1_1dim__)}, #>  894 :                 std::vector<size_t>{static_cast<size_t>(w2_1dim__), #>  895 :                   static_cast<size_t>(w2_2dim__)}, #>  896 :                 std::vector<size_t>{static_cast<size_t>(b2_1dim__)}, #>  897 :                 std::vector<size_t>{static_cast<size_t>(w_out_1dim__)}, #>  898 :                 std::vector<size_t>{}}; #>  899 :     if (emit_transformed_parameters__) { #>  900 :       std::vector<std::vector<size_t>> #>  901 :         temp{std::vector<size_t>{static_cast<size_t>(n), #>  902 :                static_cast<size_t>(z1_2dim__)}, #>  903 :              std::vector<size_t>{static_cast<size_t>(n), #>  904 :                static_cast<size_t>(a1_2dim__)}, #>  905 :              std::vector<size_t>{static_cast<size_t>(n), #>  906 :                static_cast<size_t>(z2_2dim__)}, #>  907 :              std::vector<size_t>{static_cast<size_t>(n), #>  908 :                static_cast<size_t>(a2_2dim__)}, #>  909 :              std::vector<size_t>{static_cast<size_t>(n)}}; #>  910 :       dimss__.reserve(dimss__.size() + temp.size()); #>  911 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end()); #>  912 :     } #>  913 :     if (emit_generated_quantities__) {} #>  914 :   } #>  915 :   inline void #>  916 :   constrained_param_names(std::vector<std::string>& param_names__, bool #>  917 :                           emit_transformed_parameters__ = true, bool #>  918 :                           emit_generated_quantities__ = true) const final { #>  919 :     for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #>  920 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  921 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #>  922 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  923 :       } #>  924 :     } #>  925 :     for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #>  926 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #>  927 :         std::to_string(sym1__)); #>  928 :     } #>  929 :     for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #>  930 :       for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #>  931 :         param_names__.emplace_back(std::string() + \"w2\" + '.' + #>  932 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  933 :       } #>  934 :     } #>  935 :     for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #>  936 :       param_names__.emplace_back(std::string() + \"b2\" + '.' + #>  937 :         std::to_string(sym1__)); #>  938 :     } #>  939 :     for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #>  940 :       param_names__.emplace_back(std::string() + \"w_out\" + '.' + #>  941 :         std::to_string(sym1__)); #>  942 :     } #>  943 :     param_names__.emplace_back(std::string() + \"b_out\"); #>  944 :     if (emit_transformed_parameters__) { #>  945 :       for (int sym1__ = 1; sym1__ <= z1_2dim__; ++sym1__) { #>  946 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  947 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #>  948 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  949 :         } #>  950 :       } #>  951 :       for (int sym1__ = 1; sym1__ <= a1_2dim__; ++sym1__) { #>  952 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  953 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #>  954 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  955 :         } #>  956 :       } #>  957 :       for (int sym1__ = 1; sym1__ <= z2_2dim__; ++sym1__) { #>  958 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  959 :           param_names__.emplace_back(std::string() + \"z2\" + '.' + #>  960 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  961 :         } #>  962 :       } #>  963 :       for (int sym1__ = 1; sym1__ <= a2_2dim__; ++sym1__) { #>  964 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #>  965 :           param_names__.emplace_back(std::string() + \"a2\" + '.' + #>  966 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  967 :         } #>  968 :       } #>  969 :       for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #>  970 :         param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #>  971 :           std::to_string(sym1__)); #>  972 :       } #>  973 :     } #>  974 :     if (emit_generated_quantities__) {} #>  975 :   } #>  976 :   inline void #>  977 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool #>  978 :                             emit_transformed_parameters__ = true, bool #>  979 :                             emit_generated_quantities__ = true) const final { #>  980 :     for (int sym1__ = 1; sym1__ <= w1_2dim__; ++sym1__) { #>  981 :       for (int sym2__ = 1; sym2__ <= m; ++sym2__) { #>  982 :         param_names__.emplace_back(std::string() + \"w1\" + '.' + #>  983 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  984 :       } #>  985 :     } #>  986 :     for (int sym1__ = 1; sym1__ <= b1_1dim__; ++sym1__) { #>  987 :       param_names__.emplace_back(std::string() + \"b1\" + '.' + #>  988 :         std::to_string(sym1__)); #>  989 :     } #>  990 :     for (int sym1__ = 1; sym1__ <= w2_2dim__; ++sym1__) { #>  991 :       for (int sym2__ = 1; sym2__ <= w2_1dim__; ++sym2__) { #>  992 :         param_names__.emplace_back(std::string() + \"w2\" + '.' + #>  993 :           std::to_string(sym2__) + '.' + std::to_string(sym1__)); #>  994 :       } #>  995 :     } #>  996 :     for (int sym1__ = 1; sym1__ <= b2_1dim__; ++sym1__) { #>  997 :       param_names__.emplace_back(std::string() + \"b2\" + '.' + #>  998 :         std::to_string(sym1__)); #>  999 :     } #> 1000 :     for (int sym1__ = 1; sym1__ <= w_out_1dim__; ++sym1__) { #> 1001 :       param_names__.emplace_back(std::string() + \"w_out\" + '.' + #> 1002 :         std::to_string(sym1__)); #> 1003 :     } #> 1004 :     param_names__.emplace_back(std::string() + \"b_out\"); #> 1005 :     if (emit_transformed_parameters__) { #> 1006 :       for (int sym1__ = 1; sym1__ <= z1_2dim__; ++sym1__) { #> 1007 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1008 :           param_names__.emplace_back(std::string() + \"z1\" + '.' + #> 1009 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1010 :         } #> 1011 :       } #> 1012 :       for (int sym1__ = 1; sym1__ <= a1_2dim__; ++sym1__) { #> 1013 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1014 :           param_names__.emplace_back(std::string() + \"a1\" + '.' + #> 1015 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1016 :         } #> 1017 :       } #> 1018 :       for (int sym1__ = 1; sym1__ <= z2_2dim__; ++sym1__) { #> 1019 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1020 :           param_names__.emplace_back(std::string() + \"z2\" + '.' + #> 1021 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1022 :         } #> 1023 :       } #> 1024 :       for (int sym1__ = 1; sym1__ <= a2_2dim__; ++sym1__) { #> 1025 :         for (int sym2__ = 1; sym2__ <= n; ++sym2__) { #> 1026 :           param_names__.emplace_back(std::string() + \"a2\" + '.' + #> 1027 :             std::to_string(sym2__) + '.' + std::to_string(sym1__)); #> 1028 :         } #> 1029 :       } #> 1030 :       for (int sym1__ = 1; sym1__ <= n; ++sym1__) { #> 1031 :         param_names__.emplace_back(std::string() + \"y_hat\" + '.' + #> 1032 :           std::to_string(sym1__)); #> 1033 :       } #> 1034 :     } #> 1035 :     if (emit_generated_quantities__) {} #> 1036 :   } #> 1037 :   inline std::string get_constrained_sizedtypes() const { #> 1038 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(w1_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b1_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w2_1dim__) + \",\\\"cols\\\":\" + std::to_string(w2_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b2\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b2_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(w_out_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(n) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #> 1039 :   } #> 1040 :   inline std::string get_unconstrained_sizedtypes() const { #> 1041 :     return std::string(\"[{\\\"name\\\":\\\"w1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(m) + \",\\\"cols\\\":\" + std::to_string(w1_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b1\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b1_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(w2_1dim__) + \",\\\"cols\\\":\" + std::to_string(w2_2dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b2\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(b2_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"w_out\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(w_out_1dim__) + \"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"b_out\\\",\\\"type\\\":{\\\"name\\\":\\\"real\\\"},\\\"block\\\":\\\"parameters\\\"},{\\\"name\\\":\\\"z1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a1\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a1_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"z2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(z2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"a2\\\",\\\"type\\\":{\\\"name\\\":\\\"matrix\\\",\\\"rows\\\":\" + std::to_string(n) + \",\\\"cols\\\":\" + std::to_string(a2_2dim__) + \"},\\\"block\\\":\\\"transformed_parameters\\\"},{\\\"name\\\":\\\"y_hat\\\",\\\"type\\\":{\\\"name\\\":\\\"vector\\\",\\\"length\\\":\" + std::to_string(n) + \"},\\\"block\\\":\\\"transformed_parameters\\\"}]\"); #> 1042 :   } #> 1043 :   // Begin method overload boilerplate #> 1044 :   template <typename RNG> inline void #> 1045 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r, #> 1046 :               Eigen::Matrix<double,-1,1>& vars, const bool #> 1047 :               emit_transformed_parameters = true, const bool #> 1048 :               emit_generated_quantities = true, std::ostream* #> 1049 :               pstream = nullptr) const { #> 1050 :     const size_t num_params__ = ((((((m * w1_2dim__) + b1_1dim__) + #> 1051 :       (w2_1dim__ * w2_2dim__)) + b2_1dim__) + w_out_1dim__) + 1); #> 1052 :     const size_t num_transformed = emit_transformed_parameters * ((((((n * #> 1053 :       z1_2dim__) + (n * a1_2dim__)) + (n * z2_2dim__)) + (n * a2_2dim__)) + #> 1054 :       n)); #> 1055 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #> 1056 :     const size_t num_to_write = num_params__ + num_transformed + #> 1057 :       num_gen_quantities; #> 1058 :     std::vector<int> params_i; #> 1059 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write, #> 1060 :              std::numeric_limits<double>::quiet_NaN()); #> 1061 :     write_array_impl(base_rng, params_r, params_i, vars, #> 1062 :       emit_transformed_parameters, emit_generated_quantities, pstream); #> 1063 :   } #> 1064 :   template <typename RNG> inline void #> 1065 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>& #> 1066 :               params_i, std::vector<double>& vars, bool #> 1067 :               emit_transformed_parameters = true, bool #> 1068 :               emit_generated_quantities = true, std::ostream* #> 1069 :               pstream = nullptr) const { #> 1070 :     const size_t num_params__ = ((((((m * w1_2dim__) + b1_1dim__) + #> 1071 :       (w2_1dim__ * w2_2dim__)) + b2_1dim__) + w_out_1dim__) + 1); #> 1072 :     const size_t num_transformed = emit_transformed_parameters * ((((((n * #> 1073 :       z1_2dim__) + (n * a1_2dim__)) + (n * z2_2dim__)) + (n * a2_2dim__)) + #> 1074 :       n)); #> 1075 :     const size_t num_gen_quantities = emit_generated_quantities * (0); #> 1076 :     const size_t num_to_write = num_params__ + num_transformed + #> 1077 :       num_gen_quantities; #> 1078 :     vars = std::vector<double>(num_to_write, #> 1079 :              std::numeric_limits<double>::quiet_NaN()); #> 1080 :     write_array_impl(base_rng, params_r, params_i, vars, #> 1081 :       emit_transformed_parameters, emit_generated_quantities, pstream); #> 1082 :   } #> 1083 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #> 1084 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const { #> 1085 :     Eigen::Matrix<int,-1,1> params_i; #> 1086 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #> 1087 :   } #> 1088 :   template <bool propto__, bool jacobian__, typename T_> inline T_ #> 1089 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i, #> 1090 :            std::ostream* pstream = nullptr) const { #> 1091 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream); #> 1092 :   } #> 1093 :   inline void #> 1094 :   transform_inits(const stan::io::var_context& context, #> 1095 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream* #> 1096 :                   pstream = nullptr) const final { #> 1097 :     std::vector<double> params_r_vec(params_r.size()); #> 1098 :     std::vector<int> params_i; #> 1099 :     transform_inits(context, params_i, params_r_vec, pstream); #> 1100 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(), #> 1101 :                  params_r_vec.size()); #> 1102 :   } #> 1103 :   inline void #> 1104 :   transform_inits(const stan::io::var_context& context, std::vector<int>& #> 1105 :                   params_i, std::vector<double>& vars, std::ostream* #> 1106 :                   pstream__ = nullptr) const { #> 1107 :     vars.resize(num_params_r__); #> 1108 :     transform_inits_impl(context, vars, pstream__); #> 1109 :   } #> 1110 :   inline void #> 1111 :   unconstrain_array(const std::vector<double>& params_constrained, #> 1112 :                     std::vector<double>& params_unconstrained, std::ostream* #> 1113 :                     pstream = nullptr) const { #> 1114 :     const std::vector<int> params_i; #> 1115 :     params_unconstrained = std::vector<double>(num_params_r__, #> 1116 :                              std::numeric_limits<double>::quiet_NaN()); #> 1117 :     unconstrain_array_impl(params_constrained, params_i, #> 1118 :       params_unconstrained, pstream); #> 1119 :   } #> 1120 :   inline void #> 1121 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained, #> 1122 :                     Eigen::Matrix<double,-1,1>& params_unconstrained, #> 1123 :                     std::ostream* pstream = nullptr) const { #> 1124 :     const std::vector<int> params_i; #> 1125 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__, #> 1126 :                              std::numeric_limits<double>::quiet_NaN()); #> 1127 :     unconstrain_array_impl(params_constrained, params_i, #> 1128 :       params_unconstrained, pstream); #> 1129 :   } #> 1130 : }; #> 1131 : } #> 1132 : using stan_model = model3cfa60feea29__namespace::model3cfa60feea29_; #> 1133 : #ifndef USING_R #> 1134 : // Boilerplate #> 1135 : stan::model::model_base& #> 1136 : new_model(stan::io::var_context& data_context, unsigned int seed, #> 1137 :           std::ostream* msg_stream) { #> 1138 :   stan_model* m = new stan_model(data_context, seed, msg_stream); #> 1139 :   return *m; #> 1140 : } #> 1141 : stan::math::profile_map& get_stan_profile_data() { #> 1142 :   return model3cfa60feea29__namespace::profiles__; #> 1143 : } #> 1144 : #endif #> 1145 : #endif #> 1146 :  #> 1147 : RCPP_MODULE(stan_fit4model3cfa60feea29__mod) { #> 1148 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >( #> 1149 :       \"stan_fit4model3cfa60feea29_\") #> 1150 :  #> 1151 :       .constructor<SEXP, SEXP, SEXP>() #> 1152 :  #> 1153 :       .method( #> 1154 :           \"call_sampler\", #> 1155 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler) #> 1156 :       .method( #> 1157 :           \"param_names\", #> 1158 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names) #> 1159 :       .method(\"param_names_oi\", #> 1160 :               &rstan::stan_fit<stan_model, #> 1161 :                                boost::random::ecuyer1988>::param_names_oi) #> 1162 :       .method(\"param_fnames_oi\", #> 1163 :               &rstan::stan_fit<stan_model, #> 1164 :                                boost::random::ecuyer1988>::param_fnames_oi) #> 1165 :       .method( #> 1166 :           \"param_dims\", #> 1167 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims) #> 1168 :       .method(\"param_dims_oi\", #> 1169 :               &rstan::stan_fit<stan_model, #> 1170 :                                boost::random::ecuyer1988>::param_dims_oi) #> 1171 :       .method(\"update_param_oi\", #> 1172 :               &rstan::stan_fit<stan_model, #> 1173 :                                boost::random::ecuyer1988>::update_param_oi) #> 1174 :       .method(\"param_oi_tidx\", #> 1175 :               &rstan::stan_fit<stan_model, #> 1176 :                                boost::random::ecuyer1988>::param_oi_tidx) #> 1177 :       .method(\"grad_log_prob\", #> 1178 :               &rstan::stan_fit<stan_model, #> 1179 :                                boost::random::ecuyer1988>::grad_log_prob) #> 1180 :       .method(\"log_prob\", #> 1181 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob) #> 1182 :       .method(\"unconstrain_pars\", #> 1183 :               &rstan::stan_fit<stan_model, #> 1184 :                                boost::random::ecuyer1988>::unconstrain_pars) #> 1185 :       .method(\"constrain_pars\", #> 1186 :               &rstan::stan_fit<stan_model, #> 1187 :                                boost::random::ecuyer1988>::constrain_pars) #> 1188 :       .method( #> 1189 :           \"num_pars_unconstrained\", #> 1190 :           &rstan::stan_fit<stan_model, #> 1191 :                            boost::random::ecuyer1988>::num_pars_unconstrained) #> 1192 :       .method( #> 1193 :           \"unconstrained_param_names\", #> 1194 :           &rstan::stan_fit< #> 1195 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names) #> 1196 :       .method( #> 1197 :           \"constrained_param_names\", #> 1198 :           &rstan::stan_fit<stan_model, #> 1199 :                            boost::random::ecuyer1988>::constrained_param_names) #> 1200 :       .method(\"standalone_gqs\", #> 1201 :               &rstan::stan_fit<stan_model, #> 1202 :                                boost::random::ecuyer1988>::standalone_gqs); #> 1203 : } #> 1204 :  #> 1205 :  #> 1206 : // declarations #> 1207 : extern \"C\" { #> 1208 : SEXP file3cfa1748b648( ) ; #> 1209 : } #> 1210 :  #> 1211 : // definition #> 1212 : SEXP file3cfa1748b648() { #> 1213 :  return Rcpp::wrap(\"anon_model\"); #> 1214 : } #>  #> CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW. #>  #> COMPILING MODEL 'anon_model' NOW. #>  #> STARTING SAMPLER FOR MODEL 'anon_model' NOW."},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"clinical-trial-applications","dir":"","previous_headings":"Applications","what":"Clinical Trial Applications","title":"Bayesian Neural Network with Stan","text":"Explore posterior probabilities estimate treatment effects success probabilities clinical trials. example, calculate posterior probability achieving clinically meaningful outcome given population.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Bayesian Neural Network with Stan","text":"Detailed vignettes available guide various applications package. See help(bnns) information bnns function arguments.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Bayesian Neural Network with Stan","text":"Contributions welcome! Please raise issues submit pull requests GitHub.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Bayesian Neural Network with Stan","text":"package licensed Apache License. See LICENSE details.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"Fits Bayesian Neural Network (BNN) model using formula interface. function parses formula data create input feature matrix target vector, fits model using bnns.default.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"","code":"# Default S3 method bnns(   formula,   data = list(),   L = 1,   nodes = 16,   act_fn = 2,   out_act_fn = 1,   iter = 1000,   warmup = 200,   thin = 1,   chains = 2,   cores = 2,   seed = 123,   ... )"},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"formula symbolic description model fitted. formula specify response variable predictors (e.g., y ~ x1 + x2). data data frame list containing variables model. Default empty list. L integer specifying number hidden layers neural network. Default 1. nodes integer vector specifying number nodes hidden layer. single value provided, applied layers. Default 16. act_fn integer vector specifying activation function(s) hidden layers. Options : 1 tanh 2 sigmoid (default) 3 ReLU 4 softplus out_act_fn integer specifying activation function output layer. Options : 1 linear (default) 2 sigmoid 3 softmax iter integer specifying total number iterations Stan sampler. Default 1e3. warmup integer specifying number warmup iterations Stan sampler. Default 2e2. thin integer specifying thinning interval Stan samples. Default 1. chains integer specifying number Markov chains. Default 2. cores integer specifying number CPU cores use parallel sampling. Default 2. seed integer specifying random seed reproducibility. Default 123. ... Additional arguments passed helper function bnns_train.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"object class \"bnns\" containing fitted model associated information, including: fit: fitted Stan model object. data: list containing processed training data. call: matched function call. formula: formula used model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"function uses provided formula data generate design matrix predictors response vector. calls helper function bnns_train fit Bayesian Neural Network model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage with formula interface: data <- data.frame(x1 = runif(100), x2 = runif(100), y = rnorm(100)) model <- bnns(y ~ x1 + x2, data = data, L = 2, nodes = c(16, 8), act_fn = c(2, 3)) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic Function for Fitting Bayesian Neural Network Models — bnns","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"generic function fitting Bayesian Neural Network (BNN) models. dispatches methods based class input data.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"","code":"bnns(   formula,   data = list(),   L = 1,   nodes = 16,   act_fn = 2,   out_act_fn = 1,   iter = 1000,   warmup = 200,   thin = 1,   chains = 2,   cores = 2,   seed = 123,   ... )"},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"formula symbolic description model fitted. formula specify response variable predictors (e.g., y ~ x1 + x2). data data frame list containing variables model. Default empty list. L integer specifying number hidden layers neural network. Default 1. nodes integer vector specifying number nodes hidden layer. single value provided, applied layers. Default 16. act_fn integer vector specifying activation function(s) hidden layers. Options : 1 tanh 2 sigmoid (default) 3 ReLU 4 softplus out_act_fn integer specifying activation function output layer. Options : 1 linear (default) 2 sigmoid 3 softmax iter integer specifying total number iterations Stan sampler. Default 1e3. warmup integer specifying number warmup iterations Stan sampler. Default 2e2. thin integer specifying thinning interval Stan samples. Default 1. chains integer specifying number Markov chains. Default 2. cores integer specifying number CPU cores use parallel sampling. Default 2. seed integer specifying random seed reproducibility. Default 123. ... Additional arguments passed specific methods fitting Bayesian Neural Networks.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"result method dispatched class input data. Typically, object class \"bnns\" containing fitted model associated information.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"function serves generic interface different methods fitting Bayesian Neural Networks. specific method dispatched depends class input arguments, allowing flexibility types inputs supported.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage with the default method: train_x <- matrix(runif(100), nrow = 10, ncol = 10) train_y <- rnorm(10) model <- bnns(train_x, train_y, L = 2, nodes = c(16, 8), act_fn = c(2, 3)) } # }  # See the documentation for bnns.default for more details on the default implementation."},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function for training the BNN — bnns_train","title":"Internal function for training the BNN — bnns_train","text":"function performs actual fitting Bayesian Neural Network. called exported bnns methods intended direct use.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function for training the BNN — bnns_train","text":"","code":"bnns_train(   train_x,   train_y,   L = 1,   nodes = 16,   act_fn = 2,   out_act_fn = 1,   iter = 1000,   warmup = 200,   thin = 1,   chains = 2,   cores = 2,   seed = 123,   ... )"},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function for training the BNN — bnns_train","text":"train_x numeric matrix representing input features (predictors) training. Rows correspond observations, columns correspond features. train_y numeric vector representing target values training. length must match number rows train_x. L integer specifying number hidden layers neural network. Default 1. nodes integer vector specifying number nodes hidden layer. single value provided, applied layers. Default 16. act_fn integer vector specifying activation function(s) hidden layers. Options : 1 tanh 2 sigmoid (default) 3 ReLU 4 softplus out_act_fn integer specifying activation function output layer. Options : 1 linear (default) 2 sigmoid 3 softmax iter integer specifying total number iterations Stan sampler. Default 1e3. warmup integer specifying number warmup iterations Stan sampler. Default 2e2. thin integer specifying thinning interval Stan samples. Default 1. chains integer specifying number Markov chains. Default 2. cores integer specifying number CPU cores use parallel sampling. Default 2. seed integer specifying random seed reproducibility. Default 123. ... Additional arguments passed Stan sampler.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function for training the BNN — bnns_train","text":"object class \"bnns\" containing following components: fit fitted Stan model object. call matched call. data list containing Stan data used model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Internal function for training the BNN — bnns_train","text":"function uses generate_stan_code function dynamically generate Stan code based specified number layers nodes. Stan used fit Bayesian Neural Network.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function for training the BNN — bnns_train","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage: train_x <- matrix(runif(100), nrow = 10, ncol = 10) train_y <- rnorm(10) model <- bnns_train(train_x, train_y, L = 2, nodes = c(16, 8), act_fn = c(2, 3))  # Access Stan model fit model$fit } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Stan Code Based on Output Activation Function — generate_stan_code","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"function serves wrapper generate Stan code Bayesian neural networks tailored different types response variables. Based specified output activation function (out_act_fn), delegates code generation appropriate function continuous, binary, categorical response models.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"","code":"generate_stan_code(num_layers, nodes, out_act_fn = 1)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"num_layers integer specifying number hidden layers neural network. nodes vector integers, element specifies number nodes corresponding hidden layer. length vector must match num_layers. out_act_fn integer specifying output activation function, determining type response variable. Supported values : 1: Continuous response (identity function output layer). 2: Binary response (sigmoid function output layer). 3: Categorical response (softmax function output layer).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"character string containing Stan code specified Bayesian neural network model. Stan model includes data, parameters, transformed parameters, model blocks, adjusted based specified response type.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"function dynamically calls one following functions based value out_act_fn: Continuous response: Calls generate_stan_code_cont. Binary response: Calls generate_stan_code_bin. Categorical response: Calls generate_stan_code_cat. unsupported value provided out_act_fn, function throws error. generated Stan code adapted response type, including appropriate likelihood functions transformations.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"","code":"if (FALSE) { # \\dontrun{ # Generate Stan code for a continuous response model stan_code <- generate_stan_code(num_layers = 2, nodes = c(10, 5), out_act_fn = 1) cat(stan_code)  # Generate Stan code for a binary response model stan_code <- generate_stan_code(num_layers = 2, nodes = c(10, 5), out_act_fn = 2) cat(stan_code)  # Generate Stan code for a categorical response model stan_code <- generate_stan_code(num_layers = 2, nodes = c(10, 5), out_act_fn = 3) cat(stan_code) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"function generates Stan code Bayesian neural network model designed predict binary response variables. Stan code dynamically constructed based specified number hidden layers nodes per layer. supports various activation functions hidden layers, including tanh, sigmoid, softplus relu. model uses Bernoulli likelihood binary outcomes.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"","code":"generate_stan_code_bin(num_layers, nodes)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"num_layers integer specifying number hidden layers neural network. nodes vector integers, element specifies number nodes corresponding hidden layer. length vector must match num_layers.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"character string containing Stan code specified Bayesian neural network model. Stan model includes data, parameters, transformed parameters, model blocks. code adjusted based whether network one multiple hidden layers.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"generated Stan code models binary response variable using neural network. hidden layers apply specified activation functions, output layer applies logistic function predict probability binary outcome. one hidden layer: function simplifies Stan code structure. multiple hidden layers: code dynamically includes additional layers based input arguments. Supported activation functions hidden layers: 1: Tanh 2: Sigmoid 3: Softplus 4: ReLU output layer uses logistic transformation (inv_logit) constrain predictions 0 1, aligns Bernoulli likelihood.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"","code":"if (FALSE) { # \\dontrun{ # Generate Stan code for a single hidden layer with 10 nodes stan_code <- generate_stan_code_binary(1, c(10)) cat(stan_code)  # Generate Stan code for two hidden layers with 8 and 4 nodes stan_code <- generate_stan_code_binary(2, c(8, 4)) cat(stan_code) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"function generates Stan code modeling categorical response using neural networks multiple layers. generated code supports customizable activation functions layer softmax-based prediction categorical output.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"","code":"generate_stan_code_cat(num_layers, nodes)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"num_layers Integer. Number layers neural network. nodes Integer vector. Number nodes layer. length vector must match num_layers, values must positive.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"string containing Stan code specified neural network architecture categorical response model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"Stan code includes following components: Data Block: Defines inputs, response variable, layer configurations, activation functions. Parameters Block: Declares weights biases layers output layer. Transformed Parameters Block: Computes intermediate outputs (z ) layer calculates final predictions (y_hat) using softmax function. Model Block: Specifies priors parameters models categorical response using categorical_logit. Supported activation functions layer: 1: Hyperbolic tangent (tanh) 2: Logistic sigmoid (inv_logit) 3: Softplus (log(1 + exp(x))) Default: Rectified linear unit (ReLU) categorical response (y) assumed take integer values 1 K, K total number categories.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"","code":"if (FALSE) { # \\dontrun{ # Generate Stan code for a neural network with 3 layers num_layers <- 3 nodes <- c(10, 8, 6)  # 10 nodes in the first layer, 8 in the second, 6 in the third stan_code <- generate_stan_code_cat(num_layers, nodes) cat(stan_code) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"function generates Stan code Bayesian neural network model designed predict continuous response variables. Stan code dynamically constructed based specified number hidden layers nodes per layer. supports various activation functions hidden layers, including tanh, sigmoid, softplus relu.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"","code":"generate_stan_code_cont(num_layers, nodes)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"num_layers integer specifying number hidden layers neural network. nodes vector integers, element specifies number nodes corresponding hidden layer. length vector must match num_layers.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"character string containing Stan code specified Bayesian neural network model. Stan model includes data, parameters, transformed parameters, model blocks. code adjusted based whether network one multiple hidden layers.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"generated Stan code models continuous response variable using neural network. hidden layers apply specified activation functions, output layer performs linear transformation predict response. likelihood assumes normally distributed residuals. one hidden layer: function simplifies Stan code structure. multiple hidden layers: code dynamically includes additional layers based input arguments. Supported activation functions hidden layers: 1: Tanh 2: Sigmoid 3: Softplus 4: ReLU","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"","code":"if (FALSE) { # \\dontrun{ # Generate Stan code for a single hidden layer with 10 nodes stan_code <- generate_stan_code_cont(1, c(10)) cat(stan_code)  # Generate Stan code for two hidden layers with 8 and 4 nodes stan_code <- generate_stan_code_cont(2, c(8, 4)) cat(stan_code) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_bin.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure Performance for Binary Classification Models — measure_bin","title":"Measure Performance for Binary Classification Models — measure_bin","text":"Evaluates performance binary classification model using confusion matrix accuracy.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_bin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure Performance for Binary Classification Models — measure_bin","text":"","code":"measure_bin(obs, pred, cut = 0.5)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_bin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Measure Performance for Binary Classification Models — measure_bin","text":"obs numeric integer vector observed binary class labels (0 1). pred numeric vector predicted probabilities positive class. cut numeric threshold (0 1) classify predictions binary labels.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_bin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Measure Performance for Binary Classification Models — measure_bin","text":"list containing: conf_mat confusion matrix comparing observed predicted class labels. accuracy proportion correct predictions.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_bin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Measure Performance for Binary Classification Models — measure_bin","text":"","code":"if (FALSE) { # \\dontrun{ obs <- c(1, 0, 1, 1, 0) pred <- c(0.9, 0.4, 0.8, 0.7, 0.3) cut <- 0.5 measure_bin(obs, pred, cut) # Returns: list(conf_mat = <confusion matrix>, accuracy = 1, ROC = <ROC>, AUC = 1) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure Performance for Multi-Class Classification Models — measure_cat","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"Evaluates performance multi-class classification model using log loss multiclass AUC.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"","code":"measure_cat(obs, pred)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"obs factor vector observed class labels. level represents unique class. pred numeric matrix predicted probabilities, row corresponds observation, column corresponds class. number columns must match number levels obs.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"list containing: log_loss negative log-likelihood averaged across observations. AUC multiclass Area Curve (AUC) computed pROC::multiclass.roc.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"log loss calculated : $$-\\frac{1}{N} \\sum_{=1}^N \\sum_{c=1}^C y_{ic} \\log(p_{ic})$$ \\(y_{ic}\\) 1 observation \\(\\) belongs class \\(c\\), \\(p_{ic}\\) predicted probability class. AUC computed using pROC::multiclass.roc function, provides overall measure model performance multiclass classification.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"","code":"if (FALSE) { # \\dontrun{ library(pROC) obs <- factor(c(\"A\", \"B\", \"C\"), levels = LETTERS[1:3]) pred <- matrix(c(0.8, 0.1, 0.1,                  0.2, 0.6, 0.2,                  0.7, 0.2, 0.1),                nrow = 3, byrow = TRUE) measure_cat(obs, pred) # Returns: list(log_loss = 1.012185, AUC = 0.75) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cont.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure Performance for Continuous Response Models — measure_cont","title":"Measure Performance for Continuous Response Models — measure_cont","text":"Evaluates performance continuous response model using RMSE MAE.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cont.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure Performance for Continuous Response Models — measure_cont","text":"","code":"measure_cont(obs, pred)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cont.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Measure Performance for Continuous Response Models — measure_cont","text":"obs numeric vector observed (true) values. pred numeric vector predicted values.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cont.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Measure Performance for Continuous Response Models — measure_cont","text":"list containing: rmse Root Mean Squared Error. mae Mean Absolute Error.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cont.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Measure Performance for Continuous Response Models — measure_cont","text":"","code":"if (FALSE) { # \\dontrun{ obs <- c(3.2, 4.1, 5.6) pred <- c(3.0, 4.3, 5.5) measure_cont(obs, pred) # Returns: list(rmse = 0.1732051, mae = 0.1666667) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Method for ","title":"Predict Method for ","text":"Generates predictions fitted Bayesian Neural Network (BNN) model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Method for ","text":"","code":"# S3 method for class 'bnns' predict(object, newdata = NULL, ...)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Method for ","text":"object object class \"bnns\", typically result call bnns.default. newdata matrix data frame new input data predictions required. NULL, predictions made training data used fit model. ... Additional arguments (currently used).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Method for ","text":"vector predicted values corresponding rows newdata training data newdata NULL.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict Method for ","text":"function uses posterior distribution Stan model bnns object compute predictions provided input data.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Method for ","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage: data <- data.frame(x1 = runif(100), x2 = runif(100), y = rnorm(100)) model <- bnns(y ~ x1 + x2, data = data, L = 2, nodes = c(16, 8)) new_data <- data.frame(x1 = runif(10), x2 = runif(10)) predictions <- predict(model, newdata = new_data) print(predictions) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/print.bnns.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for ","title":"Print Method for ","text":"Displays summary fitted Bayesian Neural Network (BNN) model, including function call Stan fit details.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/print.bnns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for ","text":"","code":"# S3 method for class 'bnns' print(x, ...)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/print.bnns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for ","text":"x object class \"bnns\", typically result call bnns.default. ... Additional arguments (currently used).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/print.bnns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for ","text":"function called side effects return value. prints following: function call used generate \"bnns\" object. summary Stan fit object stored x$fit.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/print.bnns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print Method for ","text":"","code":"if (FALSE) { # \\dontrun{ # Example usage: df <- data.frame(x1 = runif(100), x2 = runif(100), y = rnorm(100)) model <- bnns(y ~ x1 + x2, data = df, L = 2, nodes = c(16, 8)) print(model) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/relu.html","id":null,"dir":"Reference","previous_headings":"","what":"relu transformation — relu","title":"relu transformation — relu","text":"relu transformation","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/relu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"relu transformation — relu","text":"","code":"relu(x)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/relu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"relu transformation — relu","text":"x numeric vector matrix relu transformation going applied.........................","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/relu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"relu transformation — relu","text":"numeric vector matrix relu transformation.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/relu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"relu transformation — relu","text":"","code":"if (FALSE) { # \\dontrun{ relu(matrix(1:4), nrow = 2) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/sigmoid.html","id":null,"dir":"Reference","previous_headings":"","what":"sigmoid transformation — sigmoid","title":"sigmoid transformation — sigmoid","text":"sigmoid transformation","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/sigmoid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sigmoid transformation — sigmoid","text":"","code":"sigmoid(x)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/sigmoid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sigmoid transformation — sigmoid","text":"x numeric vector matrix sigmoid transformation going applied.........................","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/sigmoid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sigmoid transformation — sigmoid","text":"numeric vector matrix sigmoid transformation.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/sigmoid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"sigmoid transformation — sigmoid","text":"","code":"if (FALSE) { # \\dontrun{ sigmoid(matrix(1:4), nrow = 2) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Softmax Function to a 3D Array — softmax_3d","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"function applies softmax transformation along third dimension 3D array. softmax function converts raw scores probabilities sum 1 slice along third dimension.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"","code":"softmax_3d(x)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"x 3D array. input array softmax function applied.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"3D array dimensions x, values along third dimension transformed using softmax function.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"softmax transformation computed : $$\\text{softmax}(x_{ijk}) = \\frac{\\exp(x_{ijk})}{\\sum_{l} \\exp(x_{ijl})}$$ applied pair indices (, j) across third dimension (k). function processes input array slice--slice first two dimensions (, j), normalizing values along third dimension (k) slice.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"","code":"if (FALSE) { # \\dontrun{ # Example: Apply softmax to a 3D array x <- array(runif(24), dim = c(2, 3, 4))  # Random 3D array (2x3x4) softmax_result <- softmax_3d(x) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/softplus.html","id":null,"dir":"Reference","previous_headings":"","what":"softplus transformation — softplus","title":"softplus transformation — softplus","text":"softplus transformation","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softplus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"softplus transformation — softplus","text":"","code":"softplus(x)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/softplus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"softplus transformation — softplus","text":"x numeric vector matrix softplus transformation going applied.........................","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softplus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"softplus transformation — softplus","text":"numeric vector matrix softplus transformation.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softplus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"softplus transformation — softplus","text":"","code":"if (FALSE) { # \\dontrun{ softplus(matrix(1:4), nrow = 2) } # }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"Provides comprehensive summary fitted Bayesian Neural Network (BNN) model, including details model call, data, network architecture, posterior distributions, model fitting information.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"","code":"# S3 method for class 'bnns' summary(object, ...)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"object object class bnns, representing fitted Bayesian Neural Network model. ... Additional arguments (currently unused).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"None. function prints summary console.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"function prints following information: Call: original function call used fit model. Data Summary: Number observations features training data. Network Architecture: Structure BNN including number hidden layers, nodes per layer, activation functions. Posterior Summary: Summarized posterior distributions key parameters (e.g., weights, biases, noise parameter). Model Fit Information: Bayesian sampling details, including number iterations, warmup period, thinning, chains. Notes: Remarks warnings, checks convergence diagnostics.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"","code":"if (FALSE) { # \\dontrun{ # Fit a Bayesian Neural Network df <- data.frame(x1 = runif(100), x2 = runif(100), y = rnorm(100)) model <- bnns(y ~ -1 + x1 + x2, data = df, L = 2, nodes = c(16, 8), act_fn = c(2, 3))  # Get a summary of the model summary(model) } # }"}]
