[{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"https://swarnendu-stat.github.io/bnns/LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright [yyyy] [name of copyright owner]  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"bnns","text":"bnns package provides efficient user-friendly implementation Bayesian Neural Networks (BNNs) regression, binary classification, multiclass classification problems. integrating Bayesian inference, bnns allows uncertainty quantification predictions robust parameter estimation. vignette covers: 1. Installing loading package 2. Preparing data 3. Fitting BNN model 4. Summarizing model 5. Making predictions 6. Model evaluation 7. Customizing prior","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"installation","dir":"Articles","previous_headings":"","what":"1. Installation","title":"bnns","text":"install package, use following commands: Load package R session:","code":"# Install from CRAN (if available) #  install.packages(\"bnns\")  # Or install the development version from GitHub # devtools::install_github(\"swarnendu-stat/bnns\") library(bnns)"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"preparing-the-data","dir":"Articles","previous_headings":"","what":"2. Preparing the Data","title":"bnns","text":"bnns package expects data form matrices predictors vector responses. ’s example generating synthetic data: binary multiclass classification:","code":"# Generate training data set.seed(123) df <- data.frame(x1 = runif(10), x2 = runif(10), y = rnorm(10)) # Binary classification response df$y_bin <- sample(0:1, 10, replace = TRUE)  # Multiclass classification response df$y_cat <- factor(sample(letters[1:3], 10, replace = TRUE)) # 3 classes"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"fitting-a-bayesian-neural-network-model","dir":"Articles","previous_headings":"","what":"3. Fitting a Bayesian Neural Network Model","title":"bnns","text":"Fit Bayesian Neural Network using bnns() function. Specify network architecture using arguments like number layers (L), nodes per layer (nodes), activation functions (act_fn).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"regression-example","dir":"Articles","previous_headings":"3. Fitting a Bayesian Neural Network Model","what":"Regression Example","title":"bnns","text":"","code":"model_reg <- bnns(   y ~ -1 + x1 + x2,   data = df,   L = 2, # Number of hidden layers   nodes = c(16, 8), # Nodes per layer   act_fn = c(2, 3), # Activation functions: 2 = Sigmoid, 3 = ReLU   out_act_fn = 1, # Output activation function: 1 = Identity (for regression)   iter = 2e2,   warmup = 1e2,   chains = 1 )"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"binary-classification-example","dir":"Articles","previous_headings":"3. Fitting a Bayesian Neural Network Model","what":"Binary Classification Example","title":"bnns","text":"","code":"model_bin <- bnns(   y_bin ~ -1 + x1 + x2,   data = df,   L = 1,   nodes = c(16),   act_fn = c(2),   out_act_fn = 2, # Output activation: 2 = Logistic sigmoid   iter = 2e2,   warmup = 1e2,   chains = 1 )"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"multiclass-classification-example","dir":"Articles","previous_headings":"3. Fitting a Bayesian Neural Network Model","what":"Multiclass Classification Example","title":"bnns","text":"","code":"model_cat <- bnns(   y_cat ~ -1 + x1 + x2,   data = df,   L = 3,   nodes = c(32, 16, 8),   act_fn = c(3, 2, 2),   out_act_fn = 3, # Output activation: 3 = Softmax   iter = 2e2,   warmup = 1e2,   chains = 1 )"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"summarizing-the-model","dir":"Articles","previous_headings":"","what":"4. Summarizing the Model","title":"bnns","text":"Use summary() function view details fitted model, including network architecture, posterior distributions, predictive performance.","code":"summary(model_reg) #> Call: #> bnns.default(formula = y ~ -1 + x1 + x2, data = df, L = 2, nodes = c(16,  #>     8), act_fn = c(2, 3), out_act_fn = 1, iter = 200, warmup = 100,  #>     chains = 1) #>  #> Data Summary: #> Number of observations: 10  #> Number of features: 2  #>  #> Network Architecture: #> Number of hidden layers: 2  #> Nodes per layer: 16, 8  #> Activation functions: 2, 3  #> Output activation function: 1  #>  #> Posterior Summary (Key Parameters): #>                 mean    se_mean        sd       2.5%        25%          50% #> w_out[1] -0.10198284 0.14234573 1.1509261 -2.3465344 -0.9310721 -0.044826796 #> w_out[2]  0.04577008 0.11614828 1.0015612 -1.9138942 -0.6495277 -0.007745432 #> w_out[3] -0.04075107 0.08738532 0.9189875 -1.8421486 -0.7018924  0.016591141 #> w_out[4] -0.12898385 0.10433181 0.9657694 -1.8705094 -0.8236752 -0.161414637 #> w_out[5]  0.04441101 0.14399470 0.9149602 -1.6450550 -0.5014460  0.074000706 #> w_out[6]  0.09181270 0.09365504 1.0175930 -1.7111797 -0.5749220  0.057005885 #> w_out[7] -0.09465186 0.13233268 1.0584434 -2.1755971 -0.8580435  0.008400356 #> w_out[8]  0.09424769 0.09008563 0.8242622 -1.8145246 -0.4300790  0.120671263 #> b_out     0.22837885 0.09277325 0.9273436 -1.4422208 -0.4423550  0.234050858 #> sigma     0.93627917 0.03072003 0.2678280  0.5408225  0.7386355  0.886663758 #>                75%    97.5%     n_eff      Rhat #> w_out[1] 0.6455087 1.872981  65.37414 1.0294148 #> w_out[2] 0.7022393 2.057543  74.35829 0.9961894 #> w_out[3] 0.5498031 1.697787 110.59672 0.9909493 #> w_out[4] 0.4874982 1.706104  85.68671 1.0311843 #> w_out[5] 0.5386251 1.930949  40.37489 1.0143750 #> w_out[6] 0.7953263 1.971914 118.05542 1.0181717 #> w_out[7] 0.5742348 1.845179  63.97364 0.9900240 #> w_out[8] 0.6472984 1.707112  83.71817 1.0260238 #> b_out    0.8811560 2.089568  99.91618 0.9960687 #> sigma    1.0861037 1.516254  76.00964 1.0077324 #>  #> Model Fit Information: #> Iterations: 200  #> Warmup: 100  #> Thinning: 1  #> Chains: 1  #>  #> Predictive Performance: #> RMSE (training): 0.7223731  #> MAE (training): 0.5778231  #>  #> Notes: #> Check convergence diagnostics for parameters with high R-hat values. summary(model_bin) #> Call: #> bnns.default(formula = y_bin ~ -1 + x1 + x2, data = df, L = 1,  #>     nodes = c(16), act_fn = c(2), out_act_fn = 2, iter = 200,  #>     warmup = 100, chains = 1) #>  #> Data Summary: #> Number of observations: 10  #> Number of features: 2  #>  #> Network Architecture: #> Number of hidden layers: 1  #> Nodes per layer: 16  #> Activation functions: 2  #> Output activation function: 2  #>  #> Posterior Summary (Key Parameters): #>                  mean    se_mean        sd      2.5%        25%          50% #> w_out[1]  -0.04345777 0.07981887 1.1288093 -2.280074 -0.7739249 -0.084563996 #> w_out[2]  -0.10854421 0.06492203 0.9181362 -1.820706 -0.8158379 -0.129244986 #> w_out[3]  -0.04733930 0.08728398 1.1709530 -2.284902 -0.6974198 -0.069762017 #> w_out[4]  -0.07442612 0.08746013 1.0056823 -1.765856 -0.8388857  0.060868077 #> w_out[5]  -0.08251131 0.07005253 0.9739135 -1.941951 -0.6649070 -0.067906255 #> w_out[6]  -0.09651904 0.06661793 0.9421197 -1.831560 -0.6940963 -0.023229666 #> w_out[7]  -0.08778892 0.07564171 0.9924330 -1.866496 -0.8478535 -0.103602978 #> w_out[8]   0.02903283 0.07734812 1.0896562 -2.087356 -0.6706888  0.067145045 #> w_out[9]  -0.13078702 0.06295167 0.7584826 -1.601768 -0.5649343 -0.112141100 #> w_out[10] -0.08238946 0.07941397 0.8960922 -1.871830 -0.8553466  0.008721204 #> w_out[11] -0.10940235 0.05845876 0.8267317 -1.569305 -0.7004692 -0.164975023 #> w_out[12] -0.13958470 0.07291295 0.9105779 -2.086525 -0.6294893 -0.114593361 #> w_out[13] -0.16140507 0.07681523 0.8308345 -1.642827 -0.7390763 -0.265218071 #> w_out[14] -0.10621591 0.07937302 1.1225040 -2.145834 -1.0087129 -0.124112967 #> w_out[15] -0.18700148 0.07406293 1.0021791 -2.049505 -0.8018032 -0.185735154 #> w_out[16] -0.13709871 0.07999005 0.8108405 -1.737055 -0.6493309 -0.061811801 #> b_out     -0.10677161 0.05751580 0.7707151 -1.655863 -0.7079414 -0.003325278 #>                 75%    97.5%    n_eff      Rhat #> w_out[1]  0.6424576 2.323639 200.0000 0.9900273 #> w_out[2]  0.4732469 1.862930 200.0000 1.0000001 #> w_out[3]  0.5712573 1.929134 179.9740 0.9916430 #> w_out[4]  0.5484194 2.061503 132.2213 1.0338821 #> w_out[5]  0.6097928 1.561309 193.2828 0.9924725 #> w_out[6]  0.5037707 1.614188 200.0000 1.0137819 #> w_out[7]  0.6459444 1.745976 172.1392 0.9941446 #> w_out[8]  0.8734678 1.919111 198.4630 0.9904989 #> w_out[9]  0.2781727 1.195860 145.1699 0.9908800 #> w_out[10] 0.5593301 1.452123 127.3244 0.9988283 #> w_out[11] 0.5374080 1.444190 200.0000 0.9928589 #> w_out[12] 0.3257585 1.587033 155.9642 0.9937455 #> w_out[13] 0.4468593 1.392755 116.9861 0.9964299 #> w_out[14] 0.6969567 2.039603 200.0000 0.9926457 #> w_out[15] 0.4123997 1.913980 183.1002 0.9906695 #> w_out[16] 0.4020165 1.462336 102.7541 0.9914435 #> b_out     0.4391922 1.189386 179.5616 0.9916888 #>  #> Model Fit Information: #> Iterations: 200  #> Warmup: 100  #> Thinning: 1  #> Chains: 1  #>  #> Predictive Performance: #> Setting levels: control = 0, case = 1 #> Setting direction: controls < cases #> Confusion matrix (training with 0.5 cutoff): 7 3  #> Accuracy (training with 0.5 cutoff): 0.7  #> 0.7142857  #>  #> Notes: #> Check convergence diagnostics for parameters with high R-hat values. summary(model_cat) #> Call: #> bnns.default(formula = y_cat ~ -1 + x1 + x2, data = df, L = 3,  #>     nodes = c(32, 16, 8), act_fn = c(3, 2, 2), out_act_fn = 3,  #>     iter = 200, warmup = 100, chains = 1) #>  #> Data Summary: #> Number of observations: 10  #> Number of features: 2  #>  #> Network Architecture: #> Number of hidden layers: 3  #> Nodes per layer: 32, 16, 8  #> Activation functions: 3, 2, 2  #> Output activation function: 3  #>  #> Posterior Summary (Key Parameters): #>                   mean    se_mean        sd      2.5%        25%         50% #> w_out[1,1]  0.01394526 0.07036622 0.9951286 -1.842787 -0.7352138  0.03492211 #> w_out[1,2] -0.08280125 0.06549208 0.9261979 -1.725050 -0.5972658 -0.05306723 #> w_out[1,3]  0.01573850 0.06314323 0.8929801 -1.599088 -0.6772641  0.04761421 #> w_out[2,1]  0.07036115 0.06026366 0.8522569 -1.402218 -0.5240907  0.04511580 #> w_out[2,2] -0.12329278 0.07094791 1.0033549 -2.001673 -0.7256266 -0.20538396 #> w_out[2,3]  0.01790976 0.06701062 0.9476732 -1.679826 -0.7097821  0.09160038 #> w_out[3,1]  0.03239133 0.08259533 1.1680744 -2.254300 -0.8092592  0.12058830 #> w_out[3,2] -0.07898128 0.09486460 1.1532263 -2.391624 -0.8628898 -0.25924333 #> w_out[3,3] -0.07272037 0.06814890 0.9637709 -2.103192 -0.8542239  0.03632515 #> w_out[4,1]  0.05156983 0.07059578 0.9983751 -1.840065 -0.5747548 -0.02963318 #> w_out[4,2] -0.09714691 0.05740685 0.8118555 -1.538313 -0.6320181 -0.10185898 #> w_out[4,3]  0.03644411 0.07437223 1.0517822 -1.689593 -0.6589942  0.06534725 #> w_out[5,1]  0.04368120 0.05885995 0.8324054 -1.533618 -0.4949419  0.02237846 #> w_out[5,2] -0.08286049 0.08133546 1.1502570 -2.248796 -0.8874759 -0.11065365 #> w_out[5,3]  0.02237333 0.05802117 0.8205433 -1.794007 -0.4839838  0.01150155 #> w_out[6,1]  0.14088588 0.07903914 1.1177822 -2.089278 -0.4444319  0.12407505 #> w_out[6,2] -0.11847308 0.06254868 0.8845720 -1.704537 -0.7062881 -0.03704612 #> w_out[6,3]  0.05785091 0.06478514 0.9162003 -1.764157 -0.5177482 -0.02077027 #> w_out[7,1]  0.12612793 0.07646742 1.0814126 -2.216329 -0.6519762  0.07510610 #> w_out[7,2] -0.05932307 0.06164795 0.8718337 -1.755824 -0.6138528 -0.06745596 #> w_out[7,3]  0.01842045 0.07330898 0.9390262 -1.690906 -0.6639781 -0.03973415 #> w_out[8,1]  0.12033166 0.05488780 0.7474899 -1.165213 -0.3938527  0.10233644 #> w_out[8,2] -0.10743562 0.08056516 1.1393635 -1.971649 -1.0039259 -0.07132602 #> w_out[8,3]  0.02160029 0.07071598 0.9308556 -1.528458 -0.7194426  0.05584917 #> b_out[1]    0.14097861 0.06239699 0.8824267 -1.895995 -0.4287659  0.11257944 #> b_out[2]   -0.20330320 0.07263399 1.0271997 -2.288989 -0.8910927 -0.23371122 #> b_out[3]   -0.08665864 0.07534820 1.0655845 -1.986733 -0.8796537 -0.21590654 #>                  75%    97.5%    n_eff      Rhat #> w_out[1,1] 0.7880883 1.711400 200.0000 0.9906571 #> w_out[1,2] 0.4556183 1.960764 200.0000 0.9905777 #> w_out[1,3] 0.7699205 1.473742 200.0000 0.9899590 #> w_out[2,1] 0.6176310 1.785358 200.0000 1.0185192 #> w_out[2,2] 0.5950283 1.726812 200.0000 0.9908967 #> w_out[2,3] 0.7451203 1.467679 200.0000 0.9900956 #> w_out[3,1] 0.9091794 2.202241 200.0000 0.9899530 #> w_out[3,2] 0.9128163 1.884212 147.7817 0.9953293 #> w_out[3,3] 0.6750217 1.512576 200.0000 0.9908107 #> w_out[4,1] 0.7711055 1.868197 200.0000 0.9906220 #> w_out[4,2] 0.4448852 1.327239 200.0000 0.9899551 #> w_out[4,3] 0.8367175 1.780680 200.0000 0.9925562 #> w_out[5,1] 0.6464946 1.560538 200.0000 0.9910343 #> w_out[5,2] 0.6141291 2.314026 200.0000 0.9900906 #> w_out[5,3] 0.5216419 1.652119 200.0000 0.9906631 #> w_out[6,1] 0.8638882 2.474803 200.0000 0.9910499 #> w_out[6,2] 0.4958150 1.463965 200.0000 0.9925982 #> w_out[6,3] 0.6543789 1.619203 200.0000 0.9900060 #> w_out[7,1] 0.9462813 1.900933 200.0000 0.9901126 #> w_out[7,2] 0.4982239 1.534793 200.0000 0.9978339 #> w_out[7,3] 0.7258390 1.897475 164.0745 0.9911252 #> w_out[8,1] 0.6205414 1.530701 185.4637 0.9906603 #> w_out[8,2] 0.7456442 2.089929 200.0000 0.9963176 #> w_out[8,3] 0.7708924 1.529909 173.2724 1.0134181 #> b_out[1]   0.7355672 1.824535 200.0000 0.9904573 #> b_out[2]   0.4550961 1.747758 200.0000 0.9974122 #> b_out[3]   0.6986215 1.867415 200.0000 0.9916260 #>  #> Model Fit Information: #> Iterations: 200  #> Warmup: 100  #> Thinning: 1  #> Chains: 1  #>  #> Predictive Performance: #> Log-loss (training): 1.014759  #> AUC (training): 0.8555556  #>  #> Notes: #> Check convergence diagnostics for parameters with high R-hat values."},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"making-predictions","dir":"Articles","previous_headings":"","what":"5. Making Predictions","title":"bnns","text":"predict() function generates predictions new data. format predictions depends output activation function.","code":"# New data test_x <- matrix(runif(10), nrow = 5, ncol = 2) |>   data.frame() |>   `colnames<-`(c(\"x1\", \"x2\"))  # Regression predictions pred_reg <- predict(model_reg, test_x)  # Binary classification predictions pred_bin <- predict(model_bin, test_x)  # Multiclass classification predictions pred_cat <- predict(model_cat, test_x)"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"evaluating-the-model","dir":"Articles","previous_headings":"","what":"6. Evaluating the Model","title":"bnns","text":"bnns package includes utility functions like measure_cont, measure_bin, measure_cat evaluating model performance.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"regression-evaluation","dir":"Articles","previous_headings":"6. Evaluating the Model","what":"Regression Evaluation","title":"bnns","text":"","code":"# True responses test_y <- rnorm(5)  # Evaluate predictions metrics_reg <- measure_cont(obs = test_y, pred = pred_reg) print(metrics_reg) #> $rmse #> [1] 1.026212 #>  #> $mae #> [1] 0.910182"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"binary-classification-evaluation","dir":"Articles","previous_headings":"6. Evaluating the Model","what":"Binary Classification Evaluation","title":"bnns","text":"","code":"# True responses test_y_bin <- sample(c(rep(0, 2), rep(1, 3)), 5)  # Evaluate predictions metrics_bin <- measure_bin(obs = test_y_bin, pred = pred_bin) #> Setting levels: control = 0, case = 1 #> Setting direction: controls > cases print(metrics_bin) #> $conf_mat #>    pred_label #> obs 0 #>   0 2 #>   1 3 #>  #> $accuracy #> [1] 0.4 #>  #> $ROC #>  #> Call: #> roc.default(response = obs, predictor = pred) #>  #> Data: pred in 2 controls (obs 0) > 3 cases (obs 1). #> Area under the curve: 1 #>  #> $AUC #> [1] 1"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"multiclass-classification-evaluation","dir":"Articles","previous_headings":"6. Evaluating the Model","what":"Multiclass Classification Evaluation","title":"bnns","text":"","code":"# True responses test_y_cat <- factor(sample(letters[1:3], 5, replace = TRUE))  # Evaluate predictions metrics_cat <- measure_cat(obs = test_y_cat, pred = pred_cat) print(metrics_cat) #> $log_loss #> [1] 1.204959 #>  #> $ROC #>  #> Call: #> multiclass.roc.default(response = obs, predictor = `colnames<-`(data.frame(pred),     levels(obs))) #>  #> Data: multivariate predictor `colnames<-`(data.frame(pred), levels(obs)) with 3 levels of obs: a, b, c. #> Multi-class area under the curve: 0.1667 #>  #> $AUC #> [1] 0.1666667"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"customized-prior","dir":"Articles","previous_headings":"","what":"7. Customized Prior","title":"bnns","text":"Customized priors can used weights well sigma parameter (regression). show example use Cauchy prior weights multi-classification case.","code":"model_cat_cauchy <- bnns(   y_cat ~ -1 + x1 + x2,   data = df,   L = 3,   nodes = c(32, 16, 8),   act_fn = c(3, 2, 2),   out_act_fn = 3, # Output activation: 3 = Softmax   iter = 2e2,   warmup = 1e2,   chains = 1,   prior_weights = list(dist = \"cauchy\", params = list(mu = 0, sigma = 2.5)) ) # Evaluate predictions metrics_cat_cauchy <- measure_cat(obs = test_y_cat, pred = predict(model_cat_cauchy, test_x)) print(metrics_cat_cauchy) #> $log_loss #> [1] 1.423818 #>  #> $ROC #>  #> Call: #> multiclass.roc.default(response = obs, predictor = `colnames<-`(data.frame(pred),     levels(obs))) #>  #> Data: multivariate predictor `colnames<-`(data.frame(pred), levels(obs)) with 3 levels of obs: a, b, c. #> Multi-class area under the curve: 0.2222 #>  #> $AUC #> [1] 0.2222222"},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"notes-on-bayesian-neural-networks","dir":"Articles","previous_headings":"","what":"8. Notes on Bayesian Neural Networks","title":"bnns","text":"Bayesian inference allows use prior knowledge weights. allows uncertainty quantification predictions. Always check convergence diagnostics R-hat values. Use informative priors possible stabilize model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/bnns.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"bnns","text":"details, consult source code GitHub.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using Bayesian Neural Networks in Clinical Trials","text":"Bayesian Neural Networks (BNNs) offer robust framework prediction clinical trials providing posterior distributions predictions. allows probabilistic reasoning, computing probability treatment achieves certain efficacy threshold proportion success. vignette, : 1. Illustrate data preparation clinical trial setting. 2. Fit BNN simulate clinical trial outcomes. 3. Leverage posterior distributions decision-making, calculating posterior probabilities treatment success.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"data-preparation","dir":"Articles","previous_headings":"","what":"1. Data Preparation","title":"Using Bayesian Neural Networks in Clinical Trials","text":"Consider hypothetical clinical trial comparing efficacy new treatment placebo. response variable binary, representing treatment success (1) failure (0).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"simulating-data","dir":"Articles","previous_headings":"1. Data Preparation","what":"Simulating Data","title":"Using Bayesian Neural Networks in Clinical Trials","text":"","code":"set.seed(123)  # Simulate predictor variables (e.g., patient covariates) n_subjects <- 100 Age <- runif(n_subjects, 18, 50) # Age in years Dose <- runif(n_subjects, 10, 100) # Dose levels Severity <- runif(n_subjects, 1, 10) # Baseline severity (arbitrary scale)  # Define true probabilities using a nonlinear function beta_0 <- 1 beta_1 <- 0.3 beta_2 <- -0.1 beta_3 <- -0.02 beta_4 <- 0.005  logit_p <- beta_0 + beta_1 * Dose + beta_2 * log(Severity) +   beta_3 * Age^2 + beta_4 * (Age * Dose) p_success <- 1 / (1 + exp(-logit_p)) # Sigmoid transformation  # Simulate binary outcomes Success <- rbinom(n_subjects, size = 1, prob = p_success)  trial_data <- cbind.data.frame(Success, Age, Dose, Severity)  # Split into training and testing train_idx <- sample(seq_len(n_subjects), size = 0.8 * n_subjects) training_data <- trial_data[train_idx, ] test_data <- trial_data[-train_idx, ]"},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"fitting-a-bayesian-neural-network","dir":"Articles","previous_headings":"","what":"2. Fitting a Bayesian Neural Network","title":"Using Bayesian Neural Networks in Clinical Trials","text":"Fit BNN simulated data. use binary classification model logistic sigmoid activation output layer.","code":"# Fit a BNN model <- bnns(   formula = Success ~ -1 + .,   data = training_data,   L = 2, # Number of hidden layers   nodes = c(16, 8), # Nodes per layer   act_fn = c(2, 2), # Activation functions for hidden layers   out_act_fn = 2, # Output activation: logistic sigmoid   iter = 2e2, # Bayesian sampling iterations   warmup = 1e2, # Warmup iterations   chains = 1 # Number of MCMC chains )"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"generating-predictions-with-uncertainty","dir":"Articles","previous_headings":"3. Posterior Predictions","what":"Generating Predictions with Uncertainty","title":"Using Bayesian Neural Networks in Clinical Trials","text":"posterior distribution predictions allows us compute just point estimates also probabilistic metrics. entry posterior_preds represents predicted probability success single posterior sample.","code":"# Generate posterior predictions for the test set posterior_preds <- predict(model, subset(test_data, select = -Success)) head(posterior_preds) # Each row corresponds to a subject, and columns are MCMC samples #>            [,1]       [,2]       [,3]       [,4]       [,5]       [,6] #> [1,] 0.95360552 0.95021834 0.94580631 0.97381018 0.94068344 0.96359538 #> [2,] 0.06315939 0.09741205 0.09364063 0.07900010 0.40425935 0.10932841 #> [3,] 0.14972664 0.11282616 0.07849459 0.04564657 0.10429327 0.07485027 #> [4,] 0.94598885 0.95010117 0.94321209 0.97329536 0.94057337 0.96320307 #> [5,] 0.77604624 0.92940934 0.37841744 0.59757302 0.80367070 0.42113683 #> [6,] 0.05192679 0.09933909 0.05331637 0.03240259 0.07729776 0.07236551 #>            [,7]       [,8]       [,9]      [,10]     [,11]      [,12] #> [1,] 0.96033781 0.95126412 0.95958453 0.98799108 0.9221397 0.88252517 #> [2,] 0.09085240 0.07730268 0.15265533 0.12565185 0.1029894 0.05112108 #> [3,] 0.11647928 0.07896275 0.15455183 0.05483277 0.1090577 0.06512479 #> [4,] 0.95256125 0.95126325 0.95917550 0.99033757 0.9223156 0.90678143 #> [5,] 0.44855007 0.73394715 0.72664563 0.60914730 0.6083129 0.75588868 #> [6,] 0.04244795 0.10405776 0.07834502 0.04424655 0.1151133 0.06173186 #>           [,13]      [,14]     [,15]      [,16]     [,17]      [,18]     [,19] #> [1,] 0.94826062 0.98336299 0.9483871 0.93820027 0.9389601 0.91249512 0.9250233 #> [2,] 0.06410978 0.08864533 0.1461942 0.05711957 0.1273991 0.09691140 0.1825022 #> [3,] 0.09552574 0.10258413 0.1546943 0.05010718 0.1128786 0.05646500 0.1824316 #> [4,] 0.92006090 0.95337677 0.9473623 0.92913291 0.9388833 0.91013212 0.8475761 #> [5,] 0.27954728 0.42333314 0.5446129 0.09064981 0.8259752 0.67166452 0.7611848 #> [6,] 0.11198219 0.10121687 0.1339196 0.04884905 0.1020319 0.07528487 0.1799139 #>          [,20]      [,21]      [,22]      [,23]     [,24]      [,25]     [,26] #> [1,] 0.8570123 0.95188447 0.93614653 0.97915223 0.9538411 0.88670961 0.8164815 #> [2,] 0.2108441 0.01876517 0.05159579 0.06854279 0.1419617 0.07576468 0.2072758 #> [3,] 0.2106688 0.02228304 0.09136696 0.07607244 0.1582908 0.07623292 0.2078918 #> [4,] 0.8570123 0.95186947 0.88334698 0.96920041 0.9211345 0.91911254 0.8163489 #> [5,] 0.2227564 0.33119388 0.82013013 0.91679389 0.8649880 0.55718589 0.4057789 #> [6,] 0.2259007 0.02640083 0.06031167 0.06703606 0.2051299 0.10078710 0.2690523 #>           [,27]      [,28]      [,29]      [,30]      [,31]      [,32] #> [1,] 0.93448124 0.83093886 0.95971761 0.93211563 0.88580751 0.76933197 #> [2,] 0.05282613 0.09073357 0.06147170 0.39366445 0.18901170 0.02742836 #> [3,] 0.02751751 0.09145168 0.07648255 0.17540935 0.07081170 0.03542751 #> [4,] 0.89772796 0.83087890 0.95971782 0.91909721 0.88379427 0.76907414 #> [5,] 0.47736025 0.60638296 0.66572018 0.27103498 0.41133933 0.76177210 #> [6,] 0.02637232 0.09142162 0.06127533 0.06807762 0.07100077 0.02757636 #>          [,33]      [,34]      [,35]     [,36]      [,37]     [,38]     [,39] #> [1,] 0.9691211 0.95037079 0.91495821 0.9293669 0.90981579 0.9728767 0.9576554 #> [2,] 0.1592738 0.02956163 0.07804768 0.1954525 0.18927290 0.1623113 0.1544121 #> [3,] 0.2768682 0.21686511 0.07813405 0.2394636 0.13124826 0.1634386 0.1565894 #> [4,] 0.9541437 0.91899709 0.83258184 0.9274860 0.88273197 0.9663756 0.8989994 #> [5,] 0.7496194 0.65550849 0.21909992 0.6373298 0.74355243 0.6767925 0.7790926 #> [6,] 0.2818228 0.10205964 0.11796825 0.1921952 0.08522386 0.1886304 0.1693040 #>          [,40]      [,41]      [,42]      [,43]     [,44]      [,45]      [,46] #> [1,] 0.9101893 0.91970037 0.90658425 0.95117991 0.9822602 0.91742259 0.96650912 #> [2,] 0.1149193 0.09188143 0.03521565 0.14456716 0.1213527 0.04969016 0.06183125 #> [3,] 0.1129824 0.09100565 0.07006517 0.09862832 0.2124452 0.06168066 0.07803220 #> [4,] 0.8882882 0.91749136 0.90351073 0.95036190 0.9694353 0.91739252 0.96175475 #> [5,] 0.6578412 0.47061066 0.72008646 0.45478921 0.7476535 0.64267045 0.82180155 #> [6,] 0.1175729 0.07193414 0.03138329 0.11224624 0.1384847 0.04272127 0.07460268 #>           [,47]     [,48]      [,49]      [,50]      [,51]      [,52]     [,53] #> [1,] 0.97492818 0.9527216 0.95113976 0.93690596 0.95197720 0.97297608 0.9059660 #> [2,] 0.12358277 0.1387682 0.08204913 0.06798811 0.04073058 0.11865216 0.1427125 #> [3,] 0.07277895 0.1493934 0.08187902 0.22042299 0.17493907 0.11776046 0.1116551 #> [4,] 0.97499294 0.9527074 0.85641502 0.93586722 0.94918490 0.97273670 0.7854650 #> [5,] 0.83792639 0.6710783 0.51332833 0.84793377 0.60336654 0.88924304 0.4423166 #> [6,] 0.03527414 0.1256664 0.05142583 0.07758123 0.12551438 0.02654554 0.1999366 #>          [,54]     [,55]     [,56]      [,57]     [,58]     [,59]      [,60] #> [1,] 0.9190505 0.9547982 0.9011607 0.92761103 0.9340773 0.8931508 0.92166620 #> [2,] 0.1526169 0.1616560 0.1296130 0.06609694 0.1838781 0.1982891 0.16796344 #> [3,] 0.1781386 0.3765773 0.1120620 0.05661459 0.1868778 0.2053042 0.07366499 #> [4,] 0.9188180 0.9222772 0.8715837 0.92761047 0.9340964 0.8926439 0.91848922 #> [5,] 0.5072204 0.5919946 0.4245891 0.65641849 0.8038999 0.4518240 0.28096960 #> [6,] 0.1013064 0.3604606 0.1065209 0.12930304 0.2296690 0.2872912 0.11808435 #>           [,61]      [,62]     [,63]     [,64]      [,65]     [,66]     [,67] #> [1,] 0.93396078 0.93471399 0.9652784 0.9330873 0.91512323 0.9450177 0.9292480 #> [2,] 0.05474521 0.03546805 0.1316126 0.1077329 0.05075558 0.2559873 0.1151109 #> [3,] 0.04890935 0.06782028 0.1776378 0.1145630 0.08794212 0.2212894 0.1315142 #> [4,] 0.93393227 0.93214157 0.9648835 0.9330872 0.91473128 0.9428492 0.9285513 #> [5,] 0.67508992 0.73598917 0.6865889 0.4235814 0.55106586 0.8371144 0.2889200 #> [6,] 0.05188726 0.18268001 0.3568487 0.0677504 0.06142090 0.1853769 0.1149471 #>           [,68]     [,69]      [,70]      [,71]      [,72]      [,73] #> [1,] 0.98202096 0.8603917 0.93841203 0.91656721 0.94490384 0.93847974 #> [2,] 0.02021273 0.1003205 0.11673252 0.22982447 0.10470599 0.19191475 #> [3,] 0.01877231 0.1008062 0.08649589 0.05468524 0.08515729 0.11594363 #> [4,] 0.93430726 0.8584144 0.94627329 0.94324038 0.93478241 0.93843010 #> [5,] 0.41895573 0.3606970 0.89526535 0.49798637 0.73349326 0.70493744 #> [6,] 0.01559951 0.1006602 0.06878357 0.04211082 0.04942317 0.05747413 #>           [,74]      [,75]     [,76]      [,77]      [,78]      [,79]     [,80] #> [1,] 0.88909075 0.98278828 0.8639886 0.96879020 0.96491291 0.90519402 0.8568571 #> [2,] 0.02375625 0.05936686 0.1532583 0.07583279 0.12075168 0.13622565 0.1425923 #> [3,] 0.09414987 0.06172718 0.1593923 0.06540429 0.09777358 0.13893618 0.2166740 #> [4,] 0.88012789 0.93171386 0.8940085 0.96884265 0.91455824 0.88949203 0.7810638 #> [5,] 0.55118557 0.29369107 0.5764709 0.73318432 0.37803663 0.54586348 0.2976378 #> [6,] 0.04178248 0.04856018 0.1502669 0.11169427 0.10363458 0.09729015 0.2196317 #>          [,81]     [,82]     [,83]      [,84]      [,85]     [,86]      [,87] #> [1,] 0.9541870 0.8667449 0.9337858 0.97847860 0.97328000 0.9518035 0.96540544 #> [2,] 0.1528603 0.1620797 0.3168863 0.02675568 0.30049688 0.3168879 0.09688536 #> [3,] 0.0427016 0.1633061 0.1270849 0.01671995 0.17654239 0.1213549 0.09675958 #> [4,] 0.9541605 0.8611769 0.9337718 0.93622344 0.95527090 0.9252328 0.96193539 #> [5,] 0.6887550 0.7877992 0.5043067 0.84606755 0.47552655 0.5717879 0.68115868 #> [6,] 0.1028810 0.1614773 0.1353831 0.01130216 0.08714658 0.1211906 0.07057784 #>          [,88]      [,89]      [,90]      [,91]      [,92]      [,93] #> [1,] 0.9547971 0.87635713 0.95538568 0.91332400 0.95599724 0.98577016 #> [2,] 0.1052705 0.07195412 0.04338679 0.07492102 0.06852273 0.14705369 #> [3,] 0.1055129 0.02586769 0.05436160 0.11121704 0.30145168 0.04992526 #> [4,] 0.9534533 0.87695772 0.91494129 0.89378463 0.85411298 0.98240236 #> [5,] 0.8558363 0.34412490 0.88552859 0.77241344 0.63225527 0.27430942 #> [6,] 0.1049393 0.01486669 0.02440260 0.05346084 0.40247117 0.04545387 #>           [,94]     [,95]      [,96]      [,97]      [,98]     [,99]    [,100] #> [1,] 0.95044320 0.9603671 0.98383313 0.90337300 0.92044419 0.9730071 0.9461210 #> [2,] 0.06496306 0.2055474 0.05476457 0.05322308 0.10997617 0.1727534 0.1422422 #> [3,] 0.06181107 0.2059193 0.13782449 0.02806611 0.07243965 0.1057670 0.1419542 #> [4,] 0.95000504 0.9360937 0.95459042 0.88155150 0.91935129 0.9653030 0.9556160 #> [5,] 0.75774754 0.5155509 0.91215866 0.44654522 0.48406376 0.5783605 0.3642702 #> [6,] 0.05950760 0.1951705 0.05787978 0.01370030 0.05254762 0.1052707 0.1411693"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"threshold-based-decision-making","dir":"Articles","previous_headings":"4. Posterior Probability of Treatment Success","what":"Threshold-Based Decision-Making","title":"Using Bayesian Neural Networks in Clinical Trials","text":"Suppose define treatment success predicted probability ≥ 0.6. can compute posterior probability threshold met subject.","code":"# Compute posterior probabilities of success (p_hat ≥ 0.6) success_threshold <- 0.6 posterior_probs_success <- rowMeans(posterior_preds >= success_threshold) head(posterior_probs_success) #> [1] 1.00 0.00 0.00 1.00 0.53 0.00"},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"proportion-of-subjects-likely-to-achieve-success","dir":"Articles","previous_headings":"4. Posterior Probability of Treatment Success","what":"Proportion of Subjects Likely to Achieve Success","title":"Using Bayesian Neural Networks in Clinical Trials","text":"Next, calculate posterior probability certain proportion subjects treatment group achieve success.","code":"# Define success proportion threshold prop_success_threshold <- 0.7  # Simulate posterior proportion of success posterior_success_proportion <- colMeans(posterior_preds >= success_threshold)  # Posterior probability that ≥ 70% of subjects achieve success posterior_prob_high_success <- mean(posterior_success_proportion >= prop_success_threshold) posterior_prob_high_success #> [1] 0"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"posterior-predictive-distribution","dir":"Articles","previous_headings":"5. Visualizing Posterior Insights","what":"Posterior Predictive Distribution","title":"Using Bayesian Neural Networks in Clinical Trials","text":"","code":"library(ggplot2)  # Plot posterior probabilities of success for individual subjects ggplot(data.frame(Subject = seq_len(nrow(test_data)), Prob = posterior_probs_success), aes(x = Subject, y = Prob)) +   geom_bar(stat = \"identity\", fill = \"blue\") +   geom_hline(yintercept = success_threshold, color = \"red\", linetype = \"dashed\") +   labs(     title = \"Posterior Probability of Treatment Success\",     x = \"Subject\",     y = \"Posterior Probability\"   )"},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"distribution-of-success-proportion","dir":"Articles","previous_headings":"5. Visualizing Posterior Insights","what":"Distribution of Success Proportion","title":"Using Bayesian Neural Networks in Clinical Trials","text":"","code":"# Histogram of posterior success proportions ggplot(data.frame(SuccessProp = posterior_success_proportion), aes(x = SuccessProp)) +   geom_histogram(fill = \"green\", bins = 20) +   geom_vline(xintercept = prop_success_threshold, color = \"red\", linetype = \"dashed\") +   labs(     title = \"Posterior Distribution of Success Proportion\",     x = \"Proportion of Subjects Achieving Success\",     y = \"Frequency\"   )"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"bayesian-probability-threshold","dir":"Articles","previous_headings":"6. Clinical Trial Decision-Making","what":"Bayesian Probability Threshold","title":"Using Bayesian Neural Networks in Clinical Trials","text":"posterior probability can guide decision-making. example: - posterior_prob_high_success > 0.9, consider treatment effective. - posterior_prob_high_success < 0.1, consider treatment ineffective. - Otherwise, collect data refine model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/articles/ct_app.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"7. Conclusion","title":"Using Bayesian Neural Networks in Clinical Trials","text":"bnns package empowers clinical trial analysts leverage Bayesian Neural Networks predictive modeling decision-making. utilizing posterior distributions, can: - Quantify uncertainty predictions. - Make informed decisions treatment efficacy. - Evaluate trial outcomes based predefined success criteria. probabilistic framework particularly valuable scenarios uncertainty plays critical role decision-making, early-phase clinical trials. ```","code":""},{"path":"https://swarnendu-stat.github.io/bnns/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Swarnendu Chatterjee. Author, maintainer, copyright holder.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chatterjee S (2025). bnns: Bayesian Neural Network Stan. R package version 0.0.0.9000, https://swarnendu-stat.github.io/bnns/, https://github.com/swarnendu-stat/bnns.","code":"@Manual{,   title = {bnns: Bayesian Neural Network with Stan},   author = {Swarnendu Chatterjee},   year = {2025},   note = {R package version 0.0.0.9000, https://swarnendu-stat.github.io/bnns/},   url = {https://github.com/swarnendu-stat/bnns}, }"},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"bnns-","dir":"","previous_headings":"","what":"Bayesian Neural Network with Stan","title":"Bayesian Neural Network with Stan","text":"bnns package provides tools fit Bayesian Neural Networks (BNNs) regression classification problems. designed flexible, supporting various network architectures, activation functions, output types, making suitable simple complex data analysis tasks.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Bayesian Neural Network with Stan","text":"Support multi-layer neural networks customizable architecture. Choice activation functions (e.g., sigmoid, ReLU, tanh). Outputs regression (continuous response) classification (binary multiclass). Bayesian inference, providing posterior distributions predictions parameters. Applications domains clinical trials, predictive modeling, .","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"installation-stable-cran-version","dir":"","previous_headings":"","what":"Installation (stable CRAN version)","title":"Bayesian Neural Network with Stan","text":"install bnns package CRAN, use following:","code":"install.packages(\"bnns\")"},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"installation-development-version","dir":"","previous_headings":"","what":"Installation (development version)","title":"Bayesian Neural Network with Stan","text":"install bnns package GitHub, use following:","code":"# Install devtools if not already installed if (!requireNamespace(\"devtools\", quietly = TRUE)) {   install.packages(\"devtools\") }  # Install bnns devtools::install_github(\"swarnendu-stat/bnns\")"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"id_1-simulate-data","dir":"","previous_headings":"Getting Started","what":"1. Simulate Data","title":"Bayesian Neural Network with Stan","text":"example simulate data regression:","code":"set.seed(123) df <- data.frame(x1 = runif(10), x2 = runif(10), y = rnorm(10))"},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"id_2-fit-a-bnn-model","dir":"","previous_headings":"Getting Started","what":"2. Fit a BNN Model","title":"Bayesian Neural Network with Stan","text":"fit Bayesian Neural Network:","code":"library(bnns)  model <- bnns(y ~ -1 + x1 + x2,   data = df, L = 2, nodes = c(10, 8), act_fn = c(2, 3), out_act_fn = 1,   iter = 1e2, warmup = 5e1, chains = 1, seed = 123 )"},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"id_3-model-summary","dir":"","previous_headings":"Getting Started","what":"3. Model Summary","title":"Bayesian Neural Network with Stan","text":"Summarize fitted model:","code":"summary(model) #> Call: #> bnns.default(formula = y ~ -1 + x1 + x2, data = df, L = 2, nodes = c(10,  #>     8), act_fn = c(2, 3), out_act_fn = 1, iter = 100, warmup = 50,  #>     chains = 1, seed = 123) #>  #> Data Summary: #> Number of observations: 10  #> Number of features: 2  #>  #> Network Architecture: #> Number of hidden layers: 2  #> Nodes per layer: 10, 8  #> Activation functions: 2, 3  #> Output activation function: 1  #>  #> Posterior Summary (Key Parameters): #>                 mean    se_mean        sd       2.5%        25%         50% #> w_out[1] -0.02324795 0.13129860 1.0762213 -1.6600031 -1.0103546 -0.18735995 #> w_out[2]  0.07270977 0.14981448 0.8350675 -1.3137496 -0.4830793 -0.06217806 #> w_out[3]  0.11283857 0.11428048 0.7623686 -1.0485410 -0.5333280  0.08261137 #> w_out[4]  0.20054171 0.11334737 0.7588289 -1.2580135 -0.2220071  0.16581899 #> w_out[5] -0.06208152 0.16932869 1.0527341 -1.8664903 -0.9103519  0.06347047 #> w_out[6]  0.30302264 0.15389760 1.0756999 -1.6702569 -0.4103843  0.19989870 #> w_out[7]  0.30786594 0.11187634 0.8229034 -1.0878378 -0.3385778  0.32939318 #> w_out[8] -0.15144312 0.12836466 0.9245842 -1.7927356 -0.6969301 -0.20455107 #> b_out     0.24797547 0.13604812 0.9077106 -1.5935206 -0.4190687  0.23167117 #> sigma     0.95245930 0.04625639 0.3037826  0.5781807  0.7346287  0.92544357 #>                75%    97.5%    n_eff      Rhat #> w_out[1] 0.7441097 1.840549 67.18664 0.9865655 #> w_out[2] 0.7052703 1.624580 31.06960 0.9923414 #> w_out[3] 0.7150443 1.618166 44.50265 1.0045883 #> w_out[4] 0.7419605 1.455819 44.81927 0.9798358 #> w_out[5] 0.6306202 1.720851 38.65238 0.9824005 #> w_out[6] 1.0225610 2.465771 48.85607 1.0054149 #> w_out[7] 0.9952039 1.614277 54.10299 0.9812693 #> w_out[8] 0.3860326 1.242786 51.88024 0.9814778 #> b_out    0.9793195 1.889829 44.51535 0.9851646 #> sigma    1.0812277 1.639066 43.13027 0.9828852 #>  #> Model Fit Information: #> Iterations: 100  #> Warmup: 50  #> Thinning: 1  #> Chains: 1  #>  #> Predictive Performance: #> RMSE (training): 0.7956568  #> MAE (training): 0.6356295  #>  #> Notes: #> Check convergence diagnostics for parameters with high R-hat values."},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"id_4-predictions","dir":"","previous_headings":"Getting Started","what":"4. Predictions","title":"Bayesian Neural Network with Stan","text":"Make predictions using trained model:","code":"pred <- predict(model)"},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"id_5-visualization","dir":"","previous_headings":"Getting Started","what":"5. Visualization","title":"Bayesian Neural Network with Stan","text":"Visualize true vs predicted values regression:","code":"plot(df$y, rowMeans(pred), main = \"True vs Predicted\", xlab = \"True Values\", ylab = \"Predicted Values\") abline(0, 1, col = \"red\")"},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"regression-example-with-custom-priors","dir":"","previous_headings":"Applications","what":"Regression Example (with custom priors)","title":"Bayesian Neural Network with Stan","text":"Use bnns regression analysis model continuous outcomes, predicting patient biomarkers clinical trials.","code":"model <- bnns(y ~ -1 + x1 + x2,   data = df, L = 2, nodes = c(10, 8), act_fn = c(2, 3), out_act_fn = 1,   iter = 1e2, warmup = 5e1, chains = 1, seed = 123,   prior_weights = list(dist = \"uniform\", params = list(alpha = -1, beta = 1)),   prior_sigma = list(dist = \"inv_gamma\", params = list(alpha = 1, beta = 1)) )"},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"classification-example","dir":"","previous_headings":"Applications","what":"Classification Example","title":"Bayesian Neural Network with Stan","text":"binary multiclass classification, set out_act_fn 2 (binary) 3 (multiclass). example:","code":"# Simulate binary classification data df <- data.frame(x1 = runif(10), x2 = runif(10), y = sample(0:1, 10, replace = TRUE))  # Fit a binary classification BNN model <- bnns(y ~ -1 + x1 + x2, data = df, L = 2, nodes = c(16, 8), act_fn = c(3, 2), out_act_fn = 2, iter = 1e2, warmup = 5e1, chains = 1)"},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"clinical-trial-applications","dir":"","previous_headings":"Applications","what":"Clinical Trial Applications","title":"Bayesian Neural Network with Stan","text":"Explore posterior probabilities estimate treatment effects success probabilities clinical trials. example, calculate posterior probability achieving clinically meaningful outcome given population.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Bayesian Neural Network with Stan","text":"Detailed vignettes available guide various applications package. See help(bnns) information bnns function arguments.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Bayesian Neural Network with Stan","text":"Contributions welcome! Please raise issues submit pull requests GitHub.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Bayesian Neural Network with Stan","text":"package licensed Apache License. See LICENSE details.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"Fits Bayesian Neural Network (BNN) model using formula interface. function parses formula data create input feature matrix target vector, fits model using bnns.default.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"","code":"# Default S3 method bnns(   formula,   data = list(),   L = 1,   nodes = 16,   act_fn = 2,   out_act_fn = 1,   iter = 1000,   warmup = 200,   thin = 1,   chains = 2,   cores = 2,   seed = 123,   prior_weights = NULL,   prior_bias = NULL,   prior_sigma = NULL,   verbose = FALSE,   refresh = max(iter/10, 1),   ... )"},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"formula symbolic description model fitted. formula specify response variable predictors (e.g., y ~ x1 + x2). data data frame list containing variables model. Default empty list. L integer specifying number hidden layers neural network. Default 1. nodes integer vector specifying number nodes hidden layer. single value provided, applied layers. Default 16. act_fn integer vector specifying activation function(s) hidden layers. Options : 1 tanh 2 sigmoid (default) 3 ReLU 4 softplus out_act_fn integer specifying activation function output layer. Options : 1 linear (default) 2 sigmoid 3 softmax iter integer specifying total number iterations Stan sampler. Default 1e3. warmup integer specifying number warmup iterations Stan sampler. Default 2e2. thin integer specifying thinning interval Stan samples. Default 1. chains integer specifying number Markov chains. Default 2. cores integer specifying number CPU cores use parallel sampling. Default 2. seed integer specifying random seed reproducibility. Default 123. prior_weights list specifying prior distribution weights neural network. list must include two components: dist: character string specifying distribution type. Supported values \"normal\", \"uniform\", \"cauchy\". params: named list specifying parameters chosen distribution: \"normal\": Provide mean (mean distribution) sd (standard deviation). \"uniform\": Provide alpha (lower bound) beta (upper bound). \"cauchy\": Provide mu (location parameter) sigma (scale parameter). prior_weights NULL, default prior normal(0, 1) distribution. example: list(dist = \"normal\", params = list(mean = 0, sd = 1)) list(dist = \"uniform\", params = list(alpha = -1, beta = 1)) list(dist = \"cauchy\", params = list(mu = 0, sigma = 2.5)) prior_bias list specifying prior distribution biases neural network. list must include two components: dist: character string specifying distribution type. Supported values \"normal\", \"uniform\", \"cauchy\". params: named list specifying parameters chosen distribution: \"normal\": Provide mean (mean distribution) sd (standard deviation). \"uniform\": Provide alpha (lower bound) beta (upper bound). \"cauchy\": Provide mu (location parameter) sigma (scale parameter). prior_bias NULL, default prior normal(0, 1) distribution. example: list(dist = \"normal\", params = list(mean = 0, sd = 1)) list(dist = \"uniform\", params = list(alpha = -1, beta = 1)) list(dist = \"cauchy\", params = list(mu = 0, sigma = 2.5)) prior_sigma list specifying prior distribution sigma parameter regression models (out_act_fn = 1). allows setting priors standard deviation residuals. list must include two components: dist: character string specifying distribution type. Supported values \"half-normal\" \"inverse-gamma\". params: named list specifying parameters chosen distribution: \"half-normal\": Provide sd (standard deviation half-normal distribution). \"inverse-gamma\": Provide shape (shape parameter) scale (scale parameter). prior_sigma NULL, default prior half-normal(0, 1) distribution. example: list(dist = \"half_normal\", params = list(mean = 0, sd = 1)) list(dist = \"inv_gamma\", params = list(alpha = 1, beta = 1)) verbose TRUE FALSE: flag indicating whether print intermediate output Stan console, might helpful model debugging. refresh refresh (integer) can used control often progress sampling reported (.e. show progress every refresh iterations). default, refresh = max(iter/10, 1). progress indicator turned refresh <= 0. ... Currently use.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"object class \"bnns\" containing fitted model associated information, including: fit: fitted Stan model object. data: list containing processed training data. call: matched function call. formula: formula used model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"function uses provided formula data generate design matrix predictors response vector. calls helper function bnns_train fit Bayesian Neural Network model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian Neural Network Model Using Formula(default) Interface — bnns.default","text":"","code":"# Example usage with formula interface: data <- data.frame(x1 = runif(10), x2 = runif(10), y = rnorm(10)) model <- bnns(y ~ -1 + x1 + x2,   data = data, L = 1, nodes = 2, act_fn = 3,   iter = 1e2, warmup = 5e1, chains = 1 ) #>  #> SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 1.5e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.15 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 7 #> Chain 1:            adapt_window = 38 #> Chain 1:            term_buffer = 5 #> Chain 1:  #> Chain 1: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 1: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 1: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 1: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 1: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 1: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 1: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 1: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 1: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 1: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 1: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 1: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.007 seconds (Warm-up) #> Chain 1:                0.006 seconds (Sampling) #> Chain 1:                0.013 seconds (Total) #> Chain 1:"},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic Function for Fitting Bayesian Neural Network Models — bnns","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"generic function fitting Bayesian Neural Network (BNN) models. dispatches methods based class input data.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"","code":"bnns(   formula,   data = list(),   L = 1,   nodes = 16,   act_fn = 2,   out_act_fn = 1,   iter = 1000,   warmup = 200,   thin = 1,   chains = 2,   cores = 2,   seed = 123,   prior_weights = NULL,   prior_bias = NULL,   prior_sigma = NULL,   verbose = FALSE,   refresh = max(iter/10, 1),   ... )"},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"formula symbolic description model fitted. formula specify response variable predictors (e.g., y ~ x1 + x2). y must continuous regression (out_act_fn = 1), numeric 0/1 binary classification (out_act_fn = 2), factor least 3 levels multi-classification (out_act_fn = 3). data data frame list containing variables model. Default empty list. L integer specifying number hidden layers neural network. Default 1. nodes integer vector specifying number nodes hidden layer. single value provided, applied layers. Default 16. act_fn integer vector specifying activation function(s) hidden layers. Options : 1 tanh 2 sigmoid (default) 3 ReLU 4 softplus out_act_fn integer specifying activation function output layer. Options : 1 linear (default) 2 sigmoid 3 softmax iter integer specifying total number iterations Stan sampler. Default 1e3. warmup integer specifying number warmup iterations Stan sampler. Default 2e2. thin integer specifying thinning interval Stan samples. Default 1. chains integer specifying number Markov chains. Default 2. cores integer specifying number CPU cores use parallel sampling. Default 2. seed integer specifying random seed reproducibility. Default 123. prior_weights list specifying prior distribution weights neural network. list must include two components: dist: character string specifying distribution type. Supported values \"normal\", \"uniform\", \"cauchy\". params: named list specifying parameters chosen distribution: \"normal\": Provide mean (mean distribution) sd (standard deviation). \"uniform\": Provide alpha (lower bound) beta (upper bound). \"cauchy\": Provide mu (location parameter) sigma (scale parameter). prior_weights NULL, default prior normal(0, 1) distribution. example: list(dist = \"normal\", params = list(mean = 0, sd = 1)) list(dist = \"uniform\", params = list(alpha = -1, beta = 1)) list(dist = \"cauchy\", params = list(mu = 0, sigma = 2.5)) prior_bias list specifying prior distribution biases neural network. list must include two components: dist: character string specifying distribution type. Supported values \"normal\", \"uniform\", \"cauchy\". params: named list specifying parameters chosen distribution: \"normal\": Provide mean (mean distribution) sd (standard deviation). \"uniform\": Provide alpha (lower bound) beta (upper bound). \"cauchy\": Provide mu (location parameter) sigma (scale parameter). prior_bias NULL, default prior normal(0, 1) distribution. example: list(dist = \"normal\", params = list(mean = 0, sd = 1)) list(dist = \"uniform\", params = list(alpha = -1, beta = 1)) list(dist = \"cauchy\", params = list(mu = 0, sigma = 2.5)) prior_sigma list specifying prior distribution sigma parameter regression models (out_act_fn = 1). allows setting priors standard deviation residuals. list must include two components: dist: character string specifying distribution type. Supported values \"half-normal\" \"inverse-gamma\". params: named list specifying parameters chosen distribution: \"half-normal\": Provide sd (standard deviation half-normal distribution). \"inverse-gamma\": Provide shape (shape parameter) scale (scale parameter). prior_sigma NULL, default prior half-normal(0, 1) distribution. example: list(dist = \"half_normal\", params = list(mean = 0, sd = 1)) list(dist = \"inv_gamma\", params = list(alpha = 1, beta = 1)) verbose TRUE FALSE: flag indicating whether print intermediate output Stan console, might helpful model debugging. refresh refresh (integer) can used control often progress sampling reported (.e. show progress every refresh iterations). default, refresh = max(iter/10, 1). progress indicator turned refresh <= 0. ... Currently use.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"result method dispatched class input data. Typically, object class \"bnns\" containing fitted model associated information.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"function serves generic interface different methods fitting Bayesian Neural Networks. specific method dispatched depends class input arguments, allowing flexibility types inputs supported.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"Bishop, C.M., 1995. Neural networks pattern recognition. Oxford university press. Carpenter, B., Gelman, ., Hoffman, M.D., Lee, D., Goodrich, B., Betancourt, M., Brubaker, M.., Guo, J., Li, P. Riddell, ., 2017. Stan: probabilistic programming language. Journal statistical software, 76. Neal, R.M., 2012. Bayesian learning neural networks (Vol. 118). Springer Science & Business Media.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic Function for Fitting Bayesian Neural Network Models — bnns","text":"","code":"# Example usage with formula interface: data <- data.frame(x1 = runif(10), x2 = runif(10), y = rnorm(10)) model <- bnns(y ~ -1 + x1 + x2,   data = data, L = 1, nodes = 2, act_fn = 1,   iter = 1e2, warmup = 5e1, chains = 1 ) #>  #> SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 2.8e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.28 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 7 #> Chain 1:            adapt_window = 38 #> Chain 1:            term_buffer = 5 #> Chain 1:  #> Chain 1: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 1: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 1: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 1: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 1: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 1: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 1: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 1: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 1: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 1: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 1: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 1: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.005 seconds (Warm-up) #> Chain 1:                0.004 seconds (Sampling) #> Chain 1:                0.009 seconds (Total) #> Chain 1:   # See the documentation for bnns.default for more details on the default implementation."},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal function for training the BNN — bnns_train","title":"Internal function for training the BNN — bnns_train","text":"function performs actual fitting Bayesian Neural Network. called exported bnns methods intended direct use.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal function for training the BNN — bnns_train","text":"","code":"bnns_train(   train_x,   train_y,   L = 1,   nodes = 16,   act_fn = 2,   out_act_fn = 1,   iter = 1000,   warmup = 200,   thin = 1,   chains = 2,   cores = 2,   seed = 123,   prior_weights = NULL,   prior_bias = NULL,   prior_sigma = NULL,   verbose = FALSE,   refresh = max(iter/10, 1),   ... )"},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal function for training the BNN — bnns_train","text":"train_x numeric matrix representing input features (predictors) training. Rows correspond observations, columns correspond features. train_y numeric vector representing target values training. length must match number rows train_x. L integer specifying number hidden layers neural network. Default 1. nodes integer vector specifying number nodes hidden layer. single value provided, applied layers. Default 16. act_fn integer vector specifying activation function(s) hidden layers. Options : 1 tanh 2 sigmoid (default) 3 ReLU 4 softplus out_act_fn integer specifying activation function output layer. Options : 1 linear (default) 2 sigmoid 3 softmax iter integer specifying total number iterations Stan sampler. Default 1e3. warmup integer specifying number warmup iterations Stan sampler. Default 2e2. thin integer specifying thinning interval Stan samples. Default 1. chains integer specifying number Markov chains. Default 2. cores integer specifying number CPU cores use parallel sampling. Default 2. seed integer specifying random seed reproducibility. Default 123. prior_weights list specifying prior distribution weights neural network. list must include two components: dist: character string specifying distribution type. Supported values \"normal\", \"uniform\", \"cauchy\". params: named list specifying parameters chosen distribution: \"normal\": Provide mean (mean distribution) sd (standard deviation). \"uniform\": Provide alpha (lower bound) beta (upper bound). \"cauchy\": Provide mu (location parameter) sigma (scale parameter). prior_weights NULL, default prior normal(0, 1) distribution. example: list(dist = \"normal\", params = list(mean = 0, sd = 1)) list(dist = \"uniform\", params = list(alpha = -1, beta = 1)) list(dist = \"cauchy\", params = list(mu = 0, sigma = 2.5)) prior_bias list specifying prior distribution biases neural network. list must include two components: dist: character string specifying distribution type. Supported values \"normal\", \"uniform\", \"cauchy\". params: named list specifying parameters chosen distribution: \"normal\": Provide mean (mean distribution) sd (standard deviation). \"uniform\": Provide alpha (lower bound) beta (upper bound). \"cauchy\": Provide mu (location parameter) sigma (scale parameter). prior_bias NULL, default prior normal(0, 1) distribution. example: list(dist = \"normal\", params = list(mean = 0, sd = 1)) list(dist = \"uniform\", params = list(alpha = -1, beta = 1)) list(dist = \"cauchy\", params = list(mu = 0, sigma = 2.5)) prior_sigma list specifying prior distribution sigma parameter regression models (out_act_fn = 1). allows setting priors standard deviation residuals. list must include two components: dist: character string specifying distribution type. Supported values \"half-normal\" \"inverse-gamma\". params: named list specifying parameters chosen distribution: \"half-normal\": Provide sd (standard deviation half-normal distribution). \"inverse-gamma\": Provide shape (shape parameter) scale (scale parameter). prior_sigma NULL, default prior half-normal(0, 1) distribution. example: list(dist = \"half_normal\", params = list(mean = 0, sd = 1)) list(dist = \"inv_gamma\", params = list(alpha = 1, beta = 1)) verbose TRUE FALSE: flag indicating whether print intermediate output Stan console, might helpful model debugging. refresh refresh (integer) can used control often progress sampling reported (.e. show progress every refresh iterations). default, refresh = max(iter/10, 1). progress indicator turned refresh <= 0. ... Currently use.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal function for training the BNN — bnns_train","text":"object class \"bnns\" containing following components: fit fitted Stan model object. call matched call. data list containing Stan data used model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Internal function for training the BNN — bnns_train","text":"function uses generate_stan_code function dynamically generate Stan code based specified number layers nodes. Stan used fit Bayesian Neural Network.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/bnns_train.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal function for training the BNN — bnns_train","text":"","code":"# Example usage: train_x <- matrix(runif(20), nrow = 10, ncol = 2) train_y <- rnorm(10) model <- bnns:::bnns_train(train_x, train_y,   L = 1, nodes = 2, act_fn = 2,   iter = 1e2, warmup = 5e1, chains = 1 ) #>  #> SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 1.3e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.13 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 7 #> Chain 1:            adapt_window = 38 #> Chain 1:            term_buffer = 5 #> Chain 1:  #> Chain 1: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 1: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 1: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 1: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 1: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 1: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 1: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 1: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 1: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 1: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 1: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 1: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.006 seconds (Warm-up) #> Chain 1:                0.005 seconds (Sampling) #> Chain 1:                0.011 seconds (Total) #> Chain 1:   # Access Stan model fit model$fit #> Inference for Stan model: anon_model. #> 1 chains, each with iter=100; warmup=50; thin=1;  #> post-warmup draws per chain=50, total post-warmup draws=50. #>  #>           mean se_mean   sd   2.5%   25%   50%   75% 97.5% n_eff Rhat #> w1[1,1]  -0.12    0.15 0.95  -1.81 -0.67 -0.17  0.47  1.70    42 1.02 #> w1[1,2]  -0.12    0.14 1.19  -2.48 -0.92 -0.09  0.75  1.86    72 0.98 #> w1[2,1]  -0.10    0.14 1.01  -1.72 -0.83 -0.15  0.58  1.64    54 0.98 #> w1[2,2]  -0.18    0.14 1.19  -2.50 -0.79 -0.14  0.71  1.72    73 0.99 #> b1[1]    -0.20    0.12 0.95  -1.75 -0.96 -0.20  0.38  1.61    65 1.01 #> b1[2]    -0.11    0.18 1.04  -1.98 -0.86 -0.22  0.55  1.79    35 1.01 #> w_out[1]  0.15    0.15 1.08  -1.99 -0.53  0.01  0.62  2.13    54 0.98 #> w_out[2]  0.17    0.09 0.87  -1.69 -0.12  0.23  0.67  1.72    85 0.98 #> b_out     0.10    0.08 0.63  -1.07 -0.25  0.15  0.45  1.46    65 1.00 #> sigma     0.77    0.02 0.20   0.45  0.61  0.75  0.89  1.14    85 0.98 #> lp__     -6.93    0.60 2.29 -10.76 -8.35 -6.48 -5.08 -3.86    15 1.07 #>  #> Samples were drawn using NUTS(diag_e) at Thu Jan  2 07:19:32 2025. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1)."},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Stan Code Based on Output Activation Function — generate_stan_code","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"function serves wrapper generate Stan code Bayesian neural networks tailored different types response variables. Based specified output activation function (out_act_fn), delegates code generation appropriate function continuous, binary, categorical response models.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"","code":"generate_stan_code(num_layers, nodes, out_act_fn = 1)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"num_layers integer specifying number hidden layers neural network. nodes vector integers, element specifies number nodes corresponding hidden layer. length vector must match num_layers. out_act_fn integer specifying output activation function, determining type response variable. Supported values : 1: Continuous response (identity function output layer). 2: Binary response (sigmoid function output layer). 3: Categorical response (softmax function output layer).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"character string containing Stan code specified Bayesian neural network model. Stan model includes data, parameters, transformed parameters, model blocks, adjusted based specified response type.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"function dynamically calls one following functions based value out_act_fn: Continuous response: Calls generate_stan_code_cont. Binary response: Calls generate_stan_code_bin. Categorical response: Calls generate_stan_code_cat. unsupported value provided out_act_fn, function throws error. generated Stan code adapted response type, including appropriate likelihood functions transformations.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Stan Code Based on Output Activation Function — generate_stan_code","text":"","code":"# Generate Stan code for a continuous response model stan_code <- generate_stan_code(num_layers = 2, nodes = c(10, 5), out_act_fn = 1) cat(stan_code) #>  #> data { #>   int<lower=1> n; #>   int<lower=1> m; #>   int<lower=1> L; #>   int<lower=1> nodes[L]; #>   matrix[n, m] X; #>   vector[n] y; #>   int<lower=1> act_fn[L]; #> } #>  #> parameters { #>   matrix[m, nodes[1]] w1; #>   vector[nodes[1]] b1; #>   matrix[nodes[1], nodes[2]] w2; #>   vector[nodes[2]] b2; #>   vector[nodes[L]] w_out; #>   real b_out; #>   real<lower=0> sigma; #> } #>  #> transformed parameters { #>   matrix[n, nodes[1]] z1; #>   matrix[n, nodes[1]] a1; #>   matrix[n, nodes[2]] z2; #>   matrix[n, nodes[2]] a2; #>   vector[n] y_hat; #>   z1 = X * w1 + rep_matrix(b1', n); #>   if (act_fn[1] == 1) a1 = tanh(z1); #>   else if (act_fn[1] == 2) a1 = inv_logit(z1); #>   else if (act_fn[1] == 3) a1 = log(1 + exp(z1)); #>   else a1 = fmax(rep_matrix(0, n, nodes[1]), z1); #>   z2 = a1 * w2 + rep_matrix(b2', n); #>   if (act_fn[2] == 1) a2 = tanh(z2); #>   else if (act_fn[2] == 2) a2 = inv_logit(z2); #>   else if (act_fn[2] == 3) a2 = log(1 + exp(z2)); #>   else a2 = fmax(rep_matrix(0, n, nodes[2]), z2); #>   y_hat = a2 * w_out + b_out; #> } #>  #> model { #>   to_vector(w1) ~ PRIOR_WEIGHT; #>   b1 ~ PRIOR_BIAS; #>   to_vector(w2) ~ PRIOR_WEIGHT; #>   b2 ~ PRIOR_BIAS; #>   w_out ~ PRIOR_WEIGHT; #>   b_out ~ PRIOR_BIAS; #>   sigma ~ PRIOR_SIGMA; #>   y ~ normal(y_hat, sigma); #> }  # Generate Stan code for a binary response model stan_code <- generate_stan_code(num_layers = 2, nodes = c(10, 5), out_act_fn = 2) cat(stan_code) #>  #> data { #>   int<lower=1> n; #>   int<lower=1> m; #>   int<lower=1> L; #>   int<lower=1> nodes[L]; #>   matrix[n, m] X; #>   array[n] int<lower=0, upper=1> y; #>   int<lower=1> act_fn[L]; #> } #>  #> parameters { #>   matrix[m, nodes[1]] w1; #>   vector[nodes[1]] b1; #>   matrix[nodes[1], nodes[2]] w2; #>   vector[nodes[2]] b2; #>   vector[nodes[L]] w_out; #>   real b_out; #> } #>  #> transformed parameters { #>   matrix[n, nodes[1]] z1; #>   matrix[n, nodes[1]] a1; #>   matrix[n, nodes[2]] z2; #>   matrix[n, nodes[2]] a2; #>   vector[n] y_hat; #>   z1 = X * w1 + rep_matrix(b1', n); #>   if (act_fn[1] == 1) a1 = tanh(z1); #>   else if (act_fn[1] == 2) a1 = inv_logit(z1); #>   else if (act_fn[1] == 3) a1 = log(1 + exp(z1)); #>   else a1 = fmax(rep_matrix(0, n, nodes[1]), z1); #>   z2 = a1 * w2 + rep_matrix(b2', n); #>   if (act_fn[2] == 1) a2 = tanh(z2); #>   else if (act_fn[2] == 2) a2 = inv_logit(z2); #>   else if (act_fn[2] == 3) a2 = log(1 + exp(z2)); #>   else a2 = fmax(rep_matrix(0, n, nodes[2]), z2); #>   y_hat = a2 * w_out + b_out; #> } #>  #> model { #>   to_vector(w1) ~ PRIOR_WEIGHT; #>   b1 ~ PRIOR_BIAS; #>   to_vector(w2) ~ PRIOR_WEIGHT; #>   b2 ~ PRIOR_BIAS; #>   w_out ~ PRIOR_WEIGHT; #>   b_out ~ PRIOR_BIAS; #>   y ~ bernoulli_logit(y_hat); #> }  # Generate Stan code for a categorical response model stan_code <- generate_stan_code(num_layers = 2, nodes = c(10, 5), out_act_fn = 3) cat(stan_code) #>  #> data { #>   int<lower=1> n; #>   int<lower=1> m; #>   int<lower=1> L; #>   int<lower=1> nodes[L]; #>   matrix[n, m] X; #>   array[n] int<lower=1> y; #>   int<lower=1> act_fn[L]; #>   int<lower=2> K; // Number of categories #> } #>  #> parameters { #>   matrix[m, nodes[1]] w1; #>   vector[nodes[1]] b1; #>   matrix[nodes[1], nodes[2]] w2; #>   vector[nodes[2]] b2; #>   matrix[nodes[L], K] w_out; #>   vector[K] b_out; #> } #>  #> transformed parameters { #>   matrix[n, nodes[1]] z1; #>   matrix[n, nodes[1]] a1; #>   matrix[n, nodes[2]] z2; #>   matrix[n, nodes[2]] a2; #>   matrix[n, K] y_hat; #>   z1 = X * w1 + rep_matrix(b1', n); #>   if (act_fn[1] == 1) a1 = tanh(z1); #>   else if (act_fn[1] == 2) a1 = inv_logit(z1); #>   else if (act_fn[1] == 3) a1 = log(1 + exp(z1)); #>   else a1 = fmax(rep_matrix(0, n, nodes[1]), z1); #>   z2 = a1 * w2 + rep_matrix(b2', n); #>   if (act_fn[2] == 1) a2 = tanh(z2); #>   else if (act_fn[2] == 2) a2 = inv_logit(z2); #>   else if (act_fn[2] == 3) a2 = log(1 + exp(z2)); #>   else a2 = fmax(rep_matrix(0, n, nodes[2]), z2); #>   y_hat = a2 * w_out + rep_matrix(b_out', n); #> } #>  #> model { #>   to_vector(w1) ~ PRIOR_WEIGHT; #>   b1 ~ PRIOR_BIAS; #>   to_vector(w2) ~ PRIOR_WEIGHT; #>   b2 ~ PRIOR_BIAS; #>   to_vector(w_out) ~ PRIOR_WEIGHT; #>   b_out ~ PRIOR_BIAS; #>   for (i in 1:n) y[i] ~ categorical_logit(y_hat[i]'); #> }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"function generates Stan code Bayesian neural network model designed predict binary response variables. Stan code dynamically constructed based specified number hidden layers nodes per layer. supports various activation functions hidden layers, including tanh, sigmoid, softplus relu. model uses Bernoulli likelihood binary outcomes.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"","code":"generate_stan_code_bin(num_layers, nodes)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"num_layers integer specifying number hidden layers neural network. nodes vector integers, element specifies number nodes corresponding hidden layer. length vector must match num_layers.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"character string containing Stan code specified Bayesian neural network model. Stan model includes data, parameters, transformed parameters, model blocks. code adjusted based whether network one multiple hidden layers.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"generated Stan code models binary response variable using neural network. hidden layers apply specified activation functions, output layer applies logistic function predict probability binary outcome. one hidden layer: function simplifies Stan code structure. multiple hidden layers: code dynamically includes additional layers based input arguments. Supported activation functions hidden layers: 1: Tanh 2: Sigmoid 3: Softplus 4: ReLU output layer uses logistic transformation (inv_logit) constrain predictions 0 1, aligns Bernoulli likelihood.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_bin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Stan Code for Binary Response Models — generate_stan_code_bin","text":"","code":"# Generate Stan code for a single hidden layer with 10 nodes stan_code <- generate_stan_code_bin(1, c(10)) cat(stan_code) #> data { #>   int<lower=1> n; #>   int<lower=1> m; #>   int<lower=1> L; #>   int<lower=1> nodes; #>   matrix[n, m] X; #>   array[n] int<lower=0, upper=1> y; #>   int<lower=1, upper=3> act_fn; #> } #>  #> parameters { #>   matrix[m, nodes] w1; #>   vector[nodes] b1; #>   vector[nodes] w_out; #>   real b_out; #> } #>  #> transformed parameters { #>   matrix[n, nodes] z1; #>   matrix[n, nodes] a1; #>   vector[n] y_hat; #>  #>   z1 = X * w1 + rep_matrix(b1', n); #>   if (act_fn == 1) a1 = tanh(z1); #>   else if (act_fn == 2) a1 = inv_logit(z1); #>   else if (act_fn == 3) a1 = log(1 + exp(z1)); #>   else a1 = fmax(rep_matrix(0, n, nodes), z1); #>  #>   y_hat = a1 * w_out + b_out; #> } #>  #> model { #>   to_vector(w1) ~ PRIOR_WEIGHT; #>   b1 ~ PRIOR_BIAS; #>   w_out ~ PRIOR_WEIGHT; #>   b_out ~ PRIOR_BIAS; #>   y ~ bernoulli_logit(y_hat); #> }  # Generate Stan code for two hidden layers with 8 and 4 nodes stan_code <- generate_stan_code_bin(2, c(8, 4)) cat(stan_code) #>  #> data { #>   int<lower=1> n; #>   int<lower=1> m; #>   int<lower=1> L; #>   int<lower=1> nodes[L]; #>   matrix[n, m] X; #>   array[n] int<lower=0, upper=1> y; #>   int<lower=1> act_fn[L]; #> } #>  #> parameters { #>   matrix[m, nodes[1]] w1; #>   vector[nodes[1]] b1; #>   matrix[nodes[1], nodes[2]] w2; #>   vector[nodes[2]] b2; #>   vector[nodes[L]] w_out; #>   real b_out; #> } #>  #> transformed parameters { #>   matrix[n, nodes[1]] z1; #>   matrix[n, nodes[1]] a1; #>   matrix[n, nodes[2]] z2; #>   matrix[n, nodes[2]] a2; #>   vector[n] y_hat; #>   z1 = X * w1 + rep_matrix(b1', n); #>   if (act_fn[1] == 1) a1 = tanh(z1); #>   else if (act_fn[1] == 2) a1 = inv_logit(z1); #>   else if (act_fn[1] == 3) a1 = log(1 + exp(z1)); #>   else a1 = fmax(rep_matrix(0, n, nodes[1]), z1); #>   z2 = a1 * w2 + rep_matrix(b2', n); #>   if (act_fn[2] == 1) a2 = tanh(z2); #>   else if (act_fn[2] == 2) a2 = inv_logit(z2); #>   else if (act_fn[2] == 3) a2 = log(1 + exp(z2)); #>   else a2 = fmax(rep_matrix(0, n, nodes[2]), z2); #>   y_hat = a2 * w_out + b_out; #> } #>  #> model { #>   to_vector(w1) ~ PRIOR_WEIGHT; #>   b1 ~ PRIOR_BIAS; #>   to_vector(w2) ~ PRIOR_WEIGHT; #>   b2 ~ PRIOR_BIAS; #>   w_out ~ PRIOR_WEIGHT; #>   b_out ~ PRIOR_BIAS; #>   y ~ bernoulli_logit(y_hat); #> }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"function generates Stan code modeling categorical response using neural networks multiple layers. generated code supports customizable activation functions layer softmax-based prediction categorical output.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"","code":"generate_stan_code_cat(num_layers, nodes)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"num_layers Integer. Number layers neural network. nodes Integer vector. Number nodes layer. length vector must match num_layers, values must positive.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"string containing Stan code specified neural network architecture categorical response model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"Stan code includes following components: Data Block: Defines inputs, response variable, layer configurations, activation functions. Parameters Block: Declares weights biases layers output layer. Transformed Parameters Block: Computes intermediate outputs (z ) layer calculates final predictions (y_hat) using softmax function. Model Block: Specifies priors parameters models categorical response using categorical_logit. Supported activation functions layer: 1: Hyperbolic tangent (tanh) 2: Logistic sigmoid (inv_logit) 3: Softplus (log(1 + exp(x))) Default: Rectified linear unit (ReLU) categorical response (y) assumed take integer values 1 K, K total number categories.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Stan Code for Neural Networks with Categorical Response — generate_stan_code_cat","text":"","code":"# Generate Stan code for a neural network with 3 layers num_layers <- 3 nodes <- c(10, 8, 6) # 10 nodes in the first layer, 8 in the second, 6 in the third stan_code <- generate_stan_code_cat(num_layers, nodes) cat(stan_code) #>  #> data { #>   int<lower=1> n; #>   int<lower=1> m; #>   int<lower=1> L; #>   int<lower=1> nodes[L]; #>   matrix[n, m] X; #>   array[n] int<lower=1> y; #>   int<lower=1> act_fn[L]; #>   int<lower=2> K; // Number of categories #> } #>  #> parameters { #>   matrix[m, nodes[1]] w1; #>   vector[nodes[1]] b1; #>   matrix[nodes[1], nodes[2]] w2; #>   vector[nodes[2]] b2; #>   matrix[nodes[2], nodes[3]] w3; #>   vector[nodes[3]] b3; #>   matrix[nodes[L], K] w_out; #>   vector[K] b_out; #> } #>  #> transformed parameters { #>   matrix[n, nodes[1]] z1; #>   matrix[n, nodes[1]] a1; #>   matrix[n, nodes[2]] z2; #>   matrix[n, nodes[2]] a2; #>   matrix[n, nodes[3]] z3; #>   matrix[n, nodes[3]] a3; #>   matrix[n, K] y_hat; #>   z1 = X * w1 + rep_matrix(b1', n); #>   if (act_fn[1] == 1) a1 = tanh(z1); #>   else if (act_fn[1] == 2) a1 = inv_logit(z1); #>   else if (act_fn[1] == 3) a1 = log(1 + exp(z1)); #>   else a1 = fmax(rep_matrix(0, n, nodes[1]), z1); #>   z2 = a1 * w2 + rep_matrix(b2', n); #>   if (act_fn[2] == 1) a2 = tanh(z2); #>   else if (act_fn[2] == 2) a2 = inv_logit(z2); #>   else if (act_fn[2] == 3) a2 = log(1 + exp(z2)); #>   else a2 = fmax(rep_matrix(0, n, nodes[2]), z2); #>   z3 = a2 * w3 + rep_matrix(b3', n); #>   if (act_fn[3] == 1) a3 = tanh(z3); #>   else if (act_fn[3] == 2) a3 = inv_logit(z3); #>   else if (act_fn[3] == 3) a3 = log(1 + exp(z3)); #>   else a3 = fmax(rep_matrix(0, n, nodes[3]), z3); #>   y_hat = a3 * w_out + rep_matrix(b_out', n); #> } #>  #> model { #>   to_vector(w1) ~ PRIOR_WEIGHT; #>   b1 ~ PRIOR_BIAS; #>   to_vector(w2) ~ PRIOR_WEIGHT; #>   b2 ~ PRIOR_BIAS; #>   to_vector(w3) ~ PRIOR_WEIGHT; #>   b3 ~ PRIOR_BIAS; #>   to_vector(w_out) ~ PRIOR_WEIGHT; #>   b_out ~ PRIOR_BIAS; #>   for (i in 1:n) y[i] ~ categorical_logit(y_hat[i]'); #> }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"function generates Stan code Bayesian neural network model designed predict continuous response variables. Stan code dynamically constructed based specified number hidden layers nodes per layer. supports various activation functions hidden layers, including tanh, sigmoid, softplus relu.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"","code":"generate_stan_code_cont(num_layers, nodes)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"num_layers integer specifying number hidden layers neural network. nodes vector integers, element specifies number nodes corresponding hidden layer. length vector must match num_layers.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"character string containing Stan code specified Bayesian neural network model. Stan model includes data, parameters, transformed parameters, model blocks. code adjusted based whether network one multiple hidden layers.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"generated Stan code models continuous response variable using neural network. hidden layers apply specified activation functions, output layer performs linear transformation predict response. likelihood assumes normally distributed residuals. one hidden layer: function simplifies Stan code structure. multiple hidden layers: code dynamically includes additional layers based input arguments. Supported activation functions hidden layers: 1: Tanh 2: Sigmoid 3: Softplus 4: ReLU","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/generate_stan_code_cont.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Stan Code for Continuous Response Models — generate_stan_code_cont","text":"","code":"# Generate Stan code for a single hidden layer with 10 nodes stan_code <- generate_stan_code_cont(1, c(10)) cat(stan_code) #> data { #>   int<lower=1> n; #>   int<lower=1> m; #>   int<lower=1> L; #>   int<lower=1> nodes; #>   matrix[n, m] X; #>   vector[n] y; #>   int<lower=1, upper=3> act_fn; #> } #>  #> parameters { #>   matrix[m, nodes] w1; #>   vector[nodes] b1; #>   vector[nodes] w_out; #>   real b_out; #>   real<lower=0> sigma; #> } #>  #> transformed parameters { #>   matrix[n, nodes] z1; #>   matrix[n, nodes] a1; #>   vector[n] y_hat; #>  #>   z1 = X * w1 + rep_matrix(b1', n); #>   if (act_fn == 1) a1 = tanh(z1); #>   else if (act_fn == 2) a1 = inv_logit(z1); #>   else if (act_fn == 3) a1 = log(1 + exp(z1)); #>   else a1 = fmax(rep_matrix(0, n, nodes), z1); #>  #>   y_hat = a1 * w_out + b_out; #> } #>  #> model { #>   to_vector(w1) ~ PRIOR_WEIGHT; #>   b1 ~ PRIOR_BIAS; #>   w_out ~ PRIOR_WEIGHT; #>   b_out ~ PRIOR_BIAS; #>   sigma ~ PRIOR_SIGMA; #>   y ~ normal(y_hat, sigma); #> }  # Generate Stan code for two hidden layers with 8 and 4 nodes stan_code <- generate_stan_code_cont(2, c(8, 4)) cat(stan_code) #>  #> data { #>   int<lower=1> n; #>   int<lower=1> m; #>   int<lower=1> L; #>   int<lower=1> nodes[L]; #>   matrix[n, m] X; #>   vector[n] y; #>   int<lower=1> act_fn[L]; #> } #>  #> parameters { #>   matrix[m, nodes[1]] w1; #>   vector[nodes[1]] b1; #>   matrix[nodes[1], nodes[2]] w2; #>   vector[nodes[2]] b2; #>   vector[nodes[L]] w_out; #>   real b_out; #>   real<lower=0> sigma; #> } #>  #> transformed parameters { #>   matrix[n, nodes[1]] z1; #>   matrix[n, nodes[1]] a1; #>   matrix[n, nodes[2]] z2; #>   matrix[n, nodes[2]] a2; #>   vector[n] y_hat; #>   z1 = X * w1 + rep_matrix(b1', n); #>   if (act_fn[1] == 1) a1 = tanh(z1); #>   else if (act_fn[1] == 2) a1 = inv_logit(z1); #>   else if (act_fn[1] == 3) a1 = log(1 + exp(z1)); #>   else a1 = fmax(rep_matrix(0, n, nodes[1]), z1); #>   z2 = a1 * w2 + rep_matrix(b2', n); #>   if (act_fn[2] == 1) a2 = tanh(z2); #>   else if (act_fn[2] == 2) a2 = inv_logit(z2); #>   else if (act_fn[2] == 3) a2 = log(1 + exp(z2)); #>   else a2 = fmax(rep_matrix(0, n, nodes[2]), z2); #>   y_hat = a2 * w_out + b_out; #> } #>  #> model { #>   to_vector(w1) ~ PRIOR_WEIGHT; #>   b1 ~ PRIOR_BIAS; #>   to_vector(w2) ~ PRIOR_WEIGHT; #>   b2 ~ PRIOR_BIAS; #>   w_out ~ PRIOR_WEIGHT; #>   b_out ~ PRIOR_BIAS; #>   sigma ~ PRIOR_SIGMA; #>   y ~ normal(y_hat, sigma); #> }"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_bin.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure Performance for Binary Classification Models — measure_bin","title":"Measure Performance for Binary Classification Models — measure_bin","text":"Evaluates performance binary classification model using confusion matrix accuracy.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_bin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure Performance for Binary Classification Models — measure_bin","text":"","code":"measure_bin(obs, pred, cut = 0.5)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_bin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Measure Performance for Binary Classification Models — measure_bin","text":"obs numeric integer vector observed binary class labels (0 1). pred numeric vector predicted probabilities positive class. cut numeric threshold (0 1) classify predictions binary labels.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_bin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Measure Performance for Binary Classification Models — measure_bin","text":"list containing: conf_mat confusion matrix comparing observed predicted class labels. accuracy proportion correct predictions. ROC ROC generated using pROC::roc AUC Area ROC curve.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_bin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Measure Performance for Binary Classification Models — measure_bin","text":"","code":"obs <- c(1, 0, 1, 1, 0) pred <- c(0.9, 0.4, 0.8, 0.7, 0.3) cut <- 0.5 measure_bin(obs, pred, cut) #> Setting levels: control = 0, case = 1 #> Setting direction: controls < cases #> $conf_mat #>    pred_label #> obs 0 1 #>   0 2 0 #>   1 0 3 #>  #> $accuracy #> [1] 1 #>  #> $ROC #>  #> Call: #> roc.default(response = obs, predictor = pred) #>  #> Data: pred in 2 controls (obs 0) < 3 cases (obs 1). #> Area under the curve: 1 #>  #> $AUC #> [1] 1 #>  # Returns: list(conf_mat = <confusion matrix>, accuracy = 1, ROC = <ROC>, AUC = 1)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure Performance for Multi-Class Classification Models — measure_cat","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"Evaluates performance multi-class classification model using log loss multiclass AUC.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"","code":"measure_cat(obs, pred)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"obs factor vector observed class labels. level represents unique class. pred numeric matrix predicted probabilities, row corresponds observation, column corresponds class. number columns must match number levels obs.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"list containing: log_loss negative log-likelihood averaged across observations. ROC ROC generated using pROC::roc AUC multiclass Area Curve (AUC) computed pROC::multiclass.roc.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"log loss calculated : $$-\\frac{1}{N} \\sum_{=1}^N \\sum_{c=1}^C y_{ic} \\log(p_{ic})$$ \\(y_{ic}\\) 1 observation \\(\\) belongs class \\(c\\), \\(p_{ic}\\) predicted probability class. AUC computed using pROC::multiclass.roc function, provides overall measure model performance multiclass classification.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Measure Performance for Multi-Class Classification Models — measure_cat","text":"","code":"library(pROC) #> Type 'citation(\"pROC\")' for a citation. #>  #> Attaching package: ‘pROC’ #> The following objects are masked from ‘package:stats’: #>  #>     cov, smooth, var obs <- factor(c(\"A\", \"B\", \"C\"), levels = LETTERS[1:3]) pred <- matrix(   c(     0.8, 0.1, 0.1,     0.2, 0.6, 0.2,     0.7, 0.2, 0.1   ),   nrow = 3, byrow = TRUE ) measure_cat(obs, pred) #> $log_loss #> [1] 1.012185 #>  #> $ROC #>  #> Call: #> multiclass.roc.default(response = obs, predictor = `colnames<-`(data.frame(pred),     levels(obs))) #>  #> Data: multivariate predictor `colnames<-`(data.frame(pred), levels(obs)) with 3 levels of obs: A, B, C. #> Multi-class area under the curve: 0.75 #>  #> $AUC #> [1] 0.75 #>  # Returns: list(log_loss = 1.012185, ROC = <ROC>, AUC = 0.75)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cont.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure Performance for Continuous Response Models — measure_cont","title":"Measure Performance for Continuous Response Models — measure_cont","text":"Evaluates performance continuous response model using RMSE MAE.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cont.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure Performance for Continuous Response Models — measure_cont","text":"","code":"measure_cont(obs, pred)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cont.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Measure Performance for Continuous Response Models — measure_cont","text":"obs numeric vector observed (true) values. pred numeric vector predicted values.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cont.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Measure Performance for Continuous Response Models — measure_cont","text":"list containing: rmse Root Mean Squared Error. mae Mean Absolute Error.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/measure_cont.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Measure Performance for Continuous Response Models — measure_cont","text":"","code":"obs <- c(3.2, 4.1, 5.6) pred <- c(3.0, 4.3, 5.5) measure_cont(obs, pred) #> $rmse #> [1] 0.1732051 #>  #> $mae #> [1] 0.1666667 #>  # Returns: list(rmse = 0.1732051, mae = 0.1666667)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Method for ","title":"Predict Method for ","text":"Generates predictions fitted Bayesian Neural Network (BNN) model.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Method for ","text":"","code":"# S3 method for class 'bnns' predict(object, newdata = NULL, ...)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Method for ","text":"object object class \"bnns\", typically result call bnns.default. newdata matrix data frame new input data predictions required. NULL, predictions made training data used fit model. ... Additional arguments (currently used).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Method for ","text":"matrix/array predicted values(regression)/probabilities(classification) first dimension corresponds rows newdata training data newdata NULL. Second dimension corresponds number posterior samples. case out_act_fn = 3, third dimension corresponds class.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict Method for ","text":"function uses posterior distribution Stan model bnns object compute predictions provided input data.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/predict.bnns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Method for ","text":"","code":"# Example usage: data <- data.frame(x1 = runif(10), x2 = runif(10), y = rnorm(10)) model <- bnns(y ~ -1 + x1 + x2,   data = data, L = 1, nodes = 2, act_fn = 2,   iter = 1e2, warmup = 5e1, chains = 1 ) #>  #> SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 1.2e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.12 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 7 #> Chain 1:            adapt_window = 38 #> Chain 1:            term_buffer = 5 #> Chain 1:  #> Chain 1: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 1: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 1: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 1: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 1: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 1: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 1: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 1: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 1: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 1: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 1: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 1: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.006 seconds (Warm-up) #> Chain 1:                0.006 seconds (Sampling) #> Chain 1:                0.012 seconds (Total) #> Chain 1:  new_data <- data.frame(x1 = runif(5), x2 = runif(5)) predictions <- predict(model, newdata = new_data) print(predictions) #>           [,1]      [,2]      [,3]      [,4]     [,5]      [,6]         [,7] #> [1,] 0.7756039 0.9241748 0.9410701 0.7175170 1.209953 0.6779093  0.056287477 #> [2,] 0.5274012 0.6797697 0.8305420 0.7123081 1.340933 0.7405154 -0.004584759 #> [3,] 0.5366830 0.6906523 0.8854969 0.7425104 1.353107 0.7080338 -0.008533404 #> [4,] 0.7026320 0.8538433 1.0626398 0.7989444 1.297590 0.6182785  0.020209716 #> [5,] 0.8053698 0.9560107 1.0389642 0.7619332 1.223467 0.6274364  0.055357283 #>           [,8]      [,9]     [,10]     [,11]     [,12]    [,13]     [,14] #> [1,] 0.2192402 0.6252391 0.3485442 0.8755397 0.9855726 1.295056 0.5972593 #> [2,] 0.2985333 0.5884889 0.4713693 0.9402093 0.9353909 1.475009 0.8292352 #> [3,] 0.3023831 0.5896633 0.4813674 0.9352218 0.9575518 1.476465 0.8886360 #> [4,] 0.2695596 0.6124992 0.4204003 0.8990557 1.0479789 1.394439 0.8540658 #> [5,] 0.2209893 0.6329821 0.3512076 0.8698143 1.0403836 1.288722 0.6537522 #>            [,15]    [,16]       [,17]     [,18]    [,19]      [,20]     [,21] #> [1,] -0.08219813 1.272085 -0.02941814 0.8997630 1.124548 0.11868208 0.1506241 #> [2,]  0.07473391 1.351100 -0.03495368 0.8759040 1.259050 0.13347404 0.5461627 #> [3,]  0.09981937 1.358394 -0.04486904 0.8848493 1.229786 0.11430572 0.6009640 #> [4,]  0.05204759 1.334609 -0.05497382 0.9278860 1.102281 0.06034536 0.5045695 #> [5,] -0.05978176 1.282026 -0.04549019 0.9325869 1.071372 0.07769624 0.2193141 #>          [,22]     [,23]     [,24]      [,25]     [,26]     [,27]    [,28] #> [1,] 0.9399344 0.6420464 0.7805652 0.04489815 0.9462384 0.8090530 1.054941 #> [2,] 0.8426657 0.7026264 0.8561840 0.58965411 1.0469689 0.7834499 1.336717 #> [3,] 0.8452041 0.7362098 0.8775020 0.69303687 1.0265965 0.7981392 1.335363 #> [4,] 0.8424971 0.7573083 0.8730560 0.62436389 0.9345661 0.8324936 1.189646 #> [5,] 0.9089978 0.6902354 0.8093155 0.21283164 0.9154875 0.8282119 1.018600 #>          [,29]     [,30]     [,31]    [,32]     [,33]        [,34]     [,35] #> [1,] 0.4934070 1.0903272 0.8542839 1.579676 0.7451051  0.116021660 0.6473854 #> [2,] 0.5697892 0.8117763 0.9876158 1.438551 0.8047621  0.143304347 0.8114204 #> [3,] 0.5852896 0.7717820 0.9612654 1.428864 0.8092999  0.100351516 0.8165581 #> [4,] 0.5770024 0.8716340 0.8319319 1.492172 0.7822026 -0.009280382 0.7391522 #> [5,] 0.5103425 1.0595219 0.8014213 1.575937 0.7496358  0.043801009 0.6434766 #>          [,36]     [,37]     [,38]     [,39]     [,40]     [,41]     [,42] #> [1,] 0.2199281 0.7009241 0.4145399 0.6737448 0.6315728 0.8211920 0.9140652 #> [2,] 0.2603512 0.4614903 0.3129261 0.5386024 0.8028119 0.8886478 0.9272726 #> [3,] 0.2606480 0.4813626 0.3384811 0.6176272 0.8260684 0.8883431 0.9175681 #> [4,] 0.2376863 0.5855625 0.4331744 0.8160060 0.7497064 0.8458918 0.8891194 #> [5,] 0.2099345 0.7186231 0.4465301 0.7856927 0.6374684 0.8129655 0.8961421 #>          [,43]     [,44]     [,45]     [,46]     [,47]     [,48]     [,49] #> [1,] 0.4323292 0.5588161 0.7974062 0.6139895 0.4714900 0.5247870 0.8506967 #> [2,] 0.4640039 0.6813060 0.6994755 0.5419306 0.8468898 0.5699353 0.9795010 #> [3,] 0.4834406 0.6741956 0.7052439 0.5966619 0.8498388 0.5514244 0.9948074 #> [4,] 0.5005677 0.5900440 0.7726378 0.7356999 0.6682682 0.4931920 0.9726315 #> [5,] 0.4598865 0.5397357 0.8116951 0.7005395 0.4729705 0.4937322 0.8639691 #>          [,50] #> [1,] 0.7108677 #> [2,] 0.7986971 #> [3,] 0.7636826 #> [4,] 0.6415561 #> [5,] 0.6457909"},{"path":"https://swarnendu-stat.github.io/bnns/reference/print.bnns.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for ","title":"Print Method for ","text":"Displays summary fitted Bayesian Neural Network (BNN) model, including function call Stan fit details.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/print.bnns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for ","text":"","code":"# S3 method for class 'bnns' print(x, ...)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/print.bnns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for ","text":"x object class \"bnns\", typically result call bnns.default. ... Additional arguments (currently used).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/print.bnns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for ","text":"function called side effects return value. prints following: function call used generate \"bnns\" object. summary Stan fit object stored x$fit.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/print.bnns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print Method for ","text":"","code":"# Example usage: data <- data.frame(x1 = runif(10), x2 = runif(10), y = rnorm(10)) model <- bnns(y ~ -1 + x1 + x2,   data = data, L = 1, nodes = 2, act_fn = 2,   iter = 1e2, warmup = 5e1, chains = 1 ) #>  #> SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 1.2e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.12 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 7 #> Chain 1:            adapt_window = 38 #> Chain 1:            term_buffer = 5 #> Chain 1:  #> Chain 1: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 1: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 1: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 1: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 1: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 1: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 1: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 1: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 1: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 1: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 1: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 1: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.007 seconds (Warm-up) #> Chain 1:                0.006 seconds (Sampling) #> Chain 1:                0.013 seconds (Total) #> Chain 1:  print(model) #> Call: #> bnns.default(formula = y ~ -1 + x1 + x2, data = data, L = 1,  #>     nodes = 2, act_fn = 2, iter = 100, warmup = 50, chains = 1) #>  #> Stan fit: #> Inference for Stan model: anon_model. #> 1 chains, each with iter=100; warmup=50; thin=1;  #> post-warmup draws per chain=50, total post-warmup draws=50. #>  #>            mean se_mean   sd   2.5%    25%    50%    75% 97.5% n_eff Rhat #> w1[1,1]    0.01    0.20 1.26  -2.43  -0.74   0.03   0.94  2.58    39 1.02 #> w1[1,2]   -0.01    0.12 0.72  -1.28  -0.40   0.02   0.44  1.47    37 0.98 #> w1[2,1]   -0.07    0.17 1.21  -2.25  -0.74  -0.16   0.52  2.31    53 1.00 #> w1[2,2]   -0.10    0.12 0.86  -1.82  -0.61  -0.18   0.48  1.44    49 0.99 #> b1[1]      0.09    0.11 0.98  -1.62  -0.52   0.09   0.77  1.86    85 1.03 #> b1[2]      0.11    0.14 0.97  -1.36  -0.65   0.06   1.02  1.64    45 1.00 #> w_out[1]   0.12    0.12 1.10  -1.79  -0.75   0.14   1.11  1.84    85 0.98 #> w_out[2]   0.29    0.15 1.13  -1.46  -0.58   0.23   1.14  2.25    54 0.98 #> b_out      0.21    0.08 0.59  -0.80  -0.27   0.14   0.58  1.37    59 0.98 #> sigma      1.10    0.03 0.25   0.71   0.91   1.06   1.27  1.65    55 0.98 #> lp__     -11.39    0.40 2.10 -15.87 -12.54 -10.89 -10.17 -7.96    28 1.12 #>  #> Samples were drawn using NUTS(diag_e) at Thu Jan  2 07:21:44 2025. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1)."},{"path":"https://swarnendu-stat.github.io/bnns/reference/relu.html","id":null,"dir":"Reference","previous_headings":"","what":"relu transformation — relu","title":"relu transformation — relu","text":"relu transformation","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/relu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"relu transformation — relu","text":"","code":"relu(x)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/relu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"relu transformation — relu","text":"x numeric vector matrix relu transformation going applied.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/relu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"relu transformation — relu","text":"numeric vector matrix relu transformation.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/relu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"relu transformation — relu","text":"","code":"relu(matrix(1:4, , nrow = 2)) #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4"},{"path":"https://swarnendu-stat.github.io/bnns/reference/sigmoid.html","id":null,"dir":"Reference","previous_headings":"","what":"sigmoid transformation — sigmoid","title":"sigmoid transformation — sigmoid","text":"sigmoid transformation","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/sigmoid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sigmoid transformation — sigmoid","text":"","code":"sigmoid(x)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/sigmoid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sigmoid transformation — sigmoid","text":"x numeric vector matrix sigmoid transformation going applied.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/sigmoid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sigmoid transformation — sigmoid","text":"numeric vector matrix sigmoid transformation.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/sigmoid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"sigmoid transformation — sigmoid","text":"","code":"sigmoid(matrix(1:4, nrow = 2)) #>           [,1]      [,2] #> [1,] 0.7310586 0.9525741 #> [2,] 0.8807971 0.9820138"},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Softmax Function to a 3D Array — softmax_3d","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"function applies softmax transformation along third dimension 3D array. softmax function converts raw scores probabilities sum 1 slice along third dimension.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"","code":"softmax_3d(x)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"x 3D array. input array softmax function applied.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"3D array dimensions x, values along third dimension transformed using softmax function.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"softmax transformation computed : $$\\text{softmax}(x_{ijk}) = \\frac{\\exp(x_{ijk})}{\\sum_{l} \\exp(x_{ijl})}$$ applied pair indices (, j) across third dimension (k). function processes input array slice--slice first two dimensions (, j), normalizing values along third dimension (k) slice.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softmax_3d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Softmax Function to a 3D Array — softmax_3d","text":"","code":"# Example: Apply softmax to a 3D array x <- array(runif(24), dim = c(2, 3, 4)) # Random 3D array (2x3x4) softmax_result <- softmax_3d(x)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/softplus.html","id":null,"dir":"Reference","previous_headings":"","what":"softplus transformation — softplus","title":"softplus transformation — softplus","text":"softplus transformation","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softplus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"softplus transformation — softplus","text":"","code":"softplus(x)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/softplus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"softplus transformation — softplus","text":"x numeric vector matrix softplus transformation going applied.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softplus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"softplus transformation — softplus","text":"numeric vector matrix softplus transformation.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/softplus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"softplus transformation — softplus","text":"","code":"softplus(matrix(1:4, nrow = 2)) #>          [,1]     [,2] #> [1,] 1.313262 3.048587 #> [2,] 2.126928 4.018150"},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"Provides comprehensive summary fitted Bayesian Neural Network (BNN) model, including details model call, data, network architecture, posterior distributions, model fitting information.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"","code":"# S3 method for class 'bnns' summary(object, ...)"},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"object object class bnns, representing fitted Bayesian Neural Network model. ... Additional arguments (currently unused).","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"list (returned invisibly) containing following elements: \"Number observations\": number observations training data. \"Number features\": number features training data. \"Number hidden layers\": number hidden layers neural network. \"Nodes per layer\": comma-separated string representing number nodes hidden layer. \"Activation functions\": comma-separated string representing activation functions used hidden layer. \"Output activation function\": activation function used output layer. \"Stanfit Summary\": summary Stan model, including key parameter posterior distributions. \"Iterations\": total number iterations used sampling Bayesian model. \"Warmup\": number iterations used warmup Bayesian model. \"Thinning\": thinning interval used Bayesian model. \"Chains\": number Markov chains used Bayesian model. \"Performance\": Predictive performance metrics, vary based output activation function. function also prints summary console.","code":""},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"function prints following information: Call: original function call used fit model. Data Summary: Number observations features training data. Network Architecture: Structure BNN including number hidden layers, nodes per layer, activation functions. Posterior Summary: Summarized posterior distributions key parameters (e.g., weights, biases, noise parameter). Model Fit Information: Bayesian sampling details, including number iterations, warmup period, thinning, chains. Notes: Remarks warnings, checks convergence diagnostics.","code":""},{"path":[]},{"path":"https://swarnendu-stat.github.io/bnns/reference/summary.bnns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of a Bayesian Neural Network (BNN) Model — summary.bnns","text":"","code":"# Fit a Bayesian Neural Network data <- data.frame(x1 = runif(10), x2 = runif(10), y = rnorm(10)) model <- bnns(y ~ -1 + x1 + x2,   data = data, L = 1, nodes = 2, act_fn = 2,   iter = 1e2, warmup = 5e1, chains = 1 ) #>  #> SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 1.2e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.12 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 7 #> Chain 1:            adapt_window = 38 #> Chain 1:            term_buffer = 5 #> Chain 1:  #> Chain 1: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 1: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 1: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 1: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 1: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 1: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 1: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 1: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 1: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 1: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 1: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 1: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.009 seconds (Warm-up) #> Chain 1:                0.007 seconds (Sampling) #> Chain 1:                0.016 seconds (Total) #> Chain 1:   # Get a summary of the model summary(model) #> Call: #> bnns.default(formula = y ~ -1 + x1 + x2, data = data, L = 1,  #>     nodes = 2, act_fn = 2, iter = 100, warmup = 50, chains = 1) #>  #> Data Summary: #> Number of observations: 10  #> Number of features: 2  #>  #> Network Architecture: #> Number of hidden layers: 1  #> Nodes per layer: 2  #> Activation functions: 2  #> Output activation function: 1  #>  #> Posterior Summary (Key Parameters): #>                  mean    se_mean        sd      2.5%        25%          50% #> w_out[1] -0.045842255 0.10757392 0.9914820 -1.983948 -0.7288537 -0.069427593 #> w_out[2]  0.267836731 0.11056643 0.9377603 -1.147143 -0.3661931  0.311119189 #> b_out     0.008583087 0.09370663 0.5844196 -1.098855 -0.3184984  0.002290707 #> sigma     0.693624929 0.04177952 0.1995585  0.420497  0.5564548  0.613698101 #>                75%     97.5%    n_eff      Rhat #> w_out[1] 0.5979316 1.5665296 84.94850 0.9911575 #> w_out[2] 0.7764748 1.9368892 71.93448 0.9817585 #> b_out    0.4613825 0.8882911 38.89635 0.9893630 #> sigma    0.8395889 1.1112311 22.81463 1.0312801 #>  #> Model Fit Information: #> Iterations: 100  #> Warmup: 50  #> Thinning: 1  #> Chains: 1  #>  #> Predictive Performance: #> RMSE (training): 0.5566119  #> MAE (training): 0.3947371  #>  #> Notes: #> Check convergence diagnostics for parameters with high R-hat values."},{"path":"https://swarnendu-stat.github.io/bnns/news/index.html","id":"bnns-010","dir":"Changelog","previous_headings":"","what":"bnns 0.1.0","title":"bnns 0.1.0","text":"Initial release bnns package. Implements Bayesian Neural Networks using Stan. Provides flexible model specification formula Bayesian estimation.","code":""}]
